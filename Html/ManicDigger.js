// Generated automatically with "cito". Do not edit.

function Acceleration()
{
	this.acceleration1 = null;
	this.acceleration2 = null;
	this.acceleration3 = null;
	this.setDefault();
}

Acceleration.prototype.setDefault = function() {
	this.acceleration1 = 0.9;
	this.acceleration2 = 2;
	this.acceleration3 = 700;
}

function Action_()
{
}

function AngleInterpolation()
{
}

AngleInterpolation.interpolateAngle256 = function(platform, a, b, progress) {
	if (progress != 0 && b != a) {
		var diff = AngleInterpolation.normalizeAngle256(b - a);
		if (diff >= 128) {
			diff -= 256;
		}
		a += platform.floatToInt(progress * diff);
	}
	return AngleInterpolation.normalizeAngle256(a);
}

AngleInterpolation.interpolateAngle360 = function(platform, a, b, progress) {
	if (progress != 0 && b != a) {
		var diff = AngleInterpolation.normalizeAngle360(platform, b - a);
		if (diff >= 180) {
			diff -= 360;
		}
		a += progress * diff;
	}
	return AngleInterpolation.normalizeAngle360(platform, a);
}

AngleInterpolation.normalizeAngle256 = function(v) {
	return (v + 16383) % 256;
}

AngleInterpolation.normalizeAngle360 = function(platform, v) {
	return platform.floatModulo(v + 16200, 360);
}

function AnimatedModel()
{
	this.animations = null;
	this.animationsCount = 0;
	this.global = null;
	this.keyframes = null;
	this.keyframesCount = 0;
	this.nodes = null;
	this.nodesCount = 0;
	this.global = new AnimationGlobal();
}

function TableBinding()
{
}

function AnimatedModelBinding()
{
	this.m = null;
	this.p = null;
}
AnimatedModelBinding.prototype = new TableBinding();

AnimatedModelBinding.prototype.floatParse = function(s) {
	var ret = new FloatRef();
	this.p.floatTryParse(s, ret);
	return ret.value;
}

AnimatedModelBinding.prototype.get = function(table, index, items) {
	if (table == "nodes") {
		var k = this.m.nodes[index];
		items.set("name", k.name);
		items.set("paren", k.parentName);
		items.set("x", this.p.floatToString(k.posx));
		items.set("y", this.p.floatToString(k.posy));
		items.set("z", this.p.floatToString(k.posz));
		items.set("rotx", this.p.floatToString(k.rotatex));
		items.set("roty", this.p.floatToString(k.rotatey));
		items.set("rotz", this.p.floatToString(k.rotatez));
		items.set("sizex", this.p.floatToString(k.sizex));
		items.set("sizey", this.p.floatToString(k.sizey));
		items.set("sizez", this.p.floatToString(k.sizez));
		items.set("u", this.p.floatToString(k.u));
		items.set("v", this.p.floatToString(k.v));
		items.set("pivx", this.p.floatToString(k.pivotx));
		items.set("pivy", this.p.floatToString(k.pivoty));
		items.set("pivz", this.p.floatToString(k.pivotz));
		items.set("scalx", this.p.floatToString(k.scalex));
		items.set("scaly", this.p.floatToString(k.scaley));
		items.set("scalz", this.p.floatToString(k.scalez));
		items.set("head", this.p.floatToString(k.head));
	}
	if (table == "keyframes") {
		var k = this.m.keyframes[index];
		items.set("anim", k.animationName);
		items.set("node", k.nodeName);
		items.set("frame", this.p.floatToString(k.frame));
		items.set("type", KeyframeType.getName(k.frame));
		items.set("x", this.p.floatToString(k.x));
		items.set("y", this.p.floatToString(k.y));
		items.set("z", this.p.floatToString(k.z));
	}
	if (table == "animations") {
		var k = this.m.animations[index];
		items.set("name", k.name);
		items.set("len", this.p.floatToString(k.length));
	}
	if (table == "global") {
		var global = this.m.global;
		items.set("texw", this.p.floatToString(global.texw));
		items.set("texh", this.p.floatToString(global.texh));
	}
}

AnimatedModelBinding.prototype.getTables = function(name, count) {
	name[0] = "nodes";
	count[0] = this.m.nodesCount;
	name[1] = "keyframes";
	count[1] = this.m.keyframesCount;
	name[2] = "animations";
	count[2] = this.m.animationsCount;
	name[3] = "global";
	count[3] = 1;
}

AnimatedModelBinding.prototype.intParse = function(s) {
	return this.p.floatToInt(this.floatParse(s));
}

AnimatedModelBinding.prototype.set = function(table, index, column, value) {
	if (table == "nodes") {
		if (index >= this.m.nodesCount) {
			this.m.nodesCount = index + 1;
		}
		if (this.m.nodes[index] == null) {
			this.m.nodes[index] = new Node();
		}
		var k = this.m.nodes[index];
		if (column == "name") {
			k.name = value;
		}
		if (column == "paren") {
			k.parentName = value;
		}
		if (column == "x") {
			k.posx = this.floatParse(value);
		}
		if (column == "y") {
			k.posy = this.floatParse(value);
		}
		if (column == "z") {
			k.posz = this.floatParse(value);
		}
		if (column == "rotx") {
			k.rotatex = this.floatParse(value);
		}
		if (column == "roty") {
			k.rotatey = this.floatParse(value);
		}
		if (column == "rotz") {
			k.rotatez = this.floatParse(value);
		}
		if (column == "sizex") {
			k.sizex = this.floatParse(value);
		}
		if (column == "sizey") {
			k.sizey = this.floatParse(value);
		}
		if (column == "sizez") {
			k.sizez = this.floatParse(value);
		}
		if (column == "u") {
			k.u = this.floatParse(value);
		}
		if (column == "v") {
			k.v = this.floatParse(value);
		}
		if (column == "pivx") {
			k.pivotx = this.floatParse(value);
		}
		if (column == "pivy") {
			k.pivoty = this.floatParse(value);
		}
		if (column == "pivz") {
			k.pivotz = this.floatParse(value);
		}
		if (column == "scalx") {
			k.scalex = this.floatParse(value);
		}
		if (column == "scaly") {
			k.scaley = this.floatParse(value);
		}
		if (column == "scalz") {
			k.scalez = this.floatParse(value);
		}
		if (column == "head") {
			k.head = this.floatParse(value);
		}
	}
	if (table == "keyframes") {
		if (index >= this.m.keyframesCount) {
			this.m.keyframesCount = index + 1;
		}
		if (this.m.keyframes[index] == null) {
			this.m.keyframes[index] = new Keyframe();
		}
		var k = this.m.keyframes[index];
		if (column == "anim") {
			k.animationName = value;
		}
		if (column == "node") {
			k.nodeName = value;
		}
		if (column == "frame") {
			k.frame = this.intParse(value);
		}
		if (column == "type") {
			k.keyframeType = KeyframeType.getValue(value);
		}
		if (column == "x") {
			k.x = this.floatParse(value);
		}
		if (column == "y") {
			k.y = this.floatParse(value);
		}
		if (column == "z") {
			k.z = this.floatParse(value);
		}
	}
	if (table == "animations") {
		if (index >= this.m.animationsCount) {
			this.m.animationsCount = index + 1;
		}
		if (this.m.animations[index] == null) {
			this.m.animations[index] = new Animation();
		}
		var k = this.m.animations[index];
		if (column == "name") {
			k.name = value;
		}
		if (column == "len") {
			k.length = this.intParse(value);
		}
	}
	if (table == "global") {
		var global = this.m.global;
		if (column == "texw") {
			global.texw = this.intParse(value);
		}
		if (column == "texh") {
			global.texh = this.intParse(value);
		}
	}
}

function AnimatedModelRenderer()
{
	this.anim = 0;
	this.frame = null;
	this.game = null;
	this.m = null;
	this.tempVec3 = null;
	this.tempframes = null;
	this.tempframesCount = null;
	this.tempframes = new Array(256);
	this.tempframesCount = new IntRef();
	this.tempVec3 = new Float32Array(new ArrayBuffer(3 << 2));
}

AnimatedModelRenderer.prototype.drawNode = function(parent, headDeg, light) {
	for (var i = 0; i < this.m.nodesCount; i++) {
		var n = this.m.nodes[i];
		if (n == null) {
			continue;
		}
		if (n.parentName != parent) {
			continue;
		}
		this.game.gLPushMatrix();
		var r = new Array(6);
		r = CuboidRenderer.cuboidNet(n.sizex, n.sizey, n.sizez, n.u, n.v);
		CuboidRenderer.cuboidNetNormalize(r, this.m.global.texw, this.m.global.texh);
		this.getAnimation(n, this.tempVec3, 5);
		if (this.tempVec3[0] != 0 && this.tempVec3[1] != 0 && this.tempVec3[2] != 0) {
			this.game.gLScale(this.tempVec3[0], this.tempVec3[1], this.tempVec3[2]);
		}
		this.getAnimation(n, this.tempVec3, 1);
		this.tempVec3[0] /= 16;
		this.tempVec3[1] /= 16;
		this.tempVec3[2] /= 16;
		if (!this.isZero(this.tempVec3)) {
			this.game.gLTranslate(this.tempVec3[0], this.tempVec3[1], this.tempVec3[2]);
		}
		this.getAnimation(n, this.tempVec3, 2);
		if (this.tempVec3[0] != 0) {
			this.game.gLRotate(this.tempVec3[0], 1, 0, 0);
		}
		if (this.tempVec3[1] != 0) {
			this.game.gLRotate(this.tempVec3[1], 0, 1, 0);
		}
		if (this.tempVec3[2] != 0) {
			this.game.gLRotate(this.tempVec3[2], 0, 0, 1);
		}
		if (n.head == 1) {
			this.game.gLRotate(headDeg, 1, 0, 0);
		}
		this.getAnimation(n, this.tempVec3, 4);
		this.tempVec3[0] /= 16;
		this.tempVec3[1] /= 16;
		this.tempVec3[2] /= 16;
		this.game.gLTranslate(this.tempVec3[0], this.tempVec3[1], this.tempVec3[2]);
		this.getAnimation(n, this.tempVec3, 3);
		this.tempVec3[0] /= 16;
		this.tempVec3[1] /= 16;
		this.tempVec3[2] /= 16;
		CuboidRenderer.drawCuboid2(this.game, 0 - this.tempVec3[0] / (2), 0 - this.tempVec3[1] / (2), 0 - this.tempVec3[2] / (2), this.tempVec3[0], this.tempVec3[1], this.tempVec3[2], r, light);
		this.drawNode(n.name, headDeg, light);
		this.game.gLPopMatrix();
	}
}

AnimatedModelRenderer.prototype.getAnimation = function(node, ret, type) {
	this.getFrames(node.name, type, this.tempframes, this.tempframesCount);
	var currentI = this.getFrameCurrent(this.tempframes, this.tempframesCount.value);
	if (currentI == -1) {
		this.getDefaultFrame(node, type, ret);
		return;
	}
	var nextI = (currentI + 1) % this.tempframesCount.value;
	var current = this.tempframes[currentI];
	var next = this.tempframes[nextI];
	var t;
	var length = this.m.animations[this.anim].length;
	if (next.frame == current.frame) {
		t = 0;
	}
	else if (next.frame > current.frame) {
		t = (this.frame - current.frame) / (next.frame - current.frame);
	}
	else {
		var end = 0;
		var begin = 0;
		if (this.frame >= current.frame) {
			end = this.frame - current.frame;
		}
		else {
			end = length - current.frame;
			begin = this.frame;
		}
		t = (end + begin) / (length - current.frame + next.frame);
	}
	ret[0] = this.lerp(current.x, next.x, t);
	ret[1] = this.lerp(current.y, next.y, t);
	ret[2] = this.lerp(current.z, next.z, t);
}

AnimatedModelRenderer.prototype.getAnimationCount = function() {
	if (this.m == null) {
		return 0;
	}
	return this.m.animationsCount;
}

AnimatedModelRenderer.prototype.getAnimationFrame = function() {
	return this.frame;
}

AnimatedModelRenderer.prototype.getAnimationId = function(animationName) {
	for (var i = 0; i < this.m.animationsCount; i++) {
		if (this.m.animations[i].name == animationName) {
			return i;
		}
	}
	return -1;
}

AnimatedModelRenderer.prototype.getAnimationLength = function() {
	if (this.m == null) {
		return 0;
	}
	if (this.m.animations == null) {
		return 0;
	}
	if (this.m.animations[this.anim] == null) {
		return 0;
	}
	return this.m.animations[this.anim].length;
}

AnimatedModelRenderer.prototype.getAnimationName = function(animationId) {
	return this.m.animations[animationId].name;
}

AnimatedModelRenderer.prototype.getDefaultFrame = function(node, type, ret) {
	switch (type) {
	case 1:
		{
			ret[0] = node.posx;
			ret[1] = node.posy;
			ret[2] = node.posz;
		}
		break;
	case 2:
		{
			ret[0] = node.rotatex;
			ret[1] = node.rotatey;
			ret[2] = node.rotatez;
		}
		break;
	case 3:
		{
			ret[0] = node.sizex;
			ret[1] = node.sizey;
			ret[2] = node.sizez;
		}
		break;
	case 4:
		{
			ret[0] = node.pivotx;
			ret[1] = node.pivoty;
			ret[2] = node.pivotz;
		}
		break;
	case 5:
		{
			ret[0] = node.scalex;
			ret[1] = node.scaley;
			ret[2] = node.scalez;
		}
		break;
	}
}

AnimatedModelRenderer.prototype.getFrameCurrent = function(frames, framesCount) {
	var animName = this.m.animations[this.anim].name;
	var current = -1;
	for (var i = 0; i < framesCount; i++) {
		var k = frames[i];
		if (k.frame <= this.frame) {
			if (current == -1) {
				current = i;
			}
			else {
				if (k.frame > frames[current].frame) {
					current = i;
				}
			}
		}
	}
	if (current == -1) {
		for (var i = 0; i < framesCount; i++) {
			var k = frames[i];
			if (current == -1 || k.frame > frames[current].frame) {
				current = i;
			}
		}
	}
	return current;
}

AnimatedModelRenderer.prototype.getFrames = function(nodeName, type, frames, count) {
	count.value = 0;
	var animName = this.m.animations[this.anim].name;
	for (var i = 0; i < this.m.keyframesCount; i++) {
		var k = this.m.keyframes[i];
		if (k == null) {
			continue;
		}
		if (k.nodeName != nodeName) {
			continue;
		}
		if (k.animationName != animName) {
			continue;
		}
		if (k.keyframeType != type) {
			continue;
		}
		frames[count.value++] = k;
	}
}

AnimatedModelRenderer.prototype.isZero = function(vec) {
	return vec[0] == 0 && vec[1] == 0 && vec[2] == 0;
}

AnimatedModelRenderer.prototype.lerp = function(v0, v1, t) {
	return v0 + (v1 - v0) * t;
}

AnimatedModelRenderer.prototype.render = function(dt, headDeg, light) {
	if (this.m == null) {
		return;
	}
	if (this.m.animations == null) {
		return;
	}
	if (this.m.animations[this.anim] == null) {
		return;
	}
	var length = this.m.animations[this.anim].length;
	this.frame += dt * 60;
	this.frame = this.frame % length;
	this.drawNode("root", headDeg, light);
}

AnimatedModelRenderer.prototype.setAnimation = function(animationName) {
	this.setAnimationId(this.getAnimationId(animationName));
}

AnimatedModelRenderer.prototype.setAnimationId = function(animationId) {
	if (animationId >= this.m.animationsCount || animationId < 0) {
		this.anim = 0;
	}
	else {
		this.anim = animationId;
	}
}

AnimatedModelRenderer.prototype.start = function(game_, model_) {
	this.game = game_;
	this.m = model_;
}

function AnimatedModelSerializer()
{
}

AnimatedModelSerializer.deserialize = function(p, data) {
	var model = new AnimatedModel();
	model.nodes = new Array(256);
	model.keyframes = new Array(1024);
	model.animations = new Array(128);
	var b = new AnimatedModelBinding();
	b.p = p;
	b.m = model;
	var s = new TableSerializer();
	s.deserialize(p, data, b);
	return model;
}

AnimatedModelSerializer.serialize = function(p, m) {
	return null;
}

function Animation()
{
	this.length = 0;
	this.name = null;
}

function AnimationGlobal()
{
	this.texh = 0;
	this.texw = 0;
}

function AnimationHint()
{
	this.drawFixX = null;
	this.drawFixY = null;
	this.drawFixZ = null;
	this.inVehicle = false;
	this.leanleft = false;
	this.leanright = false;
}

function AnimationState()
{
	this.bodyrotation = null;
	this.fullbodyrotate = false;
	this.headbodydelta = null;
	this.interp = null;
	this.lastheading = null;
	this.light = null;
	this.speed = null;
	this.bodyrotation = -1;
	this.light = 1;
}

AnimationState.prototype.getInterp = function() {
	return this.interp;
}

function Asset()
{
	this.data = null;
	this.dataLength = 0;
	this.md5 = null;
	this.name = null;
}

function AssetList()
{
	this.count = 0;
	this.items = null;
}

AssetList.prototype.getCount = function() {
	return this.count;
}

AssetList.prototype.getItems = function() {
	return this.items;
}

AssetList.prototype.setCount = function(value) {
	this.count = value;
}

AssetList.prototype.setItems = function(value) {
	this.items = value;
}

function AudioCi()
{
}

function AudioControl()
{
	this.sounds = null;
	this.soundsCount = 0;
	this.soundsCount = 0;
	this.sounds = new Array(64);
	for (var i = 0; i < 64; i++) {
		this.sounds[i] = null;
	}
}

AudioControl.prototype.add = function(s) {
	for (var i = 0; i < this.soundsCount; i++) {
		if (this.sounds[i] == null) {
			this.sounds[i] = s;
			return;
		}
	}
	if (this.soundsCount < 64) {
		this.sounds[this.soundsCount++] = s;
	}
}

AudioControl.prototype.clear = function() {
	for (var i = 0; i < this.soundsCount; i++) {
		this.sounds[i] = null;
	}
	this.soundsCount = 0;
}

AudioControl.prototype.stopAll = function() {
	for (var i = 0; i < this.soundsCount; i++) {
		if (this.sounds[i] == null) {
			continue;
		}
		this.sounds[i].stop = true;
	}
}

function AudioData()
{
}

function AudioSampleCi()
{
}

function AviWriterCi()
{
}

function BackgroundAction()
{
	this.active = false;
	this.dt = null;
	this.finished = false;
	this.game = null;
	this.i = 0;
	this.game = null;
	this.i = -1;
	this.dt = 1;
	this.active = false;
	this.finished = false;
}
BackgroundAction.prototype = new Action_();

BackgroundAction.prototype.run = function() {
	this.game.clientmods[this.i].onReadOnlyBackgroundThread(this.game, this.dt);
	this.finished = true;
}

function BitTools()
{
}

BitTools.isPowerOfTwo = function(x) {
	return x == 1 || x == 2 || x == 4 || x == 8 || x == 16 || x == 32 || x == 64 || x == 128 || x == 256 || x == 512 || x == 1024 || x == 2048 || x == 4096 || x == 8192 || x == 16384 || x == 32768 || x == 65536 || x == 131072 || x == 262144 || x == 524288 || x == 1048576 || x == 2097152 || x == 4194304 || x == 8388608 || x == 16777216 || x == 33554432 || x == 67108864 || x == 134217728 || x == 268435456 || x == 536870912 || x == 1073741824;
}

BitTools.nextPowerOfTwo = function(x) {
	x--;
	x |= x >> 1;
	x |= x >> 2;
	x |= x >> 4;
	x |= x >> 8;
	x |= x >> 16;
	x++;
	return x;
}

function BitmapCi()
{
}

BitmapCi.prototype.dispose = function() {
}

function BitmapData_()
{
	this.argb = null;
	this.height = 0;
	this.width = 0;
}

BitmapData_.create = function(width, height) {
	var b = new BitmapData_();
	b.width = width;
	b.height = height;
	b.argb = new Int32Array(new ArrayBuffer(width * height << 2));
	return b;
}

BitmapData_.createFromBitmap = function(p, atlas2d_) {
	var b = new BitmapData_();
	b.width = p.floatToInt(p.bitmapGetWidth(atlas2d_));
	b.height = p.floatToInt(p.bitmapGetHeight(atlas2d_));
	b.argb = new Int32Array(new ArrayBuffer(b.width * b.height << 2));
	p.bitmapGetPixelsArgb(atlas2d_, b.argb);
	return b;
}

BitmapData_.prototype.getPixel = function(x, y) {
	return this.argb[x + y * this.width];
}

BitmapData_.prototype.setPixel = function(x, y, color) {
	this.argb[x + y * this.width] = color;
}

BitmapData_.prototype.toBitmap = function(p) {
	var bmp = p.bitmapCreate(this.width, this.height);
	p.bitmapSetPixelsArgb(bmp, this.argb);
	return bmp;
}

function BlockOctreeSearcher()
{
	this.startBox = null;
	this.currentHit = null;
	this.currentLine = null;
	this.intersection = null;
	this.l = null;
	this.lCount = 0;
	this.listpool = null;
	this.listpool_i = 0;
	this.platform = null;
	this.pool = null;
	this.pool_i = 0;
	this.intersection = new Intersection();
	this.pool = new Array(10000);
	for (var i = 0; i < 10000; i++) {
		this.pool[i] = new Box3D();
	}
	this.listpool = new Array(50);
	for (var i = 0; i < 50; i++) {
		this.listpool[i] = new ListBox3d();
		this.listpool[i].arr = new Array(1000);
	}
	this.l = new Array(1024);
	this.lCount = 0;
	this.currentHit = new Float32Array(new ArrayBuffer(3 << 2));
}

BlockOctreeSearcher.prototype.boxHit = function(box) {
	this.currentHit[0] = 0;
	this.currentHit[1] = 0;
	this.currentHit[2] = 0;
	return Intersection.checkLineBox(box, this.currentLine, this.currentHit);
}

BlockOctreeSearcher.prototype.children = function(box) {
	var l = this.newListBox3d();
	l.count = 8;
	var c = l.arr;
	for (var i = 0; i < 8; i++) {
		c[i] = this.newBox3d();
	}
	var x = box.minEdge[0];
	var y = box.minEdge[1];
	var z = box.minEdge[2];
	var size = box.lengthX() / (2);
	c[0].set(x, y, z, size);
	c[1].set(x + size, y, z, size);
	c[2].set(x, y, z + size, size);
	c[3].set(x + size, y, z + size, size);
	c[4].set(x, y + size, z, size);
	c[5].set(x + size, y + size, z, size);
	c[6].set(x, y + size, z + size, size);
	c[7].set(x + size, y + size, z + size, size);
	return l;
}

BlockOctreeSearcher.prototype.lineIntersection = function(isEmpty, getBlockHeight, line, retCount) {
	this.lCount = 0;
	this.currentLine = line;
	this.currentHit[0] = 0;
	this.currentHit[1] = 0;
	this.currentHit[2] = 0;
	var l1 = this.search(PredicateBox3DHit.create(this));
	for (var i = 0; i < l1.count; i++) {
		var node = l1.arr[i];
		var hit = this.currentHit;
		var x = node.minEdge[0];
		var y = node.minEdge[2];
		var z = node.minEdge[1];
		if (!isEmpty.isBlockEmpty(this.platform.floatToInt(x), this.platform.floatToInt(y), this.platform.floatToInt(z))) {
			var node2 = new Box3D();
			node2.minEdge = Vec3.cloneIt(node.minEdge);
			node2.maxEdge = Vec3.cloneIt(node.maxEdge);
			node2.maxEdge[1] = node2.minEdge[1] + getBlockHeight.getBlockHeight(this.platform.floatToInt(x), this.platform.floatToInt(y), this.platform.floatToInt(z));
			var b = new BlockPosSide();
			var hit2 = new Float32Array(new ArrayBuffer(3 << 2));
			var dir = new Float32Array(new ArrayBuffer(3 << 2));
			dir[0] = line.end[0] - line.start[0];
			dir[1] = line.end[1] - line.start[1];
			dir[2] = line.end[2] - line.start[2];
			var ishit = Intersection.hitBoundingBox(node2.minEdge, node2.maxEdge, line.start, dir, hit2);
			if (ishit) {
				b.blockPos = Vec3.fromValues(this.platform.floatToInt(x), this.platform.floatToInt(z), this.platform.floatToInt(y));
				b.collisionPos = hit2;
				this.l[this.lCount++] = b;
			}
		}
	}
	var ll = new Array(this.lCount);
	for (var i = 0; i < this.lCount; i++) {
		ll[i] = this.l[i];
	}
	retCount.value = this.lCount;
	return ll;
}

BlockOctreeSearcher.prototype.search = function(query) {
	this.pool_i = 0;
	this.listpool_i = 0;
	if (this.startBox.lengthX() == 0 && this.startBox.lengthY() == 0 && this.startBox.lengthZ() == 0) {
		return new ListBox3d();
	}
	return this.searchPrivate(query, this.startBox);
}

BlockOctreeSearcher.prototype.searchPrivate = function(query, box) {
	if (box.lengthX() == 1) {
		var l1 = this.newListBox3d();
		l1.count = 1;
		l1.arr[0] = box;
		return l1;
	}
	var l = this.newListBox3d();
	l.count = 0;
	var children = this.children(box);
	for (var k = 0; k < children.count; k++) {
		var child = children.arr[k];
		if (query.hit(child)) {
			var l2 = this.searchPrivate(query, child);
			for (var i = 0; i < l2.count; i++) {
				var n = l2.arr[i];
				l.arr[l.count++] = n;
			}
			this.recycleListBox3d(l2);
		}
	}
	this.recycleListBox3d(children);
	return l;
}

BlockOctreeSearcher.prototype.newBox3d = function() {
	return this.pool[this.pool_i++];
}

BlockOctreeSearcher.prototype.newListBox3d = function() {
	var l = this.listpool[this.listpool_i++];
	l.count = 0;
	return l;
}

BlockOctreeSearcher.prototype.recycleBox3d = function(l) {
	this.pool_i--;
	this.pool[this.pool_i] = l;
}

BlockOctreeSearcher.prototype.recycleListBox3d = function(l) {
	this.listpool_i--;
	this.listpool[this.listpool_i] = l;
}

function BlockPosSide()
{
	this.blockPos = null;
	this.collisionPos = null;
}

BlockPosSide.create = function(x, y, z) {
	var p = new BlockPosSide();
	p.blockPos = Vec3.fromValues(x, y, z);
	return p;
}

BlockPosSide.prototype.current = function() {
	return this.blockPos;
}

BlockPosSide.prototype.translated = function() {
	var translated = new Float32Array(new ArrayBuffer(3 << 2));
	translated[0] = this.blockPos[0];
	translated[1] = this.blockPos[1];
	translated[2] = this.blockPos[2];
	if (this.collisionPos == null) {
		return translated;
	}
	if (this.collisionPos[0] == this.blockPos[0]) {
		translated[0] = translated[0] - 1;
	}
	if (this.collisionPos[1] == this.blockPos[1]) {
		translated[1] = translated[1] - 1;
	}
	if (this.collisionPos[2] == this.blockPos[2]) {
		translated[2] = translated[2] - 1;
	}
	if (this.collisionPos[0] == this.blockPos[0] + 1) {
		translated[0] = translated[0] + 1;
	}
	if (this.collisionPos[1] == this.blockPos[1] + 1) {
		translated[1] = translated[1] + 1;
	}
	if (this.collisionPos[2] == this.blockPos[2] + 1) {
		translated[2] = translated[2] + 1;
	}
	return translated;
}

function BlockRendererTorch()
{
	this.sideTexture = 0;
	this.topTexture = 0;
}

BlockRendererTorch.prototype.addTorch = function(d_Data, d_TerainRenderer, m, x, y, z, type) {
	var one = 1;
	var curcolor = Game.colorFromArgb(255, 255, 255, 255);
	var torchsizexy = (one * 16) / (100);
	var topx = one / (2) - torchsizexy / (2);
	var topy = one / (2) - torchsizexy / (2);
	var bottomx = one / (2) - torchsizexy / (2);
	var bottomy = one / (2) - torchsizexy / (2);
	topx += x;
	topy += y;
	bottomx += x;
	bottomy += y;
	if (type == TorchType.FRONT) {
		bottomx = x - torchsizexy;
	}
	if (type == TorchType.BACK) {
		bottomx = x + 1;
	}
	if (type == TorchType.LEFT) {
		bottomy = y - torchsizexy;
	}
	if (type == TorchType.RIGHT) {
		bottomy = y + 1;
	}
	var top00 = Vector3Ref.create(topx, z + (one * 9) / (10), topy);
	var top01 = Vector3Ref.create(topx, z + (one * 9) / (10), topy + torchsizexy);
	var top10 = Vector3Ref.create(topx + torchsizexy, z + (one * 9) / (10), topy);
	var top11 = Vector3Ref.create(topx + torchsizexy, z + (one * 9) / (10), topy + torchsizexy);
	if (type == TorchType.LEFT) {
		top01.y += -(one * 1) / (10);
		top11.y += -(one * 1) / (10);
	}
	if (type == TorchType.RIGHT) {
		top10.y += -(one * 1) / (10);
		top00.y += -(one * 1) / (10);
	}
	if (type == TorchType.FRONT) {
		top10.y += -(one * 1) / (10);
		top11.y += -(one * 1) / (10);
	}
	if (type == TorchType.BACK) {
		top01.y += -(one * 1) / (10);
		top00.y += -(one * 1) / (10);
	}
	var bottom00 = Vector3Ref.create(bottomx, z + 0, bottomy);
	var bottom01 = Vector3Ref.create(bottomx, z + 0, bottomy + torchsizexy);
	var bottom10 = Vector3Ref.create(bottomx + torchsizexy, z + 0, bottomy);
	var bottom11 = Vector3Ref.create(bottomx + torchsizexy, z + 0, bottomy + torchsizexy);
	{
		var sidetexture = this.topTexture;
		var texrec = TextureAtlas.textureCoords2d(sidetexture, d_TerainRenderer.texturesPacked());
		var lastelement = m.getVerticesCount();
		this.addVertex(m, top00.x, top00.y, top00.z, texrec.left(), texrec.top(), curcolor);
		this.addVertex(m, top01.x, top01.y, top01.z, texrec.left(), texrec.bottom(), curcolor);
		this.addVertex(m, top10.x, top10.y, top10.z, texrec.right(), texrec.top(), curcolor);
		this.addVertex(m, top11.x, top11.y, top11.z, texrec.right(), texrec.bottom(), curcolor);
		m.indices[m.indicesCount++] = lastelement + 0;
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 2;
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 3;
		m.indices[m.indicesCount++] = lastelement + 2;
	}
	{
		var sidetexture = this.sideTexture;
		var texrec = TextureAtlas.textureCoords2d(sidetexture, d_TerainRenderer.texturesPacked());
		var lastelement = m.getVerticesCount();
		this.addVertex(m, bottom00.x, bottom00.y, bottom00.z, texrec.left(), texrec.top(), curcolor);
		this.addVertex(m, bottom01.x, bottom01.y, bottom01.z, texrec.left(), texrec.bottom(), curcolor);
		this.addVertex(m, bottom10.x, bottom10.y, bottom10.z, texrec.right(), texrec.top(), curcolor);
		this.addVertex(m, bottom11.x, bottom11.y, bottom11.z, texrec.right(), texrec.bottom(), curcolor);
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 0;
		m.indices[m.indicesCount++] = lastelement + 2;
		m.indices[m.indicesCount++] = lastelement + 3;
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 2;
	}
	{
		var sidetexture = this.sideTexture;
		var texrec = TextureAtlas.textureCoords2d(sidetexture, d_TerainRenderer.texturesPacked());
		var lastelement = m.getVerticesCount();
		this.addVertex(m, bottom00.x, bottom00.y, bottom00.z, texrec.left(), texrec.bottom(), curcolor);
		this.addVertex(m, bottom01.x, bottom01.y, bottom01.z, texrec.right(), texrec.bottom(), curcolor);
		this.addVertex(m, top00.x, top00.y, top00.z, texrec.left(), texrec.top(), curcolor);
		this.addVertex(m, top01.x, top01.y, top01.z, texrec.right(), texrec.top(), curcolor);
		m.indices[m.indicesCount++] = lastelement + 0;
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 2;
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 3;
		m.indices[m.indicesCount++] = lastelement + 2;
	}
	{
		var sidetexture = this.sideTexture;
		var texrec = TextureAtlas.textureCoords2d(sidetexture, d_TerainRenderer.texturesPacked());
		var lastelement = m.getVerticesCount();
		this.addVertex(m, bottom10.x, bottom10.y, bottom10.z, texrec.right(), texrec.bottom(), curcolor);
		this.addVertex(m, bottom11.x, bottom11.y, bottom11.z, texrec.left(), texrec.bottom(), curcolor);
		this.addVertex(m, top10.x, top10.y, top10.z, texrec.right(), texrec.top(), curcolor);
		this.addVertex(m, top11.x, top11.y, top11.z, texrec.left(), texrec.top(), curcolor);
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 0;
		m.indices[m.indicesCount++] = lastelement + 2;
		m.indices[m.indicesCount++] = lastelement + 3;
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 2;
	}
	{
		var sidetexture = this.sideTexture;
		var texrec = TextureAtlas.textureCoords2d(sidetexture, d_TerainRenderer.texturesPacked());
		var lastelement = m.getVerticesCount();
		this.addVertex(m, bottom00.x, bottom00.y, bottom00.z, texrec.right(), texrec.bottom(), curcolor);
		this.addVertex(m, top00.x, top00.y, top00.z, texrec.right(), texrec.top(), curcolor);
		this.addVertex(m, bottom10.x, bottom10.y, bottom10.z, texrec.left(), texrec.bottom(), curcolor);
		this.addVertex(m, top10.x, top10.y, top10.z, texrec.left(), texrec.top(), curcolor);
		m.indices[m.indicesCount++] = lastelement + 0;
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 2;
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 3;
		m.indices[m.indicesCount++] = lastelement + 2;
	}
	{
		var sidetexture = this.sideTexture;
		var texrec = TextureAtlas.textureCoords2d(sidetexture, d_TerainRenderer.texturesPacked());
		var lastelement = m.getVerticesCount();
		this.addVertex(m, bottom01.x, bottom01.y, bottom01.z, texrec.left(), texrec.bottom(), curcolor);
		this.addVertex(m, top01.x, top01.y, top01.z, texrec.left(), texrec.top(), curcolor);
		this.addVertex(m, bottom11.x, bottom11.y, bottom11.z, texrec.right(), texrec.bottom(), curcolor);
		this.addVertex(m, top11.x, top11.y, top11.z, texrec.right(), texrec.top(), curcolor);
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 0;
		m.indices[m.indicesCount++] = lastelement + 2;
		m.indices[m.indicesCount++] = lastelement + 3;
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 2;
	}
}

BlockRendererTorch.prototype.addVertex = function(model, x, y, z, u, v, color) {
	model.xyz[model.getXyzCount() + 0] = x;
	model.xyz[model.getXyzCount() + 1] = y;
	model.xyz[model.getXyzCount() + 2] = z;
	model.uv[model.getUvCount() + 0] = u;
	model.uv[model.getUvCount() + 1] = v;
	model.rgba[model.getRgbaCount() + 0] = Game.intToByte(Game.colorR(color));
	model.rgba[model.getRgbaCount() + 1] = Game.intToByte(Game.colorG(color));
	model.rgba[model.getRgbaCount() + 2] = Game.intToByte(Game.colorB(color));
	model.rgba[model.getRgbaCount() + 3] = Game.intToByte(Game.colorA(color));
	model.verticesCount++;
}

var BlockSetMode = {
	DESTROY : 0,
	CREATE : 1,
	USE : 2,
	USE_WITH_TOOL : 3
}

function BlockTypeSimple()
{
	this.block = null;
	this.block = new Packet_BlockType();
}

BlockTypeSimple.prototype.setAllTextures = function(texture) {
	this.block.textureIdTop = texture;
	this.block.textureIdBottom = texture;
	this.block.textureIdFront = texture;
	this.block.textureIdBack = texture;
	this.block.textureIdLeft = texture;
	this.block.textureIdRight = texture;
	this.block.textureIdForInventory = texture;
}

BlockTypeSimple.prototype.setDrawType = function(p) {
	this.block.drawType = p;
}

BlockTypeSimple.prototype.setName = function(name) {
	this.block.name = name;
}

BlockTypeSimple.prototype.setTextureBack = function(p) {
	this.block.textureIdBack = p;
}

BlockTypeSimple.prototype.setTextureBottom = function(p) {
	this.block.textureIdBottom = p;
}

BlockTypeSimple.prototype.setTextureFront = function(p) {
	this.block.textureIdFront = p;
}

BlockTypeSimple.prototype.setTextureLeft = function(p) {
	this.block.textureIdLeft = p;
}

BlockTypeSimple.prototype.setTextureRight = function(p) {
	this.block.textureIdRight = p;
}

BlockTypeSimple.prototype.setTextureTop = function(p) {
	this.block.textureIdTop = p;
}

BlockTypeSimple.prototype.setWalkableType = function(p) {
	this.block.walkableType = p;
}

function BoolRef()
{
	this.value = false;
}

BoolRef.prototype.getValue = function() {
	return this.value;
}

BoolRef.prototype.setValue = function(value_) {
	this.value = value_;
}

function Box3D()
{
	this.maxEdge = null;
	this.minEdge = null;
}

Box3D.prototype.addPoint = function(x, y, z) {
	if (this.minEdge == null || this.maxEdge == null || this.minEdge[0] == 0 && this.minEdge[1] == 0 && this.minEdge[2] == 0 && this.maxEdge[0] == 0 && this.maxEdge[1] == 0 && this.maxEdge[2] == 0) {
		this.minEdge = Vec3.fromValues(x, y, z);
		this.maxEdge = Vec3.fromValues(x, y, z);
	}
	this.minEdge[0] = MathCi.minFloat(this.minEdge[0], x);
	this.minEdge[1] = MathCi.minFloat(this.minEdge[1], y);
	this.minEdge[2] = MathCi.minFloat(this.minEdge[2], z);
	this.maxEdge[0] = MathCi.maxFloat(this.maxEdge[0], x);
	this.maxEdge[1] = MathCi.maxFloat(this.maxEdge[1], y);
	this.maxEdge[2] = MathCi.maxFloat(this.maxEdge[2], z);
}

Box3D.prototype.center = function() {
	return null;
}

Box3D.create = function(x, y, z, size) {
	var b = new Box3D();
	b.set(x, y, z, size);
	return b;
}

Box3D.prototype.lengthX = function() {
	return this.maxEdge[0] - this.minEdge[0];
}

Box3D.prototype.lengthY = function() {
	return this.maxEdge[1] - this.minEdge[1];
}

Box3D.prototype.lengthZ = function() {
	return this.maxEdge[2] - this.minEdge[2];
}

Box3D.prototype.set = function(x, y, z, size) {
	if (this.minEdge == null) {
		this.minEdge = new Float32Array(new ArrayBuffer(3 << 2));
		this.maxEdge = new Float32Array(new ArrayBuffer(3 << 2));
	}
	this.minEdge[0] = x;
	this.minEdge[1] = y;
	this.minEdge[2] = z;
	this.maxEdge[0] = x + size;
	this.maxEdge[1] = y + size;
	this.maxEdge[2] = z + size;
}

function Bullet_()
{
	this.fromX = null;
	this.fromY = null;
	this.fromZ = null;
	this.progress = null;
	this.speed = null;
	this.toX = null;
	this.toY = null;
	this.toZ = null;
}

function Button()
{
	this.text = null;
	this.font = null;
	this.fontcolor = 0;
	this.fontcolorselected = 0;
	this.height = 0;
	this.selected = false;
	this.width = 0;
	this.x = 0;
	this.y = 0;
	this.fontcolor = Game.colorFromArgb(255, 255, 255, 255);
	this.fontcolorselected = Game.colorFromArgb(255, 255, 0, 0);
	this.font = new FontCi();
}

var ButtonStyle = {
	BUTTON : 0,
	TEXT : 1,
	SERVER_ENTRY : 2
}

function ByteArray()
{
	this.data = null;
	this.length = 0;
}

function CachedTextTexture()
{
	this.text = null;
	this.texture = null;
}

function CachedTexture()
{
	this.lastuseMilliseconds = 0;
	this.sizeX = null;
	this.sizeY = null;
	this.textureId = 0;
}

function CameraMove()
{
	this.angleDown = false;
	this.angleUp = false;
	this.distance = null;
	this.distanceDown = false;
	this.distanceUp = false;
	this.moveX = 0;
	this.moveY = 0;
	this.turnLeft = false;
	this.turnRight = false;
}

function CameraPoint()
{
	this.orientationGlX = null;
	this.orientationGlY = null;
	this.orientationGlZ = null;
	this.positionGlX = null;
	this.positionGlY = null;
	this.positionGlZ = null;
}

var CameraType = {
	FPP : 0,
	TPP : 1,
	OVERHEAD : 2
}

function Chatline()
{
	this.clickable = false;
	this.linkTarget = null;
	this.text = null;
	this.timeMilliseconds = 0;
}

Chatline.create = function(text_, timeMilliseconds_) {
	var c = new Chatline();
	c.text = text_;
	c.timeMilliseconds = timeMilliseconds_;
	c.clickable = false;
	return c;
}

Chatline.createClickable = function(text_, timeMilliseconds_, linkTarget_) {
	var c = new Chatline();
	c.text = text_;
	c.timeMilliseconds = timeMilliseconds_;
	c.clickable = true;
	c.linkTarget = linkTarget_;
	return c;
}

function Chunk()
{
	this.baseLight = null;
	this.baseLightDirty = false;
	this.data = null;
	this.dataInt = null;
	this.rendered = null;
	this.baseLightDirty = true;
}

Chunk.prototype.chunkHasData = function() {
	return this.data != null || this.dataInt != null;
}

Chunk.prototype.getBlockInChunk = function(pos) {
	if (this.dataInt != null) {
		return this.dataInt[pos];
	}
	else {
		return this.data[pos];
	}
}

Chunk.prototype.setBlockInChunk = function(pos, block) {
	if (this.dataInt == null) {
		if (block < 255) {
			this.data[pos] = Game.intToByte(block);
		}
		else {
			var n = 4096;
			this.dataInt = new Int32Array(new ArrayBuffer(n << 2));
			for (var i = 0; i < n; i++) {
				this.dataInt[i] = this.data[i];
			}
			this.data = null;
			this.dataInt[pos] = block;
		}
	}
	else {
		this.dataInt[pos] = block;
	}
}

function ChunkEntityClient()
{
}

function ChunkSimple()
{
	this.data = null;
}

function CitoStream()
{
}

function CitoMemoryStream()
{
	this.buffer_ = null;
	this.bufferlength = 0;
	this.count_ = 0;
	this.position_ = 0;
	this.buffer_ = new Uint8Array(new ArrayBuffer(1));
	this.count_ = 0;
	this.bufferlength = 1;
	this.position_ = 0;
}
CitoMemoryStream.prototype = new CitoStream();

CitoMemoryStream.prototype.canSeek = function() {
	return false;
}

CitoMemoryStream.create = function(buffer, length) {
	var m = new CitoMemoryStream();
	m.buffer_ = buffer;
	m.count_ = length;
	m.bufferlength = length;
	m.position_ = 0;
	return m;
}

CitoMemoryStream.prototype.getBuffer = function() {
	return this.buffer_;
}

CitoMemoryStream.prototype.length = function() {
	return this.count_;
}

CitoMemoryStream.prototype.position = function() {
	return this.position_;
}

CitoMemoryStream.prototype.read = function(buffer, offset, count) {
	for (var i = 0; i < count; i++) {
		if (this.position_ + i >= this.count_) {
			this.position_ += i;
			return i;
		}
		buffer[offset + i] = this.buffer_[this.position_ + i];
	}
	this.position_ += count;
	return count;
}

CitoMemoryStream.prototype.readByte = function() {
	if (this.position_ >= this.count_) {
		return -1;
	}
	return this.buffer_[this.position_++];
}

CitoMemoryStream.prototype.seek = function(length, seekOrigin) {
	switch (seekOrigin) {
	case CitoSeekOrigin.CURRENT:
		this.position_ += length;
		break;
	}
}

CitoMemoryStream.prototype.seek_ = function(p, seekOrigin) {
}

CitoMemoryStream.prototype.toArray = function() {
	return this.buffer_;
}

CitoMemoryStream.prototype.write = function(buffer, offset, count) {
	for (var i = 0; i < count; i++) {
		this.writeByte(buffer[offset + i]);
	}
}

CitoMemoryStream.prototype.writeByte = function(p) {
	if (this.position_ >= this.bufferlength) {
		var buffer2 = new Uint8Array(new ArrayBuffer(this.bufferlength * 2));
		for (var i = 0; i < this.bufferlength; i++) {
			buffer2[i] = this.buffer_[i];
		}
		this.buffer_ = buffer2;
		this.bufferlength = this.bufferlength * 2;
	}
	this.buffer_[this.position_] = p;
	if (this.position_ == this.count_) {
		this.count_++;
	}
	this.position_++;
}

var CitoSeekOrigin = {
	CURRENT : 0
}

function ClientCommandArgs()
{
	this.arguments = null;
	this.command = null;
}

function IInventoryController()
{
}

function ClientInventoryController()
{
	this.g = null;
}
ClientInventoryController.prototype = new IInventoryController();

ClientInventoryController.create = function(game) {
	var c = new ClientInventoryController();
	c.g = game;
	return c;
}

ClientInventoryController.prototype.inventoryClick = function(pos) {
	this.g.inventoryClick(pos);
}

ClientInventoryController.prototype.moveToInventory = function(from) {
	this.g.moveToInventory(from);
}

ClientInventoryController.prototype.wearItem = function(from, to) {
	this.g.wearItem(from, to);
}

function ClientMod()
{
}

ClientMod.prototype.dispose = function(game) {
}

ClientMod.prototype.onBeforeNewFrameDraw3d = function(game, deltaTime) {
}

ClientMod.prototype.onClientCommand = function(game, args) {
	return false;
}

ClientMod.prototype.onHitEntity = function(game, e) {
}

ClientMod.prototype.onKeyDown = function(game, args) {
}

ClientMod.prototype.onKeyPress = function(game, args) {
}

ClientMod.prototype.onKeyUp = function(game, args) {
}

ClientMod.prototype.onMouseDown = function(game, args) {
}

ClientMod.prototype.onMouseMove = function(game, args) {
}

ClientMod.prototype.onMouseUp = function(game, args) {
}

ClientMod.prototype.onMouseWheelChanged = function(game, args) {
}

ClientMod.prototype.onNewFrame = function(game, args) {
}

ClientMod.prototype.onNewFrameDraw2d = function(game, deltaTime) {
}

ClientMod.prototype.onNewFrameDraw3d = function(game, deltaTime) {
}

ClientMod.prototype.onNewFrameFixed = function(game, args) {
}

ClientMod.prototype.onNewFrameReadOnlyMainThread = function(game, deltaTime) {
}

ClientMod.prototype.onReadOnlyBackgroundThread = function(game, dt) {
}

ClientMod.prototype.onReadOnlyMainThread = function(game, dt) {
}

ClientMod.prototype.onReadWriteMainThread = function(game, dt) {
}

ClientMod.prototype.onTouchEnd = function(game, e) {
}

ClientMod.prototype.onTouchMove = function(game, e) {
}

ClientMod.prototype.onTouchStart = function(game, e) {
}

ClientMod.prototype.onUseEntity = function(game, e) {
}

ClientMod.prototype.start = function(modmanager) {
}

function ClientModManager()
{
}

function ClientModManager1()
{
	this.game = null;
}
ClientModManager1.prototype = new ClientModManager();

ClientModManager1.prototype.aviWriterCreate = function() {
	return this.game.platform.aviWriterCreate();
}

ClientModManager1.prototype.displayNotification = function(message) {
	this.game.addChatline(message);
}

ClientModManager1.prototype.draw2dText = function(text, x, y, font) {
	this.game.draw2dText(text, font, x, y, null, false);
}

ClientModManager1.prototype.draw2dTexture = function(textureid, x1, y1, width, height, inAtlasId, color) {
	var a = Game.colorA(color);
	var r = Game.colorR(color);
	var g = Game.colorG(color);
	var b = Game.colorB(color);
	this.game.draw2dTexture(textureid, this.game.platform.floatToInt(x1), this.game.platform.floatToInt(y1), this.game.platform.floatToInt(width), this.game.platform.floatToInt(height), inAtlasId, 0, Game.colorFromArgb(a, r, g, b), false);
}

ClientModManager1.prototype.draw2dTextures = function(todraw, todrawLength, textureId) {
	this.game.draw2dTextures(todraw, todrawLength, textureId);
}

ClientModManager1.prototype.enableCameraControl = function(enable) {
	this.game.enableCameraControl = enable;
}

ClientModManager1.prototype.getFreemove = function() {
	return this.game.controls.getFreemove();
}

ClientModManager1.prototype.getLocalOrientationX = function() {
	return this.game.player.position.rotx;
}

ClientModManager1.prototype.getLocalOrientationY = function() {
	return this.game.player.position.roty;
}

ClientModManager1.prototype.getLocalOrientationZ = function() {
	return this.game.player.position.rotz;
}

ClientModManager1.prototype.getLocalPositionX = function() {
	return this.game.player.position.x;
}

ClientModManager1.prototype.getLocalPositionY = function() {
	return this.game.player.position.y;
}

ClientModManager1.prototype.getLocalPositionZ = function() {
	return this.game.player.position.z;
}

ClientModManager1.prototype.getPerformanceInfo = function() {
	return this.game.performanceinfo;
}

ClientModManager1.prototype.getPlatform = function() {
	return this.game.platform;
}

ClientModManager1.prototype.getWindowHeight = function() {
	return this.game.platform.getCanvasHeight();
}

ClientModManager1.prototype.getWindowWidth = function() {
	return this.game.platform.getCanvasWidth();
}

ClientModManager1.prototype.grabScreenshot = function() {
	return this.game.platform.grabScreenshot();
}

ClientModManager1.prototype.isFreemoveAllowed = function() {
	return this.game.allowFreemove;
}

ClientModManager1.prototype.makeScreenshot = function() {
	this.game.platform.saveScreenshot();
}

ClientModManager1.prototype.orthoMode = function() {
	this.game.orthoMode(this.getWindowWidth(), this.getWindowHeight());
}

ClientModManager1.prototype.perspectiveMode = function() {
	this.game.perspectiveMode();
}

ClientModManager1.prototype.sendChatMessage = function(message) {
	this.game.sendChat(message);
}

ClientModManager1.prototype.setFreemove = function(level) {
	this.game.controls.setFreemove(level);
}

ClientModManager1.prototype.setLocalOrientation = function(glx, gly, glz) {
	this.game.player.position.rotx = glx;
	this.game.player.position.roty = gly;
	this.game.player.position.rotz = glz;
}

ClientModManager1.prototype.setLocalPosition = function(glx, gly, glz) {
	this.game.player.position.x = glx;
	this.game.player.position.y = gly;
	this.game.player.position.z = glz;
}

ClientModManager1.prototype.showGui = function(level) {
	if (level == 0) {
		this.game.eNABLE_DRAW2D = false;
	}
	else {
		this.game.eNABLE_DRAW2D = true;
	}
}

ClientModManager1.prototype.whiteTexture = function() {
	return this.game.whiteTexture();
}

function ClientPacketHandler()
{
	this.one = null;
	this.one = 1;
}

function ClientPacketHandlerDialog()
{
}
ClientPacketHandlerDialog.prototype = new ClientPacketHandler();

ClientPacketHandlerDialog.prototype.convertDialog = function(game, p) {
	var s = new DialogScreen();
	s.widgets = new Array(p.widgetsCount);
	s.widgetCount = p.widgetsCount;
	for (var i = 0; i < p.widgetsCount; i++) {
		var a = p.widgets[i];
		var b = new MenuWidget();
		if (a.type == 1) {
			b.type = WidgetType.LABEL;
		}
		if (a.type == 0) {
			b.type = WidgetType.BUTTON;
		}
		if (a.type == 2) {
			b.type = WidgetType.TEXTBOX;
		}
		b.x = a.x;
		b.y = a.y;
		b.sizex = a.width;
		b.sizey = a.height_;
		b.text = a.text;
		if (b.text != null) {
			b.text = game.platform.stringReplace(b.text, "!SERVER_IP!", game.serverInfo.connectdata.ip);
		}
		if (b.text != null) {
			b.text = game.platform.stringReplace(b.text, "!SERVER_PORT!", game.platform.intToString(game.serverInfo.connectdata.port));
		}
		b.color = a.color;
		if (a.font != null) {
			b.font = new FontCi();
			b.font.family = game.validFont(a.font.familyName);
			b.font.size = game.deserializeFloat(a.font.sizeFloat);
			b.font.style = a.font.fontStyle;
		}
		b.id = a.id;
		b.isbutton = a.clickKey != 0;
		if (a.image == "Solid") {
			b.image = null;
		}
		else if (a.image != null) {
			b.image = StringTools.stringAppend(game.platform, a.image, ".png");
		}
		s.widgets[i] = b;
	}
	for (var i = 0; i < s.widgetCount; i++) {
		if (s.widgets[i] == null) {
			continue;
		}
		if (s.widgets[i].type == WidgetType.TEXTBOX) {
			s.widgets[i].editing = true;
			break;
		}
	}
	return s;
}

ClientPacketHandlerDialog.prototype.handle = function(game, packet) {
	var d = packet.dialog;
	if (d.dialog == null) {
		if (game.getDialogId(d.dialogId) != -1 && game.dialogs[game.getDialogId(d.dialogId)].value.isModal != 0) {
			game.guiStateBackToGame();
		}
		if (game.getDialogId(d.dialogId) != -1) {
			game.dialogs[game.getDialogId(d.dialogId)] = null;
		}
		if (game.dialogsCount_() == 0) {
			game.setFreeMouse(false);
		}
	}
	else {
		var d2 = new VisibleDialog();
		d2.key = d.dialogId;
		d2.value = d.dialog;
		d2.screen = this.convertDialog(game, d2.value);
		d2.screen.game = game;
		if (game.getDialogId(d.dialogId) == -1) {
			for (var i = 0; i < game.dialogsCount; i++) {
				if (game.dialogs[i] == null) {
					game.dialogs[i] = d2;
					break;
				}
			}
		}
		else {
			game.dialogs[game.getDialogId(d.dialogId)] = d2;
		}
		if (d.dialog.isModal != 0) {
			game.guistate = GuiState.MODAL_DIALOG;
			game.setFreeMouse(true);
		}
	}
}

function ClientPacketHandlerEntityDespawn()
{
}
ClientPacketHandlerEntityDespawn.prototype = new ClientPacketHandler();

ClientPacketHandlerEntityDespawn.prototype.handle = function(game, packet) {
	if (game.entities[packet.entityDespawn.id] != null) {
		if (game.entities[packet.entityDespawn.id].drawModel != null && game.entities[packet.entityDespawn.id].drawModel.downloadSkin) {
			var currentTex = game.entities[packet.entityDespawn.id].drawModel.currentTexture;
			if (currentTex > 0 && currentTex != game.getTexture("mineplayer.png")) {
				game.entities[packet.entityDespawn.id].drawModel.currentTexture = -1;
				game.deleteTexture(game.entities[packet.entityDespawn.id].drawName.name);
			}
		}
	}
	game.entities[packet.entityDespawn.id] = null;
}

function ClientPacketHandlerEntityPosition()
{
}
ClientPacketHandlerEntityPosition.prototype = new ClientPacketHandler();

ClientPacketHandlerEntityPosition.prototype.handle = function(game, packet) {
	var entity = game.entities[packet.entityPosition.id];
	var pos = ClientPacketHandlerEntitySpawn.toClientEntityPosition(packet.entityPosition.positionAndOrientation);
	entity.networkPosition = pos;
	entity.networkPosition.positionLoaded = true;
	entity.networkPosition.lastUpdateMilliseconds = game.platform.timeMillisecondsFromStart();
	if (packet.entityPosition.id == game.localPlayerId) {
		game.player.position.x = pos.x;
		game.player.position.y = pos.y;
		game.player.position.z = pos.z;
		game.player.position.rotx = pos.rotx;
		game.player.position.roty = pos.roty;
		game.player.position.rotz = pos.rotz;
		entity.networkPosition = null;
	}
	else if (entity.push != null) {
		entity.push.xFloat = packet.entityPosition.positionAndOrientation.x;
		entity.push.yFloat = packet.entityPosition.positionAndOrientation.z;
		entity.push.zFloat = packet.entityPosition.positionAndOrientation.y;
	}
}

function ClientPacketHandlerEntitySpawn()
{
}
ClientPacketHandlerEntitySpawn.prototype = new ClientPacketHandler();

ClientPacketHandlerEntitySpawn.prototype.handle = function(game, packet) {
	var entity = game.entities[packet.entitySpawn.id];
	if (entity == null) {
		entity = new Entity();
	}
	ClientPacketHandlerEntitySpawn.toClientEntity(game, packet.entitySpawn.entity_, entity, packet.entitySpawn.id != game.localPlayerId);
	game.entities[packet.entitySpawn.id] = entity;
	if (packet.entitySpawn.id == game.localPlayerId) {
		entity.networkPosition = null;
		game.player = entity;
		if (!game.spawned) {
			entity.scripts[entity.scriptsCount++] = new ScriptCharacterPhysics();
			game.mapLoaded();
			game.spawned = true;
		}
	}
}

ClientPacketHandlerEntitySpawn.toClientEntity = function(game, entity, old, updatePosition) {
	if (entity.position != null) {
		if (old.position == null || updatePosition) {
			old.networkPosition = ClientPacketHandlerEntitySpawn.toClientEntityPosition(entity.position);
			old.networkPosition.positionLoaded = true;
			old.networkPosition.lastUpdateMilliseconds = game.platform.timeMillisecondsFromStart();
			old.position = ClientPacketHandlerEntitySpawn.toClientEntityPosition(entity.position);
		}
	}
	if (entity.drawModel != null) {
		old.drawModel = new EntityDrawModel();
		old.drawModel.eyeHeight = game.deserializeFloat(entity.drawModel.eyeHeight);
		old.drawModel.modelHeight = game.deserializeFloat(entity.drawModel.modelHeight);
		old.drawModel.texture_ = entity.drawModel.texture_;
		old.drawModel.model_ = entity.drawModel.model_;
		if (old.drawModel.model_ == null) {
			old.drawModel.model_ = "player.txt";
		}
		old.drawModel.downloadSkin = entity.drawModel.downloadSkin != 0;
	}
	if (entity.drawName_ != null) {
		old.drawName = new DrawName();
		if (entity.drawName_.color != null) {
			old.drawName.name = game.platform.stringFormat2("{0}{1}", entity.drawName_.color, entity.drawName_.name);
		}
		else {
			old.drawName.name = entity.drawName_.name;
		}
		if (!game.platform.stringStartsWithIgnoreCase(old.drawName.name, "&")) {
			old.drawName.name = game.platform.stringFormat("&f{0}", old.drawName.name);
		}
		old.drawName.onlyWhenSelected = entity.drawName_.onlyWhenSelected;
		old.drawName.clientAutoComplete = entity.drawName_.clientAutoComplete;
	}
	if (entity.drawText != null) {
		old.drawText = new EntityDrawText();
		old.drawText.text = entity.drawText.text;
		var one_ = 1;
		old.drawText.dx = (one_ * entity.drawText.dx) / (32);
		old.drawText.dy = (one_ * entity.drawText.dy) / (32);
		old.drawText.dz = (one_ * entity.drawText.dz) / (32);
	}
	else {
		old.drawText = null;
	}
	if (entity.drawBlock != null) {
	}
	if (entity.push != null) {
		old.push = new Packet_ServerExplosion();
		old.push.rangeFloat = entity.push.rangeFloat;
	}
	else {
		old.push = null;
	}
	old.usable = entity.usable;
	if (entity.drawArea != null) {
		old.drawArea = new EntityDrawArea();
		old.drawArea.x = entity.drawArea.x;
		old.drawArea.y = entity.drawArea.y;
		old.drawArea.z = entity.drawArea.z;
		old.drawArea.sizex = entity.drawArea.sizex;
		old.drawArea.sizey = entity.drawArea.sizey;
		old.drawArea.sizez = entity.drawArea.sizez;
	}
	else {
		old.drawArea = null;
	}
	return old;
}

ClientPacketHandlerEntitySpawn.toClientEntityPosition = function(pos) {
	var one = 1;
	var p = new EntityPosition_();
	p.x = (one * pos.x) / (32);
	p.y = (one * pos.y) / (32);
	p.z = (one * pos.z) / (32);
	p.rotx = Game.angle256ToRad(pos.pitch);
	p.roty = Game.angle256ToRad(pos.heading);
	return p;
}

function ClientPackets()
{
}

ClientPackets.activeMaterialSlot = function(ActiveMaterial) {
	var p = new Packet_Client();
	{
		p.id = 56;
		p.activeMaterialSlot = new Packet_ClientActiveMaterialSlot();
		p.activeMaterialSlot.activeMaterialSlot = ActiveMaterial;
	}
	return p;
}

ClientPackets.chat = function(s, isTeamchat) {
	var p = new Packet_ClientMessage();
	p.message = s;
	p.isTeamchat = isTeamchat;
	var pp = new Packet_Client();
	pp.id = 13;
	pp.message = p;
	return pp;
}

ClientPackets.craft = function(x, y, z, recipeId) {
	var cmd = new Packet_ClientCraft();
	cmd.x = x;
	cmd.y = y;
	cmd.z = z;
	cmd.recipeId = recipeId;
	var p = new Packet_Client();
	p.id = 9;
	p.craft = cmd;
	return p;
}

ClientPackets.createLoginPacket = function(platform, username, verificationKey) {
	var p = new Packet_ClientIdentification();
	{
		p.username = username;
		p.mdProtocolVersion = platform.getGameVersion();
		p.verificationKey = verificationKey;
	}
	var pp = new Packet_Client();
	pp.id = 0;
	pp.identification = p;
	return pp;
}

ClientPackets.createLoginPacket_ = function(platform, username, verificationKey, serverPassword) {
	var p = new Packet_ClientIdentification();
	{
		p.username = username;
		p.mdProtocolVersion = platform.getGameVersion();
		p.verificationKey = verificationKey;
		p.serverPassword = serverPassword;
	}
	var pp = new Packet_Client();
	pp.id = 0;
	pp.identification = p;
	return pp;
}

ClientPackets.death = function(reason, sourcePlayer) {
	var p = new Packet_Client();
	p.id = 60;
	p.death = new Packet_ClientDeath();
	{
		p.death.reason = reason;
		p.death.sourcePlayer = sourcePlayer;
	}
	return p;
}

ClientPackets.dialogClick = function(widgetId, textValues, textValuesCount) {
	var p = new Packet_Client();
	p.id = 14;
	p.dialogClick_ = new Packet_ClientDialogClick();
	p.dialogClick_.widgetId = widgetId;
	p.dialogClick_.setTextBoxValue(textValues, textValuesCount, textValuesCount);
	return p;
}

ClientPackets.fillArea = function(startx, starty, startz, endx, endy, endz, blockType, ActiveMaterial) {
	var p = new Packet_ClientFillArea();
	{
		p.x1 = startx;
		p.y1 = starty;
		p.z1 = startz;
		p.x2 = endx;
		p.y2 = endy;
		p.z2 = endz;
		p.blockType = blockType;
		p.materialSlot = ActiveMaterial;
	}
	var pp = new Packet_Client();
	pp.id = 510;
	pp.fillArea = p;
	return pp;
}

ClientPackets.gameResolution = function(width, height) {
	var p = new Packet_ClientGameResolution();
	p.width = width;
	p.height = height;
	var pp = new Packet_Client();
	pp.id = 10;
	pp.gameResolution = p;
	return pp;
}

ClientPackets.health = function(currentHealth) {
	var p = new Packet_Client();
	{
		p.id = 52;
		p.health = new Packet_ClientHealth();
		p.health.currentHealth = currentHealth;
	}
	return p;
}

ClientPackets.hitEntity = function(entityId) {
	var p = new Packet_Client();
	p.id = 61;
	p.entityInteraction = new Packet_ClientEntityInteraction();
	p.entityInteraction.entityId = entityId;
	p.entityInteraction.interactionType = 1;
	return p;
}

ClientPackets.inventoryClick = function(pos) {
	var p = new Packet_ClientInventoryAction();
	p.a = pos;
	p.action = 0;
	var pp = new Packet_Client();
	pp.id = 51;
	pp.inventoryAction = p;
	return pp;
}

ClientPackets.leave = function(reason) {
	var p = new Packet_Client();
	p.id = 57;
	p.leave = new Packet_ClientLeave();
	p.leave.reason = reason;
	return p;
}

ClientPackets.monsterHit = function(damage) {
	var p = new Packet_ClientHealth();
	p.currentHealth = damage;
	var packet = new Packet_Client();
	packet.id = 53;
	packet.health = p;
	return packet;
}

ClientPackets.moveToInventory = function(from) {
	var p = new Packet_ClientInventoryAction();
	p.a = from;
	p.action = 2;
	var pp = new Packet_Client();
	pp.id = 51;
	pp.inventoryAction = p;
	return pp;
}

ClientPackets.oxygen = function(currentOxygen) {
	var packet = new Packet_Client();
	packet.id = 59;
	packet.oxygen = new Packet_ClientOxygen();
	packet.oxygen.currentOxygen = currentOxygen;
	return packet;
}

ClientPackets.pingReply = function() {
	var p = new Packet_ClientPingReply();
	var pp = new Packet_Client();
	pp.id = 1;
	pp.pingReply = p;
	return pp;
}

ClientPackets.positionAndOrientation = function(game, playerId, positionX, positionY, positionZ, orientationX, orientationY, orientationZ, stance) {
	var p = new Packet_ClientPositionAndOrientation();
	{
		p.playerId = playerId;
		p.x = game.platform.floatToInt(positionX * 32);
		p.y = game.platform.floatToInt(positionY * 32);
		p.z = game.platform.floatToInt(positionZ * 32);
		p.heading = game.platform.floatToInt(Game.radToAngle256(orientationY));
		p.pitch = game.platform.floatToInt(Game.radToAngle256(orientationX));
		p.stance = stance;
	}
	var pp = new Packet_Client();
	pp.id = 8;
	pp.positionAndOrientation = p;
	return pp;
}

ClientPackets.reload = function() {
	var p = new Packet_Client();
	p.id = 58;
	p.reload = new Packet_ClientReload();
	return p;
}

ClientPackets.requestBlob = function(game, required, requiredCount) {
	var p = new Packet_ClientRequestBlob();
	if (GameVersionHelper.serverVersionAtLeast(game.platform, game.serverGameVersion, 2014, 4, 13)) {
		p.requestedMd5 = new Packet_StringList();
		p.requestedMd5.setItems(required, requiredCount, requiredCount);
	}
	var pp = new Packet_Client();
	pp.id = 50;
	pp.requestBlob = p;
	return pp;
}

ClientPackets.serverQuery = function() {
	var p1 = new Packet_ClientServerQuery();
	var pp = new Packet_Client();
	pp.id = 64;
	pp.query = p1;
	return pp;
}

ClientPackets.setBlock = function(x, y, z, mode, type, materialslot) {
	var p = new Packet_ClientSetBlock();
	{
		p.x = x;
		p.y = y;
		p.z = z;
		p.mode = mode;
		p.blockType = type;
		p.materialSlot = materialslot;
	}
	var pp = new Packet_Client();
	pp.id = 5;
	pp.setBlock = p;
	return pp;
}

ClientPackets.specialKeyRespawn = function() {
	var p = new Packet_Client();
	{
		p.id = 55;
		p.specialKey_ = new Packet_ClientSpecialKey();
		p.specialKey_.key_ = 0;
	}
	return p;
}

ClientPackets.specialKeySelectTeam = function() {
	var p = new Packet_Client();
	{
		p.id = 55;
		p.specialKey_ = new Packet_ClientSpecialKey();
		p.specialKey_.key_ = 3;
	}
	return p;
}

ClientPackets.specialKeySetSpawn = function() {
	var p = new Packet_Client();
	{
		p.id = 55;
		p.specialKey_ = new Packet_ClientSpecialKey();
		p.specialKey_.key_ = 1;
	}
	return p;
}

ClientPackets.specialKeyTabPlayerList = function() {
	var p = new Packet_Client();
	p.id = 55;
	p.specialKey_ = new Packet_ClientSpecialKey();
	p.specialKey_.key_ = 2;
	return p;
}

ClientPackets.useEntity = function(entityId) {
	var p = new Packet_Client();
	p.id = 61;
	p.entityInteraction = new Packet_ClientEntityInteraction();
	p.entityInteraction.entityId = entityId;
	p.entityInteraction.interactionType = 0;
	return p;
}

ClientPackets.wearItem = function(from, to) {
	var p = new Packet_ClientInventoryAction();
	p.a = from;
	p.b = to;
	p.action = 1;
	var pp = new Packet_Client();
	pp.id = 51;
	pp.inventoryAction = p;
	return pp;
}

function ClientSimple()
{
	this.connection = null;
	this.mainSocket = null;
	this.name = null;
	this.chunksseen = null;
	this.connected = false;
	this.glX = null;
	this.glY = null;
	this.glZ = null;
	this.inventory = null;
	this.inventoryDirty = false;
	this.notifyMapAction = null;
	this.pingLastMilliseconds = 0;
	this.inventory = new Packet_Inventory();
	this.inventory.setRightHand(new Array(10), 10, 10);
	for (var i = 0; i < 10; i++) {
		this.inventory.rightHand[i] = new Packet_Item();
	}
}

function ClientStateOnServer()
{
}
ClientStateOnServer.CONNECTING = 0;
ClientStateOnServer.LOADING_GENERATING = 1;
ClientStateOnServer.LOADING_SENDING = 2;
ClientStateOnServer.PLAYING = 3;

function Config3d()
{
	this.eNABLE_BACKFACECULLING = false;
	this.eNABLE_MIPMAPS = false;
	this.eNABLE_TRANSPARENCY = false;
	this.eNABLE_VISIBILITY_CULLING = false;
	this.viewdistance = null;
	this.eNABLE_BACKFACECULLING = true;
	this.eNABLE_TRANSPARENCY = true;
	this.eNABLE_MIPMAPS = true;
	this.eNABLE_VISIBILITY_CULLING = false;
	this.viewdistance = 128;
}

Config3d.prototype.getEnableMipmaps = function() {
	return this.eNABLE_MIPMAPS;
}

Config3d.prototype.getEnableTransparency = function() {
	return this.eNABLE_TRANSPARENCY;
}

Config3d.prototype.getViewDistance = function() {
	return this.viewdistance;
}

Config3d.prototype.setEnableMipmaps = function(value) {
	this.eNABLE_MIPMAPS = value;
}

Config3d.prototype.setEnableTransparency = function(value) {
	this.eNABLE_TRANSPARENCY = value;
}

Config3d.prototype.setViewDistance = function(value) {
	this.viewdistance = value;
}

function ConnectData()
{
	this.auth = null;
	this.ip = null;
	this.isServePasswordProtected = false;
	this.port = 0;
	this.serverPassword = null;
	this.username = null;
}

ConnectData.fromUri = function(uri) {
	var c = new ConnectData();
	c = new ConnectData();
	c.ip = uri.getIp();
	c.port = 25565;
	c.username = "gamer";
	if (uri.getPort() != -1) {
		c.port = uri.getPort();
	}
	if (uri.getGet().containsKey("user")) {
		c.username = uri.getGet().get("user");
	}
	if (uri.getGet().containsKey("auth")) {
		c.auth = uri.getGet().get("auth");
	}
	if (uri.getGet().containsKey("serverPassword")) {
		c.isServePasswordProtected = MiscCi.readBool(uri.getGet().get("serverPassword"));
	}
	return c;
}

ConnectData.prototype.getIsServePasswordProtected = function() {
	return this.isServePasswordProtected;
}

ConnectData.prototype.setIp = function(value) {
	this.ip = value;
}

ConnectData.prototype.setIsServePasswordProtected = function(value) {
	this.isServePasswordProtected = value;
}

ConnectData.prototype.setPort = function(value) {
	this.port = value;
}

ConnectData.prototype.setServerPassword = function(value) {
	this.serverPassword = value;
}

ConnectData.prototype.setUsername = function(value) {
	this.username = value;
}

function ConnectedPlayer()
{
	this.id = 0;
	this.name = null;
	this.ping = 0;
}

function Controls()
{
	this.freemove = false;
	this.movedown = false;
	this.movedx = null;
	this.movedy = null;
	this.moveup = false;
	this.noclip = false;
	this.shiftkeydown = false;
	this.wantsjump = false;
	this.wantsjumphalf = false;
}

Controls.prototype.getFreemove = function() {
	if (!this.freemove) {
		return 0;
	}
	if (this.noclip) {
		return 2;
	}
	else {
		return 1;
	}
}

Controls.prototype.setFreemove = function(level) {
	if (level == 0) {
		this.freemove = false;
		this.noclip = false;
	}
	if (level == 1) {
		this.freemove = true;
		this.noclip = false;
	}
	if (level == 2) {
		this.freemove = true;
		this.noclip = true;
	}
}

function CornerEnum()
{
}
CornerEnum.BOTTOM_LEFT = 2;
CornerEnum.BOTTOM_RIGHT = 3;
CornerEnum.NONE = -1;
CornerEnum.TOP_LEFT = 0;
CornerEnum.TOP_RIGHT = 1;

function CraftingTableTool()
{
	this.d_Data = null;
	this.d_Map = null;
}

CraftingTableTool.prototype.getOnTable = function(table, tableCount, retCount) {
	var ontable = new Int32Array(new ArrayBuffer(2048 << 2));
	var ontableCount = 0;
	for (var i = 0; i < tableCount; i++) {
		var v = table[i];
		var t = this.d_Map.getBlock(v.x, v.y, v.z + 1);
		ontable[ontableCount++] = t;
	}
	retCount.value = ontableCount;
	return ontable;
}

CraftingTableTool.prototype.getTable = function(posx, posy, posz, retCount) {
	var l = new Array(2048);
	var lCount = 0;
	var todo = new Array(2048);
	var todoCount = 0;
	todo[todoCount++] = Vector3IntRef.create(posx, posy, posz);
	for (;;) {
		if (todoCount == 0 || lCount >= 2000) {
			break;
		}
		var p = todo[todoCount - 1];
		todoCount--;
		if (this.vector3IntRefArrayContains(l, lCount, p)) {
			continue;
		}
		l[lCount++] = p;
		var a = Vector3IntRef.create(p.x + 1, p.y, p.z);
		if (this.d_Map.getBlock(a.x, a.y, a.z) == this.d_Data.blockIdCraftingTable()) {
			todo[todoCount++] = a;
		}
		var b = Vector3IntRef.create(p.x - 1, p.y, p.z);
		if (this.d_Map.getBlock(b.x, b.y, b.z) == this.d_Data.blockIdCraftingTable()) {
			todo[todoCount++] = b;
		}
		var c = Vector3IntRef.create(p.x, p.y + 1, p.z);
		if (this.d_Map.getBlock(c.x, c.y, c.z) == this.d_Data.blockIdCraftingTable()) {
			todo[todoCount++] = c;
		}
		var d = Vector3IntRef.create(p.x, p.y - 1, p.z);
		if (this.d_Map.getBlock(d.x, d.y, d.z) == this.d_Data.blockIdCraftingTable()) {
			todo[todoCount++] = d;
		}
	}
	retCount.value = lCount;
	return l;
}

CraftingTableTool.prototype.vector3IntRefArrayContains = function(l, lCount, p) {
	for (var i = 0; i < lCount; i++) {
		if (l[i].x == p.x && l[i].y == p.y && l[i].z == p.z) {
			return true;
		}
	}
	return false;
}

function CubeModelData()
{
}

CubeModelData.getCubeModelData = function() {
	var m = new ModelData();
	var xyz = new Float32Array(new ArrayBuffer(72 << 2));
	for (var i = 0; i < 72; i++) {
		xyz[i] = CubeModelData.CI_CONST_ARRAY_1[i];
	}
	m.setXyz(xyz);
	var uv = new Float32Array(new ArrayBuffer(48 << 2));
	for (var i = 0; i < 48; i++) {
		uv[i] = CubeModelData.CI_CONST_ARRAY_2[i];
	}
	m.setUv(uv);
	m.setVerticesCount(24);
	m.setIndices(CubeModelData.CI_CONST_ARRAY_3);
	m.setIndicesCount(36);
	return m;
}
CubeModelData.CI_CONST_ARRAY_1 = [ -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1,
	1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1,
	1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1,
	1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1,
	-1, 1, -1, 1, 1, -1, 1, -1 ];
CubeModelData.CI_CONST_ARRAY_2 = [ 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0,
	0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0,
	1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1 ];
CubeModelData.CI_CONST_ARRAY_3 = [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8,
	10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21,
	22, 20, 22, 23 ];

function CuboidRenderer()
{
}

CuboidRenderer.addVertex = function(model, x, y, z, u, v, color) {
	model.xyz[model.getXyzCount() + 0] = x;
	model.xyz[model.getXyzCount() + 1] = y;
	model.xyz[model.getXyzCount() + 2] = z;
	model.uv[model.getUvCount() + 0] = u;
	model.uv[model.getUvCount() + 1] = v;
	model.rgba[model.getRgbaCount() + 0] = Game.intToByte(Game.colorR(color));
	model.rgba[model.getRgbaCount() + 1] = Game.intToByte(Game.colorG(color));
	model.rgba[model.getRgbaCount() + 2] = Game.intToByte(Game.colorB(color));
	model.rgba[model.getRgbaCount() + 3] = Game.intToByte(Game.colorA(color));
	model.verticesCount++;
}

CuboidRenderer.cuboidNet = function(tsizex, tsizey, tsizez, tstartx, tstarty) {
	var coords = new Array(6);
	{
		coords[0] = RectangleFloat.create(tsizez + tstartx, tsizez + tstarty, tsizex, tsizey);
		coords[1] = RectangleFloat.create(2 * tsizez + tsizex + tstartx, tsizez + tstarty, tsizex, tsizey);
		coords[2] = RectangleFloat.create(tstartx, tsizez + tstarty, tsizez, tsizey);
		coords[3] = RectangleFloat.create(tsizez + tsizex + tstartx, tsizez + tstarty, tsizez, tsizey);
		coords[4] = RectangleFloat.create(tsizez + tstartx, tstarty, tsizex, tsizez);
		coords[5] = RectangleFloat.create(tsizez + tsizex + tstartx, tstarty, tsizex, tsizez);
	}
	return coords;
}

CuboidRenderer.cuboidNetNormalize = function(coords, texturewidth, textureheight) {
	var AtiArtifactFix = 0.15;
	for (var i = 0; i < 6; i++) {
		var x = (coords[i].x + AtiArtifactFix) / (texturewidth);
		var y = (coords[i].y + AtiArtifactFix) / (textureheight);
		var w = (coords[i].x + coords[i].width - AtiArtifactFix) / (texturewidth) - x;
		var h = (coords[i].y + coords[i].height - AtiArtifactFix) / (textureheight) - y;
		coords[i] = RectangleFloat.create(x, y, w, h);
	}
}

CuboidRenderer.drawCuboid = function(game, posX, posY, posZ, sizeX, sizeY, sizeZ, texturecoords, light) {
	var data = new ModelData();
	data.xyz = new Float32Array(new ArrayBuffer(72 << 2));
	data.uv = new Float32Array(new ArrayBuffer(48 << 2));
	data.rgba = new Uint8Array(new ArrayBuffer(96));
	var light255 = game.platform.floatToInt(light * 255);
	var color = Game.colorFromArgb(255, light255, light255, light255);
	var rect;
	rect = texturecoords[0];
	CuboidRenderer.addVertex(data, posX, posY, posZ, rect.x, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX, posY, posZ + sizeZ, rect.x + rect.width, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX, posY + sizeY, posZ + sizeZ, rect.x + rect.width, rect.y, color);
	CuboidRenderer.addVertex(data, posX, posY + sizeY, posZ, rect.x, rect.y, color);
	rect = texturecoords[1];
	CuboidRenderer.addVertex(data, posX + sizeX, posY, posZ, rect.x, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX + sizeX, posY, posZ + sizeZ, rect.x + rect.width, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX + sizeX, posY + sizeY, posZ + sizeZ, rect.x + rect.width, rect.y, color);
	CuboidRenderer.addVertex(data, posX + sizeX, posY + sizeY, posZ, rect.x, rect.y, color);
	rect = texturecoords[2];
	CuboidRenderer.addVertex(data, posX + sizeX, posY, posZ, rect.x, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX, posY, posZ, rect.x + rect.width, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX, posY + sizeY, posZ, rect.x + rect.width, rect.y, color);
	CuboidRenderer.addVertex(data, posX + sizeX, posY + sizeY, posZ, rect.x, rect.y, color);
	rect = texturecoords[3];
	CuboidRenderer.addVertex(data, posX + sizeX, posY, posZ + sizeZ, rect.x + rect.width, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX, posY, posZ + sizeZ, rect.x, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX, posY + sizeY, posZ + sizeZ, rect.x, rect.y, color);
	CuboidRenderer.addVertex(data, posX + sizeX, posY + sizeY, posZ + sizeZ, rect.x + rect.width, rect.y, color);
	rect = texturecoords[4];
	CuboidRenderer.addVertex(data, posX, posY + sizeY, posZ, rect.x, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX, posY + sizeY, posZ + sizeZ, rect.x + rect.width, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX + sizeX, posY + sizeY, posZ + sizeZ, rect.x + rect.width, rect.y, color);
	CuboidRenderer.addVertex(data, posX + sizeX, posY + sizeY, posZ, rect.x, rect.y, color);
	rect = texturecoords[5];
	CuboidRenderer.addVertex(data, posX, posY, posZ, rect.x, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX, posY, posZ + sizeZ, rect.x + rect.width, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX + sizeX, posY, posZ + sizeZ, rect.x + rect.width, rect.y, color);
	CuboidRenderer.addVertex(data, posX + sizeX, posY, posZ, rect.x, rect.y, color);
	data.indices = new Int32Array(new ArrayBuffer(36 << 2));
	for (var i = 0; i < 6; i++) {
		data.indices[i * 6 + 0] = i * 4 + 3;
		data.indices[i * 6 + 1] = i * 4 + 2;
		data.indices[i * 6 + 2] = i * 4 + 0;
		data.indices[i * 6 + 3] = i * 4 + 2;
		data.indices[i * 6 + 4] = i * 4 + 1;
		data.indices[i * 6 + 5] = i * 4 + 0;
	}
	data.indicesCount = 36;
	game.platform.glDisableCullFace();
	game.drawModelData(data);
	game.platform.glEnableCullFace();
}

CuboidRenderer.drawCuboid2 = function(game, posX, posY, posZ, sizeX, sizeY, sizeZ, texturecoords, light) {
	var data = new ModelData();
	data.xyz = new Float32Array(new ArrayBuffer(72 << 2));
	data.uv = new Float32Array(new ArrayBuffer(48 << 2));
	data.rgba = new Uint8Array(new ArrayBuffer(96));
	var light255 = game.platform.floatToInt(light * 255);
	var color = Game.colorFromArgb(255, light255, light255, light255);
	var rect;
	rect = texturecoords[2];
	CuboidRenderer.addVertex(data, posX, posY, posZ, rect.x, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX, posY, posZ + sizeZ, rect.x + rect.width, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX, posY + sizeY, posZ + sizeZ, rect.x + rect.width, rect.y, color);
	CuboidRenderer.addVertex(data, posX, posY + sizeY, posZ, rect.x, rect.y, color);
	rect = texturecoords[3];
	CuboidRenderer.addVertex(data, posX + sizeX, posY, posZ + sizeZ, rect.x, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX + sizeX, posY, posZ, rect.x + rect.width, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX + sizeX, posY + sizeY, posZ, rect.x + rect.width, rect.y, color);
	CuboidRenderer.addVertex(data, posX + sizeX, posY + sizeY, posZ + sizeZ, rect.x, rect.y, color);
	rect = texturecoords[1];
	CuboidRenderer.addVertex(data, posX + sizeX, posY, posZ, rect.x, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX, posY, posZ, rect.x + rect.width, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX, posY + sizeY, posZ, rect.x + rect.width, rect.y, color);
	CuboidRenderer.addVertex(data, posX + sizeX, posY + sizeY, posZ, rect.x, rect.y, color);
	rect = texturecoords[0];
	CuboidRenderer.addVertex(data, posX + sizeX, posY, posZ + sizeZ, rect.x + rect.width, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX, posY, posZ + sizeZ, rect.x, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX, posY + sizeY, posZ + sizeZ, rect.x, rect.y, color);
	CuboidRenderer.addVertex(data, posX + sizeX, posY + sizeY, posZ + sizeZ, rect.x + rect.width, rect.y, color);
	rect = texturecoords[4];
	CuboidRenderer.addVertex(data, posX, posY + sizeY, posZ, rect.x, rect.y, color);
	CuboidRenderer.addVertex(data, posX, posY + sizeY, posZ + sizeZ, rect.x, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX + sizeX, posY + sizeY, posZ + sizeZ, rect.x + rect.width, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX + sizeX, posY + sizeY, posZ, rect.x + rect.width, rect.y, color);
	rect = texturecoords[5];
	CuboidRenderer.addVertex(data, posX, posY, posZ, rect.x, rect.y, color);
	CuboidRenderer.addVertex(data, posX, posY, posZ + sizeZ, rect.x, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX + sizeX, posY, posZ + sizeZ, rect.x + rect.width, rect.bottom(), color);
	CuboidRenderer.addVertex(data, posX + sizeX, posY, posZ, rect.x + rect.width, rect.y, color);
	data.indices = new Int32Array(new ArrayBuffer(36 << 2));
	for (var i = 0; i < 6; i++) {
		data.indices[i * 6 + 0] = i * 4 + 3;
		data.indices[i * 6 + 1] = i * 4 + 2;
		data.indices[i * 6 + 2] = i * 4 + 0;
		data.indices[i * 6 + 3] = i * 4 + 2;
		data.indices[i * 6 + 4] = i * 4 + 1;
		data.indices[i * 6 + 5] = i * 4 + 0;
	}
	data.indicesCount = 36;
	game.platform.glDisableCullFace();
	game.drawModelData(data);
	game.platform.glEnableCullFace();
}

function DelegateGetBlockHeight()
{
}

function DelegateIsBlockEmpty()
{
}

function GameScreen()
{
	this.widgetCount = 0;
	this.game = null;
	this.screenx = 0;
	this.screeny = 0;
	this.widgets = null;
	this.widgetCount = 64;
	this.widgets = new Array(this.widgetCount);
}
GameScreen.prototype = new ClientMod();

GameScreen.prototype.charRepeat = function(c, length) {
	var charArray = new Int32Array(new ArrayBuffer(length << 2));
	for (var i = 0; i < length; i++) {
		charArray[i] = c;
	}
	return this.game.platform.charArrayToString(charArray, length);
}

GameScreen.prototype.charToString = function(a) {
	var arr = new Int32Array(new ArrayBuffer(1 << 2));
	arr[0] = a;
	return this.game.platform.charArrayToString(arr, 1);
}

GameScreen.prototype.drawWidgets = function() {
	for (var i = 0; i < this.widgetCount; i++) {
		var w = this.widgets[i];
		if (w != null) {
			if (!w.visible) {
				continue;
			}
			var text = w.text;
			if (w.selected) {
				text = StringTools.stringAppend(this.game.platform, "&2", text);
			}
			if (w.type == WidgetType.BUTTON) {
				if (w.buttonStyle == ButtonStyle.TEXT) {
				}
				else {
					if (w.image != null) {
						this.game.draw2dBitmapFile(w.image, this.screenx + w.x, this.screeny + w.y, w.sizex, w.sizey);
					}
					else {
						this.game.draw2dTexture(this.game.whiteTexture(), this.screenx + w.x, this.screeny + w.y, w.sizex, w.sizey, null, 0, w.color, false);
					}
					this.game.draw2dText(text, w.font, this.screenx + w.x, this.screeny + w.y + w.sizey / (2), null, false);
				}
			}
			if (w.type == WidgetType.TEXTBOX) {
				if (w.password) {
					text = this.charRepeat(42, StringTools.stringLength(this.game.platform, w.text));
				}
				if (w.editing) {
					text = StringTools.stringAppend(this.game.platform, text, "_");
				}
				{
					this.game.draw2dText(text, w.font, this.screenx + w.x, this.screeny + w.y, null, false);
				}
				{
				}
			}
			if (w.type == WidgetType.LABEL) {
				this.game.draw2dText(text, w.font, this.screenx + w.x, this.screeny + w.y, IntRef.create(w.color), false);
			}
			if (w.description != null) {
			}
		}
	}
}

GameScreen.prototype.keyDown = function(e) {
	for (var i = 0; i < this.widgetCount; i++) {
		var w = this.widgets[i];
		if (w != null) {
			if (w.type == WidgetType.TEXTBOX) {
				if (w.editing) {
					var key = e.getKeyCode();
					if (e.getCtrlPressed() && key == 104) {
						if (this.game.platform.clipboardContainsText()) {
							w.text = StringTools.stringAppend(this.game.platform, w.text, this.game.platform.clipboardGetText());
						}
						return;
					}
					if (key == 53) {
						if (StringTools.stringLength(this.game.platform, w.text) > 0) {
							w.text = StringTools.stringSubstring(this.game.platform, w.text, 0, StringTools.stringLength(this.game.platform, w.text) - 1);
						}
						return;
					}
				}
			}
		}
	}
}

GameScreen.prototype.keyPress = function(e) {
	for (var i = 0; i < this.widgetCount; i++) {
		var w = this.widgets[i];
		if (w != null) {
			if (w.type == WidgetType.TEXTBOX) {
				if (w.editing) {
					if (this.game.platform.isValidTypingChar(e.getKeyChar())) {
						w.text = StringTools.stringAppend(this.game.platform, w.text, this.charToString(e.getKeyChar()));
					}
				}
			}
		}
	}
}

GameScreen.prototype.mouseDown = function(x, y) {
	var handled = false;
	var editingChange = false;
	for (var i = 0; i < this.widgetCount; i++) {
		var w = this.widgets[i];
		if (w != null) {
			if (w.type == WidgetType.BUTTON) {
				w.pressed = this.pointInRect(x, y, this.screenx + w.x, this.screeny + w.y, w.sizex, w.sizey);
				if (w.pressed) {
					handled = true;
				}
			}
			if (w.type == WidgetType.TEXTBOX) {
				w.pressed = this.pointInRect(x, y, this.screenx + w.x, this.screeny + w.y, w.sizex, w.sizey);
				if (w.pressed) {
					handled = true;
				}
				var wasEditing = w.editing;
				w.editing = w.pressed;
				if (w.editing && !wasEditing) {
					this.game.platform.showKeyboard(true);
					editingChange = true;
				}
				if (!w.editing && wasEditing && !editingChange) {
					this.game.platform.showKeyboard(false);
				}
			}
		}
	}
	return handled;
}

GameScreen.prototype.mouseMove = function(e) {
	if (e.getEmulated() && !e.getForceUsage()) {
		return;
	}
	for (var i = 0; i < this.widgetCount; i++) {
		var w = this.widgets[i];
		if (w != null) {
			w.hover = this.pointInRect(e.getX(), e.getY(), this.screenx + w.x, this.screeny + w.y, w.sizex, w.sizey);
		}
	}
}

GameScreen.prototype.mouseUp = function(x, y) {
	for (var i = 0; i < this.widgetCount; i++) {
		var w = this.widgets[i];
		if (w != null) {
			w.pressed = false;
		}
	}
	for (var i = 0; i < this.widgetCount; i++) {
		var w = this.widgets[i];
		if (w != null) {
			if (w.type == WidgetType.BUTTON) {
				if (this.pointInRect(x, y, this.screenx + w.x, this.screeny + w.y, w.sizex, w.sizey)) {
					this.onButton(w);
				}
			}
		}
	}
}

GameScreen.prototype.onBackPressed = function() {
}

GameScreen.prototype.onButton = function(w) {
}

GameScreen.prototype.onKeyDown = function(game_, args) {
	this.keyDown(args);
}

GameScreen.prototype.onKeyPress = function(game_, args) {
	this.keyPress(args);
}

GameScreen.prototype.onMouseDown = function(game_, args) {
	this.mouseDown(args.getX(), args.getY());
}

GameScreen.prototype.onMouseMove = function(game_, args) {
	this.mouseMove(args);
}

GameScreen.prototype.onMouseUp = function(game_, args) {
	this.mouseUp(args.getX(), args.getY());
}

GameScreen.prototype.onMouseWheel = function(e) {
}

GameScreen.prototype.onTouchEnd = function(game_, e) {
	this.screenOnTouchEnd(e);
}

GameScreen.prototype.onTouchStart = function(game_, e) {
	this.screenOnTouchStart(e);
}

GameScreen.prototype.screenOnTouchEnd = function(e) {
	this.mouseUp(e.getX(), e.getY());
}

GameScreen.prototype.screenOnTouchStart = function(e) {
	e.setHandled(this.mouseDown(e.getX(), e.getY()));
}

GameScreen.prototype.pointInRect = function(x, y, rx, ry, rw, rh) {
	return x >= rx && y >= ry && x < rx + rw && y < ry + rh;
}

function DialogScreen()
{
}
DialogScreen.prototype = new GameScreen();

DialogScreen.prototype.onButton = function(w) {
	if (w.isbutton) {
		var textValues = new Array(this.widgetCount);
		for (var i = 0; i < this.widgetCount; i++) {
			var s = this.widgets[i].text;
			if (s == null) {
				s = "";
			}
			textValues[i] = s;
		}
		this.game.sendPacketClient(ClientPackets.dialogClick(w.id, textValues, this.widgetCount));
	}
}

function DictionaryStringAudioData()
{
	this.keys = null;
	this.values = null;
	this.keys = new Array(1024);
	for (var i = 0; i < 1024; i++) {
		this.keys[i] = null;
	}
	this.values = new Array(1024);
	for (var i = 0; i < 1024; i++) {
		this.values[i] = null;
	}
}

DictionaryStringAudioData.prototype.contains = function(key) {
	var id = this.getId(key);
	return id != -1;
}

DictionaryStringAudioData.prototype.getById = function(id) {
	return this.values[id];
}

DictionaryStringAudioData.prototype.getId = function(key) {
	for (var i = 0; i < 1024; i++) {
		if (this.keys[i] == key) {
			return i;
		}
	}
	return -1;
}

DictionaryStringAudioData.prototype.set = function(key, bmp) {
	var id = this.getId(key);
	if (id != -1) {
		this.values[id] = bmp;
		return id;
	}
	for (var i = 0; i < 1024; i++) {
		if (this.keys[i] == null) {
			this.keys[i] = key;
			this.values[i] = bmp;
			return i;
		}
	}
	return -1;
}

function DictionaryStringAudioSample()
{
	this.count = 0;
	this.keys = null;
	this.max = 0;
	this.values = null;
	this.max = 1024;
	this.count = 0;
	this.keys = new Array(this.max);
	this.values = new Array(this.max);
}

DictionaryStringAudioSample.prototype.contains = function(key) {
	var index = this.getIndex(key);
	return index != -1;
}

DictionaryStringAudioSample.prototype.get = function(key) {
	var index = this.getIndex(key);
	return this.values[index];
}

DictionaryStringAudioSample.prototype.getIndex = function(key) {
	for (var i = 0; i < this.count; i++) {
		if (this.keys[i] == key) {
			return i;
		}
	}
	return -1;
}

DictionaryStringAudioSample.prototype.set = function(key, value) {
	var index = this.getIndex(key);
	if (index != -1) {
		this.values[index] = value;
		return;
	}
	this.keys[this.count] = key;
	this.values[this.count] = value;
	this.count++;
}

function DictionaryStringByteArray()
{
	this.items = null;
	this.itemsCount = 0;
	this.items = new Array(1024);
	this.itemsCount = 1024;
}

DictionaryStringByteArray.prototype.get = function(name) {
	for (var i = 0; i < this.itemsCount; i++) {
		if (this.items[i] == null) {
			continue;
		}
		if (Game.stringEquals(this.items[i].name, name)) {
			return this.items[i].data;
		}
	}
	return null;
}

DictionaryStringByteArray.prototype.set = function(name, value) {
	for (var i = 0; i < this.itemsCount; i++) {
		if (this.items[i] == null) {
			continue;
		}
		if (Game.stringEquals(this.items[i].name, name)) {
			this.items[i].data = value;
			return;
		}
	}
	for (var i = 0; i < this.itemsCount; i++) {
		if (this.items[i] == null) {
			this.items[i] = new StringByteArray();
			this.items[i].name = name;
			this.items[i].data = value;
			return;
		}
	}
}

function DictionaryStringInt1024()
{
	this.count = 0;
	this.items = null;
	this.items = new Array(1024);
	this.count = 0;
}

DictionaryStringInt1024.prototype.contains = function(key) {
	for (var i = 0; i < this.count; i++) {
		if (this.items[i] == null) {
			continue;
		}
		if (Game.stringEquals(this.items[i].key, key)) {
			return true;
		}
	}
	return false;
}

DictionaryStringInt1024.prototype.get = function(key) {
	for (var i = 0; i < this.count; i++) {
		if (this.items[i] == null) {
			continue;
		}
		if (Game.stringEquals(this.items[i].key, key)) {
			return this.items[i].value;
		}
	}
	return -1;
}

DictionaryStringInt1024.prototype.remove = function(key) {
	for (var i = 0; i < this.count; i++) {
		if (this.items[i] == null) {
			continue;
		}
		if (Game.stringEquals(this.items[i].key, key)) {
			this.items[i] = null;
			return true;
		}
	}
	return false;
}

DictionaryStringInt1024.prototype.set = function(key, value) {
	for (var i = 0; i < this.count; i++) {
		if (this.items[i] == null) {
			continue;
		}
		if (this.items[i].key == key) {
			this.items[i].value = value;
			return;
		}
	}
	for (var i = 0; i < this.count; i++) {
		if (this.items[i] == null) {
			this.items[i] = new KeyValueStringInt();
			this.items[i].key = key;
			this.items[i].value = value;
			return;
		}
	}
	var k = new KeyValueStringInt();
	k.key = key;
	k.value = value;
	this.items[this.count++] = k;
}

function DictionaryStringString()
{
	this.items = null;
	this.size = 0;
	this.start(64);
}

DictionaryStringString.prototype.containsKey = function(key) {
	for (var i = 0; i < this.size; i++) {
		if (this.items[i] == null) {
			continue;
		}
		if (Game.stringEquals(this.items[i].key, key)) {
			return true;
		}
	}
	return false;
}

DictionaryStringString.prototype.get = function(key) {
	for (var i = 0; i < this.size; i++) {
		if (this.items[i] == null) {
			continue;
		}
		if (Game.stringEquals(this.items[i].key, key)) {
			return this.items[i].value;
		}
	}
	return null;
}

DictionaryStringString.prototype.getSize = function() {
	return this.size;
}

DictionaryStringString.prototype.remove = function(key) {
	for (var i = 0; i < this.size; i++) {
		if (this.items[i] == null) {
			continue;
		}
		if (Game.stringEquals(this.items[i].key, key)) {
			this.items[i] = null;
		}
	}
}

DictionaryStringString.prototype.set = function(key, value) {
	for (var i = 0; i < this.size; i++) {
		if (this.items[i] == null) {
			continue;
		}
		if (Game.stringEquals(this.items[i].key, key)) {
			this.items[i].value = value;
			return;
		}
	}
	for (var i = 0; i < this.size; i++) {
		if (this.items[i] == null) {
			this.items[i] = new KeyValueStringString();
			this.items[i].key = key;
			this.items[i].value = value;
			return;
		}
	}
}

DictionaryStringString.prototype.start = function(size_) {
	this.items = new Array(size_);
	this.size = size_;
}

function DictionaryVector3Float()
{
	this.items = null;
	this.itemsCount = 0;
	this.itemsCount = 16384;
	this.items = new Array(this.itemsCount);
}

DictionaryVector3Float.prototype.clear = function() {
	for (var i = 0; i < this.itemsCount; i++) {
		this.items[i] = null;
	}
}

DictionaryVector3Float.prototype.containsKey = function(x, y, z) {
	return this.itemIndex(x, y, z) != -1;
}

DictionaryVector3Float.prototype.count = function() {
	var count = 0;
	for (var i = 0; i < this.itemsCount; i++) {
		if (this.items[i] != null) {
			count++;
		}
	}
	return count;
}

DictionaryVector3Float.prototype.get = function(x, y, z) {
	return this.items[this.itemIndex(x, y, z)].value;
}

DictionaryVector3Float.prototype.itemIndex = function(x, y, z) {
	for (var i = 0; i < this.itemsCount; i++) {
		if (this.items[i] == null) {
			continue;
		}
		var item = this.items[i];
		if (item.x == x && item.y == y && item.z == z) {
			return i;
		}
	}
	return -1;
}

DictionaryVector3Float.prototype.remove = function(x, y, z) {
	if (this.itemIndex(x, y, z) == -1) {
		return;
	}
	this.items[this.itemIndex(x, y, z)] = null;
}

DictionaryVector3Float.prototype.set = function(x, y, z, value) {
	var index = this.itemIndex(x, y, z);
	if (index != -1) {
		this.items[index].value = value;
	}
	else {
		for (var i = 0; i < this.itemsCount; i++) {
			if (this.items[i] == null) {
				var item = new Vector3Float();
				item.x = x;
				item.y = y;
				item.z = z;
				item.value = value;
				this.items[i] = item;
				return;
			}
		}
	}
}

function DirectionUtils()
{
}

DirectionUtils.possibleNewRails3 = function(enter_at) {
	var ret = new Array(3);
	switch (enter_at) {
	case TileEnterDirection.LEFT:
		ret[0] = VehicleDirection12.UP_LEFT_UP;
		ret[1] = VehicleDirection12.HORIZONTAL_RIGHT;
		ret[2] = VehicleDirection12.DOWN_LEFT_DOWN;
		break;
	case TileEnterDirection.DOWN:
		ret[0] = VehicleDirection12.DOWN_LEFT_LEFT;
		ret[1] = VehicleDirection12.VERTICAL_UP;
		ret[2] = VehicleDirection12.DOWN_RIGHT_RIGHT;
		break;
	case TileEnterDirection.UP:
		ret[0] = VehicleDirection12.UP_LEFT_LEFT;
		ret[1] = VehicleDirection12.VERTICAL_DOWN;
		ret[2] = VehicleDirection12.UP_RIGHT_RIGHT;
		break;
	case TileEnterDirection.RIGHT:
		ret[0] = VehicleDirection12.UP_RIGHT_UP;
		ret[1] = VehicleDirection12.HORIZONTAL_LEFT;
		ret[2] = VehicleDirection12.DOWN_RIGHT_DOWN;
		break;
	default:
		return null;
	}
	return ret;
}

DirectionUtils.railDirectionFlagsCount = function(railDirectionFlags) {
	var count = 0;
	if ((railDirectionFlags & DirectionUtils.toRailDirectionFlags(RailDirection.DOWN_LEFT)) != 0) {
		count++;
	}
	if ((railDirectionFlags & DirectionUtils.toRailDirectionFlags(RailDirection.DOWN_RIGHT)) != 0) {
		count++;
	}
	if ((railDirectionFlags & DirectionUtils.toRailDirectionFlags(RailDirection.HORIZONTAL)) != 0) {
		count++;
	}
	if ((railDirectionFlags & DirectionUtils.toRailDirectionFlags(RailDirection.UP_LEFT)) != 0) {
		count++;
	}
	if ((railDirectionFlags & DirectionUtils.toRailDirectionFlags(RailDirection.UP_RIGHT)) != 0) {
		count++;
	}
	if ((railDirectionFlags & DirectionUtils.toRailDirectionFlags(RailDirection.VERTICAL)) != 0) {
		count++;
	}
	return count;
}

DirectionUtils.resultEnter = function(direction) {
	switch (direction) {
	case TileExitDirection.UP:
		return TileEnterDirection.DOWN;
	case TileExitDirection.DOWN:
		return TileEnterDirection.UP;
	case TileExitDirection.LEFT:
		return TileEnterDirection.RIGHT;
	case TileExitDirection.RIGHT:
		return TileEnterDirection.LEFT;
	default:
		return TileEnterDirection.DOWN;
	}
}

DirectionUtils.resultExit = function(direction) {
	switch (direction) {
	case VehicleDirection12.HORIZONTAL_LEFT:
		return TileExitDirection.LEFT;
	case VehicleDirection12.HORIZONTAL_RIGHT:
		return TileExitDirection.RIGHT;
	case VehicleDirection12.VERTICAL_UP:
		return TileExitDirection.UP;
	case VehicleDirection12.VERTICAL_DOWN:
		return TileExitDirection.DOWN;
	case VehicleDirection12.UP_LEFT_UP:
		return TileExitDirection.UP;
	case VehicleDirection12.UP_LEFT_LEFT:
		return TileExitDirection.LEFT;
	case VehicleDirection12.UP_RIGHT_UP:
		return TileExitDirection.UP;
	case VehicleDirection12.UP_RIGHT_RIGHT:
		return TileExitDirection.RIGHT;
	case VehicleDirection12.DOWN_LEFT_DOWN:
		return TileExitDirection.DOWN;
	case VehicleDirection12.DOWN_LEFT_LEFT:
		return TileExitDirection.LEFT;
	case VehicleDirection12.DOWN_RIGHT_DOWN:
		return TileExitDirection.DOWN;
	case VehicleDirection12.DOWN_RIGHT_RIGHT:
		return TileExitDirection.RIGHT;
	default:
		return TileExitDirection.DOWN;
	}
}

DirectionUtils.reverse = function(direction) {
	switch (direction) {
	case VehicleDirection12.HORIZONTAL_LEFT:
		return VehicleDirection12.HORIZONTAL_RIGHT;
	case VehicleDirection12.HORIZONTAL_RIGHT:
		return VehicleDirection12.HORIZONTAL_LEFT;
	case VehicleDirection12.VERTICAL_UP:
		return VehicleDirection12.VERTICAL_DOWN;
	case VehicleDirection12.VERTICAL_DOWN:
		return VehicleDirection12.VERTICAL_UP;
	case VehicleDirection12.UP_LEFT_UP:
		return VehicleDirection12.UP_LEFT_LEFT;
	case VehicleDirection12.UP_LEFT_LEFT:
		return VehicleDirection12.UP_LEFT_UP;
	case VehicleDirection12.UP_RIGHT_UP:
		return VehicleDirection12.UP_RIGHT_RIGHT;
	case VehicleDirection12.UP_RIGHT_RIGHT:
		return VehicleDirection12.UP_RIGHT_UP;
	case VehicleDirection12.DOWN_LEFT_DOWN:
		return VehicleDirection12.DOWN_LEFT_LEFT;
	case VehicleDirection12.DOWN_LEFT_LEFT:
		return VehicleDirection12.DOWN_LEFT_DOWN;
	case VehicleDirection12.DOWN_RIGHT_DOWN:
		return VehicleDirection12.DOWN_RIGHT_RIGHT;
	case VehicleDirection12.DOWN_RIGHT_RIGHT:
		return VehicleDirection12.DOWN_RIGHT_DOWN;
	default:
		return VehicleDirection12.DOWN_LEFT_DOWN;
	}
}

DirectionUtils.toRailDirection = function(direction) {
	switch (direction) {
	case VehicleDirection12.HORIZONTAL_LEFT:
		return RailDirection.HORIZONTAL;
	case VehicleDirection12.HORIZONTAL_RIGHT:
		return RailDirection.HORIZONTAL;
	case VehicleDirection12.VERTICAL_UP:
		return RailDirection.VERTICAL;
	case VehicleDirection12.VERTICAL_DOWN:
		return RailDirection.VERTICAL;
	case VehicleDirection12.UP_LEFT_UP:
		return RailDirection.UP_LEFT;
	case VehicleDirection12.UP_LEFT_LEFT:
		return RailDirection.UP_LEFT;
	case VehicleDirection12.UP_RIGHT_UP:
		return RailDirection.UP_RIGHT;
	case VehicleDirection12.UP_RIGHT_RIGHT:
		return RailDirection.UP_RIGHT;
	case VehicleDirection12.DOWN_LEFT_DOWN:
		return RailDirection.DOWN_LEFT;
	case VehicleDirection12.DOWN_LEFT_LEFT:
		return RailDirection.DOWN_LEFT;
	case VehicleDirection12.DOWN_RIGHT_DOWN:
		return RailDirection.DOWN_RIGHT;
	case VehicleDirection12.DOWN_RIGHT_RIGHT:
		return RailDirection.DOWN_RIGHT;
	default:
		return RailDirection.DOWN_LEFT;
	}
}

DirectionUtils.toRailDirectionFlags = function(direction) {
	switch (direction) {
	case RailDirection.DOWN_LEFT:
		return 16;
	case RailDirection.DOWN_RIGHT:
		return 32;
	case RailDirection.HORIZONTAL:
		return 1;
	case RailDirection.UP_LEFT:
		return 4;
	case RailDirection.UP_RIGHT:
		return 8;
	case RailDirection.VERTICAL:
		return 2;
	default:
		return 0;
	}
}

DirectionUtils.toVehicleDirection12Flags = function(direction) {
	switch (direction) {
	case VehicleDirection12.HORIZONTAL_LEFT:
		return 1;
	case VehicleDirection12.HORIZONTAL_RIGHT:
		return 2;
	case VehicleDirection12.VERTICAL_UP:
		return 4;
	case VehicleDirection12.VERTICAL_DOWN:
		return 8;
	case VehicleDirection12.UP_LEFT_UP:
		return 16;
	case VehicleDirection12.UP_LEFT_LEFT:
		return 32;
	case VehicleDirection12.UP_RIGHT_UP:
		return 64;
	case VehicleDirection12.UP_RIGHT_RIGHT:
		return 128;
	case VehicleDirection12.DOWN_LEFT_DOWN:
		return 256;
	case VehicleDirection12.DOWN_LEFT_LEFT:
		return 512;
	case VehicleDirection12.DOWN_RIGHT_DOWN:
		return 1024;
	case VehicleDirection12.DOWN_RIGHT_RIGHT:
		return 2048;
	default:
		return 0;
	}
}

DirectionUtils.toVehicleDirection12Flags_ = function(directions, directionsCount) {
	var flags = 0;
	for (var i = 0; i < directionsCount; i++) {
		var d = directions[i];
		flags = flags | DirectionUtils.toVehicleDirection12Flags(d);
	}
	return flags;
}

function DisplayResolutionCi()
{
	this.bitsPerPixel = 0;
	this.height = 0;
	this.refreshRate = null;
	this.width = 0;
}

function Draw2dData()
{
	this.color = 0;
	this.height = null;
	this.inAtlasId = null;
	this.width = null;
	this.x1 = null;
	this.y1 = null;
}

function DrawModeEnum()
{
}
DrawModeEnum.LINES = 1;
DrawModeEnum.TRIANGLES = 0;

function DrawName()
{
	this.clientAutoComplete = false;
	this.drawHealth = false;
	this.health = null;
	this.name = null;
	this.onlyWhenSelected = false;
	this.textX = null;
	this.textY = null;
	this.textZ = null;
}

function DrawWireframeCube()
{
	this.one = null;
	this.wireframeCube = null;
	this.one = 1;
}

DrawWireframeCube.prototype.drawWireframeCube_ = function(game, posx, posy, posz, scalex, scaley, scalez) {
	game.platform.gLLineWidth(2);
	game.platform.bindTexture2d(0);
	if (this.wireframeCube == null) {
		var data = WireframeCube.get();
		this.wireframeCube = game.platform.createModel(data);
	}
	game.gLPushMatrix();
	game.gLTranslate(posx, posy, posz);
	var half = this.one / (2);
	game.gLScale(scalex * half, scaley * half, scalez * half);
	game.drawModel(this.wireframeCube);
	game.gLPopMatrix();
}

function IPEndPointCi()
{
}

function DummyIpEndPoint()
{
}
DummyIpEndPoint.prototype = new IPEndPointCi();

DummyIpEndPoint.prototype.addressToString = function() {
	return "127.0.0.1";
}

function NetClient()
{
}

function DummyNetClient()
{
	this.network = null;
	this.platform = null;
}
DummyNetClient.prototype = new NetClient();

DummyNetClient.prototype.connect = function(ip, port) {
	return new DummyNetConnectionCi();
}

DummyNetClient.prototype.readMessage = function() {
	var msg = null;
	this.platform.monitorEnter(this.network.clientReceiveBufferLock);
	{
		if (this.network.clientReceiveBuffer.count() > 0) {
			msg = new NetIncomingMessage();
			var b = this.network.clientReceiveBuffer.dequeue();
			msg.message = b.data;
			msg.messageLength = b.length;
		}
	}
	this.platform.monitorExit(this.network.clientReceiveBufferLock);
	return msg;
}

DummyNetClient.prototype.sendMessage = function(message, method) {
	this.platform.monitorEnter(this.network.serverReceiveBufferLock);
	{
		var msg = message;
		var b = new ByteArray();
		b.data = msg.message;
		b.length = msg.messageLength;
		this.network.serverReceiveBuffer.enqueue(b);
	}
	this.platform.monitorExit(this.network.serverReceiveBufferLock);
}

DummyNetClient.prototype.setNetwork = function(network_) {
	this.network = network_;
}

DummyNetClient.prototype.setPlatform = function(gamePlatform) {
	this.platform = gamePlatform;
}

DummyNetClient.prototype.start = function() {
}

function NetConnection()
{
}

function DummyNetConnectionCi()
{
	this.network = null;
	this.platform = null;
}
DummyNetConnectionCi.prototype = new NetConnection();

DummyNetConnectionCi.prototype.equalsConnection = function(connection) {
	return true;
}

DummyNetConnectionCi.prototype.remoteEndPoint = function() {
	return new DummyIpEndPoint();
}

DummyNetConnectionCi.prototype.sendMessage = function(msg, method, sequenceChannel) {
	this.platform.monitorEnter(this.network.clientReceiveBufferLock);
	{
		var msg2 = msg;
		var b = new ByteArray();
		b.data = msg2.message;
		b.length = msg2.messageLength;
		this.network.clientReceiveBuffer.enqueue(b);
	}
	this.platform.monitorExit(this.network.clientReceiveBufferLock);
}

DummyNetConnectionCi.prototype.update = function() {
}

function INetOutgoingMessage()
{
	this.message = null;
	this.messageLength = 0;
}

INetOutgoingMessage.prototype.write = function(source, sourceCount) {
	this.messageLength = sourceCount;
	this.message = new Uint8Array(new ArrayBuffer(sourceCount));
	for (var i = 0; i < sourceCount; i++) {
		this.message[i] = source[i];
	}
}

function DummyNetOutgoingMessage()
{
}
DummyNetOutgoingMessage.prototype = new INetOutgoingMessage();

function NetServer()
{
}

function DummyNetServer()
{
	this.connectedClient = null;
	this.network = null;
	this.platform = null;
	this.receivedAnyMessage = false;
	this.connectedClient = new DummyNetConnectionCi();
}
DummyNetServer.prototype = new NetServer();

DummyNetServer.prototype.readMessage = function() {
	this.connectedClient.network = this.network;
	this.connectedClient.platform = this.platform;
	var msg = null;
	this.platform.monitorEnter(this.network.serverReceiveBufferLock);
	{
		if (this.network.serverReceiveBuffer.count() > 0) {
			if (!this.receivedAnyMessage) {
				this.receivedAnyMessage = true;
				msg = new NetIncomingMessage();
				msg.type = NetworkMessageType.CONNECT;
				msg.senderConnection = this.connectedClient;
			}
			else {
				msg = new NetIncomingMessage();
				var b = this.network.serverReceiveBuffer.dequeue();
				msg.message = b.data;
				msg.messageLength = b.length;
				msg.senderConnection = this.connectedClient;
			}
		}
	}
	this.platform.monitorExit(this.network.serverReceiveBufferLock);
	return msg;
}

DummyNetServer.prototype.setNetwork = function(dummyNetwork) {
	this.network = dummyNetwork;
}

DummyNetServer.prototype.setPlatform = function(gamePlatform) {
	this.platform = gamePlatform;
}

DummyNetServer.prototype.setPort = function(port) {
}

DummyNetServer.prototype.start = function() {
}

function DummyNetwork()
{
	this.clientReceiveBuffer = null;
	this.clientReceiveBufferLock = null;
	this.serverReceiveBuffer = null;
	this.serverReceiveBufferLock = null;
	this.clear();
}

DummyNetwork.prototype.clear = function() {
	this.serverReceiveBuffer = new QueueByteArray();
	this.clientReceiveBuffer = new QueueByteArray();
}

DummyNetwork.prototype.start = function(lock1, lock2) {
	this.serverReceiveBufferLock = lock1;
	this.clientReceiveBufferLock = lock2;
}

function EnetEvent()
{
}

function EnetEventRef()
{
	this.e = null;
}

EnetEventRef.prototype.getEvent = function() {
	return this.e;
}

EnetEventRef.prototype.setEvent = function(value_) {
	this.e = value_;
}

var EnetEventType = {
	NONE : 0,
	CONNECT : 1,
	DISCONNECT : 2,
	RECEIVE : 3
}

function EnetHost()
{
}

function EnetNetClient()
{
	this.connected = false;
	this.connected2 = false;
	this.host = null;
	this.messages = null;
	this.peer = null;
	this.platform = null;
	this.tosend = null;
}
EnetNetClient.prototype = new NetClient();

EnetNetClient.prototype.connect = function(ip, port) {
	this.peer = this.platform.enetHostConnect(this.host, ip, port, 1234, 200);
	this.connected = true;
	return null;
}

EnetNetClient.prototype.doSendPacket = function(msg) {
	var msg1 = msg;
	this.platform.enetPeerSend(this.peer, 0, msg1.message, msg1.messageLength, 1);
}

EnetNetClient.prototype.readMessage = function() {
	if (!this.connected) {
		return null;
	}
	if (this.messages.count() > 0) {
		return this.messages.dequeue();
	}
	if (this.connected2) {
		while (this.tosend.count() > 0) {
			var msg = this.tosend.dequeue();
			this.doSendPacket(msg);
		}
	}
	var event_ = new EnetEventRef();
	if (this.platform.enetHostService(this.host, 0, event_)) {
		do {
			switch (event_.e.type()) {
			case EnetEventType.CONNECT:
				this.connected2 = true;
				break;
			case EnetEventType.RECEIVE:
				var data = event_.e.packet().getBytes();
				var dataLength = event_.e.packet().getBytesCount();
				event_.e.packet().dispose();
				var msg = new NetIncomingMessage();
				msg.message = data;
				msg.messageLength = dataLength;
				this.messages.enqueue(msg);
				break;
			}
		}
		while (this.platform.enetHostCheckEvents(this.host, event_));
	}
	if (this.messages.count() > 0) {
		return this.messages.dequeue();
	}
	return null;
}

EnetNetClient.prototype.sendMessage = function(message, method) {
	var msg = message;
	if (!this.connected2) {
		this.tosend.enqueue(msg);
		return;
	}
	this.doSendPacket(msg);
}

EnetNetClient.prototype.setPlatform = function(platform_) {
	this.platform = platform_;
}

EnetNetClient.prototype.start = function() {
	this.host = this.platform.enetCreateHost();
	this.platform.enetHostInitialize(this.host, null, 1, 0, 0, 0);
	this.tosend = new QueueINetOutgoingMessage();
	this.messages = new QueueNetIncomingMessage();
}

function EnetPacket()
{
}

function EnetPacketFlags()
{
}
EnetPacketFlags.NO_ALLOCATE = 4;
EnetPacketFlags.NONE = 0;
EnetPacketFlags.RELIABLE = 1;
EnetPacketFlags.UNRELIABLE_FRAGMENT = 8;
EnetPacketFlags.UNSEQUENCED = 2;

function EnetPeer()
{
}

function Entity()
{
	this.bullet = null;
	this.drawArea = null;
	this.drawModel = null;
	this.drawName = null;
	this.drawText = null;
	this.expires = null;
	this.grenade = null;
	this.minecart = null;
	this.networkPosition = null;
	this.playerDrawInfo = null;
	this.playerStats = null;
	this.position = null;
	this.push = null;
	this.scripts = null;
	this.scriptsCount = 0;
	this.sprite = null;
	this.usable = false;
	this.scripts = new Array(8);
	this.scriptsCount = 0;
}

function EntityDrawArea()
{
	this.sizex = 0;
	this.sizey = 0;
	this.sizez = 0;
	this.visible = false;
	this.x = 0;
	this.y = 0;
	this.z = 0;
}

function EntityDrawModel()
{
	this.currentTexture = 0;
	this.downloadSkin = false;
	this.modelHeight = null;
	this.model_ = null;
	this.skinDownloadResponse = null;
	this.texture_ = null;
	this.eyeHeight = null;
	this.renderer = null;
	this.currentTexture = -1;
}

function EntityDrawText()
{
	this.dx = null;
	this.dy = null;
	this.dz = null;
	this.rotx = null;
	this.roty = null;
	this.rotz = null;
	this.text = null;
}

function EntityPosition_()
{
	this.lastUpdateMilliseconds = 0;
	this.positionLoaded = false;
	this.rotx = null;
	this.roty = null;
	this.rotz = null;
	this.x = null;
	this.y = null;
	this.z = null;
}

function EntityScript()
{
}

EntityScript.prototype.onNewFrameFixed = function(game, entity, dt) {
}

var EscapeMenuState = {
	MAIN : 0,
	OPTIONS : 1,
	GRAPHICS : 2,
	KEYS : 3,
	OTHER : 4
}

function Expires()
{
	this.timeLeft = null;
	this.totalTime = null;
}

Expires.create = function(p) {
	var expires = new Expires();
	expires.totalTime = p;
	expires.timeLeft = p;
	return expires;
}

function FastQueueInt()
{
	this.count = 0;
	this.end = 0;
	this.maxCount = 0;
	this.start = 0;
	this.values = null;
}

FastQueueInt.prototype.clear = function() {
	this.count = 0;
}

FastQueueInt.prototype.initialize = function(maxCount) {
	this.maxCount = maxCount;
	this.values = new Int32Array(new ArrayBuffer(maxCount << 2));
	this.count = 0;
	this.start = 0;
	this.end = 0;
}

FastQueueInt.prototype.pop = function() {
	var value = this.values[this.start];
	this.count--;
	this.start++;
	if (this.start >= this.maxCount) {
		this.start = 0;
	}
	return value;
}

FastQueueInt.prototype.push = function(value) {
	this.values[this.end] = value;
	this.count++;
	this.end++;
	if (this.end >= this.maxCount) {
		this.end = 0;
	}
}

function FastStackInt()
{
	this.count = 0;
	this.values = null;
	this.valuesLength = 0;
}

FastStackInt.prototype.clear = function() {
	this.count = 0;
}

FastStackInt.prototype.count_ = function() {
	return this.count;
}

FastStackInt.prototype.initialize = function(maxCount) {
	this.valuesLength = maxCount;
	this.values = new Int32Array(new ArrayBuffer(maxCount << 2));
}

FastStackInt.prototype.pop = function() {
	this.count--;
	return this.values[this.count];
}

FastStackInt.prototype.push = function(value) {
	while (this.count >= this.valuesLength) {
		var values2 = new Int32Array(new ArrayBuffer(this.valuesLength * 2 << 2));
		for (var i = 0; i < this.valuesLength; i++) {
			values2[i] = this.values[i];
		}
		this.values = values2;
		this.valuesLength = this.valuesLength * 2;
	}
	this.values[this.count] = value;
	this.count++;
}

function FloatRef()
{
	this.value = null;
}

FloatRef.create = function(value_) {
	var f = new FloatRef();
	f.value = value_;
	return f;
}

FloatRef.prototype.getValue = function() {
	return this.value;
}

FloatRef.prototype.setValue = function(value_) {
	this.value = value_;
}

function FontCi()
{
	this.family = null;
	this.size = null;
	this.style = 0;
	this.family = "Arial";
	this.size = 12;
	this.style = 0;
}

FontCi.create = function(family_, size_, style_) {
	var f = new FontCi();
	f.family = family_;
	f.size = size_;
	f.style = style_;
	return f;
}

FontCi.prototype.getFontFamily = function() {
	return this.family;
}

FontCi.prototype.getFontSize = function() {
	return this.size;
}

FontCi.prototype.getFontStyle = function() {
	return this.style;
}

var FontType = {
	NICE : 0,
	SIMPLE : 1,
	BLACK_BACKGROUND : 2,
	DEFAULT : 3
}

function FreemoveLevelEnum()
{
}
FreemoveLevelEnum.FREEMOVE = 1;
FreemoveLevelEnum.NOCLIP = 2;
FreemoveLevelEnum.NONE = 0;

function FrustumCulling()
{
	this.d_GetCameraMatrix = null;
	this.frustum00 = null;
	this.frustum01 = null;
	this.frustum02 = null;
	this.frustum03 = null;
	this.frustum10 = null;
	this.frustum11 = null;
	this.frustum12 = null;
	this.frustum13 = null;
	this.frustum20 = null;
	this.frustum21 = null;
	this.frustum22 = null;
	this.frustum23 = null;
	this.frustum30 = null;
	this.frustum31 = null;
	this.frustum32 = null;
	this.frustum33 = null;
	this.frustum40 = null;
	this.frustum41 = null;
	this.frustum42 = null;
	this.frustum43 = null;
	this.frustum50 = null;
	this.frustum51 = null;
	this.frustum52 = null;
	this.frustum53 = null;
	this.platform = null;
}

FrustumCulling.prototype.calcFrustumEquations = function() {
	var t;
	var matModelView = this.d_GetCameraMatrix.getModelViewMatrix();
	var matProjection = this.d_GetCameraMatrix.getProjectionMatrix();
	var matFrustum = Mat4.create();
	Mat4.multiply(matFrustum, matProjection, matModelView);
	{
		var clip1 = matFrustum;
		{
			this.frustum00 = clip1[3] - clip1[0];
			this.frustum01 = clip1[7] - clip1[4];
			this.frustum02 = clip1[11] - clip1[8];
			this.frustum03 = clip1[15] - clip1[12];
			t = this.platform.mathSqrt(this.frustum00 * this.frustum00 + this.frustum01 * this.frustum01 + this.frustum02 * this.frustum02);
			this.frustum00 /= t;
			this.frustum01 /= t;
			this.frustum02 /= t;
			this.frustum03 /= t;
			this.frustum10 = clip1[3] + clip1[0];
			this.frustum11 = clip1[7] + clip1[4];
			this.frustum12 = clip1[11] + clip1[8];
			this.frustum13 = clip1[15] + clip1[12];
			t = this.platform.mathSqrt(this.frustum10 * this.frustum10 + this.frustum11 * this.frustum11 + this.frustum12 * this.frustum12);
			this.frustum10 /= t;
			this.frustum11 /= t;
			this.frustum12 /= t;
			this.frustum13 /= t;
			this.frustum20 = clip1[3] + clip1[1];
			this.frustum21 = clip1[7] + clip1[5];
			this.frustum22 = clip1[11] + clip1[9];
			this.frustum23 = clip1[15] + clip1[13];
			t = this.platform.mathSqrt(this.frustum20 * this.frustum20 + this.frustum21 * this.frustum21 + this.frustum22 * this.frustum22);
			this.frustum20 /= t;
			this.frustum21 /= t;
			this.frustum22 /= t;
			this.frustum23 /= t;
			this.frustum30 = clip1[3] - clip1[1];
			this.frustum31 = clip1[7] - clip1[5];
			this.frustum32 = clip1[11] - clip1[9];
			this.frustum33 = clip1[15] - clip1[13];
			t = this.platform.mathSqrt(this.frustum30 * this.frustum30 + this.frustum31 * this.frustum31 + this.frustum32 * this.frustum32);
			this.frustum30 /= t;
			this.frustum31 /= t;
			this.frustum32 /= t;
			this.frustum33 /= t;
			this.frustum40 = clip1[3] - clip1[2];
			this.frustum41 = clip1[7] - clip1[6];
			this.frustum42 = clip1[11] - clip1[10];
			this.frustum43 = clip1[15] - clip1[14];
			t = this.platform.mathSqrt(this.frustum40 * this.frustum40 + this.frustum41 * this.frustum41 + this.frustum42 * this.frustum42);
			this.frustum40 /= t;
			this.frustum41 /= t;
			this.frustum42 /= t;
			this.frustum43 /= t;
			this.frustum50 = clip1[3] + clip1[2];
			this.frustum51 = clip1[7] + clip1[6];
			this.frustum52 = clip1[11] + clip1[10];
			this.frustum53 = clip1[15] + clip1[14];
			t = this.platform.mathSqrt(this.frustum50 * this.frustum50 + this.frustum51 * this.frustum51 + this.frustum52 * this.frustum52);
			this.frustum50 /= t;
			this.frustum51 /= t;
			this.frustum52 /= t;
			this.frustum53 /= t;
		}
	}
}

FrustumCulling.prototype.sphereInFrustum = function(x, y, z, radius) {
	var d = 0;
	d = this.frustum00 * x + this.frustum01 * y + this.frustum02 * z + this.frustum03;
	if (d <= -radius)
		return false;
	d = this.frustum10 * x + this.frustum11 * y + this.frustum12 * z + this.frustum13;
	if (d <= -radius)
		return false;
	d = this.frustum20 * x + this.frustum21 * y + this.frustum22 * z + this.frustum23;
	if (d <= -radius)
		return false;
	d = this.frustum30 * x + this.frustum31 * y + this.frustum32 * z + this.frustum33;
	if (d <= -radius)
		return false;
	d = this.frustum40 * x + this.frustum41 * y + this.frustum42 * z + this.frustum43;
	if (d <= -radius)
		return false;
	d = this.frustum50 * x + this.frustum51 * y + this.frustum52 * z + this.frustum53;
	if (d <= -radius)
		return false;
	return true;
}

function Game()
{
	this.activeMaterial = 0;
	this.allowFreemove = false;
	this.allowedFonts = null;
	this.allowedFontsCount = 0;
	this.audioEnabled = false;
	this.autoJumpEnabled = false;
	this.cameraEyeX = null;
	this.cameraEyeY = null;
	this.cameraEyeZ = null;
	this.cameraMatrix = null;
	this.chatLineLength = 0;
	this.chatLines = null;
	this.chatLinesCount = 0;
	this.chatLinesMax = 0;
	this.eNABLE_DRAW2D = false;
	this.eNABLE_DRAW_TEST_CHARACTER = false;
	this.eNABLE_LAG = 0;
	this.eNABLE_TPP_VIEW = false;
	this.eNABLE_ZFAR = false;
	this.follow = null;
	this.font = 0;
	this.gLRotateTempVec3 = null;
	this.gLScaleTempVec3 = null;
	this.gLTranslateTempVec3 = null;
	this.guiTyping = TypingState.NONE;
	this.guiTypingBuffer = null;
	this.ironSights = false;
	this.isShiftPressed = false;
	this.isTeamchat = false;
	this.isTyping = false;
	this.lastReceivedMilliseconds = 0;
	this.loadedAmmo = null;
	this.localPlayerId = 0;
	this.newBlockTypes = null;
	this.nightLevels = null;
	this.pICK_DISTANCE = null;
	this.playerPushDistance = null;
	this.playerStats = null;
	this.radiusWhenMoving = null;
	this.receivedMapLength = 0;
	this.selectedBlockPositionX = 0;
	this.selectedBlockPositionY = 0;
	this.selectedBlockPositionZ = 0;
	this.selectedEntityId = 0;
	this.serverInfo = null;
	this.set3dProjectionTempMat4 = null;
	this.skySphereNight = false;
	this.tPP_CAMERA_DISTANCE_MAX = 0;
	this.tPP_CAMERA_DISTANCE_MIN = 0;
	this.textureId = null;
	this.textureIdForInventory = null;
	this.totalAmmo = null;
	this.a = null;
	this.accumulator = null;
	this.ammostarted = false;
	this.assets = null;
	this.assetsLoadProgress = null;
	this.audio = null;
	this.basemovespeed = null;
	this.blobdownload = null;
	this.blobdownloadmd5 = null;
	this.blobdownloadname = null;
	this.blockHealth = null;
	this.blocktypes = null;
	this.cachedTextTextures = null;
	this.cachedTextTexturesMax = 0;
	this.camera = null;
	this.cameratype = CameraType.FPP;
	this.circleModelData = null;
	this.clientmods = null;
	this.clientmodsCount = 0;
	this.commitActions = null;
	this.connectdata = null;
	this.constRotationSpeed = null;
	this.constWallDistance = null;
	this.controls = null;
	this.currentAttackedBlock = null;
	this.currentMatrixModeProjection = false;
	this.currentTimeMilliseconds = 0;
	this.currentlyAttackedEntity = 0;
	this.d_Batcher = null;
	this.d_Config3d = null;
	this.d_Data = null;
	this.d_DataMonsters = null;
	this.d_FrustumCulling = null;
	this.d_Heightmap = null;
	this.d_Inventory = null;
	this.d_InventoryUtil = null;
	this.d_SunMoonRenderer = null;
	this.d_TerrainChunkTesselator = null;
	this.d_TerrainTextures = null;
	this.d_TextureAtlasConverter = null;
	this.dialogs = null;
	this.dialogsCount = 0;
	this.drawblockinfo = false;
	this.enableCameraControl = false;
	this.enable_move = false;
	this.entities = null;
	this.entitiesCount = 0;
	this.escapeMenuRestart = false;
	this.exitToMainMenu = false;
	this.fancySkysphere = false;
	this.fillAreaLimit = 0;
	this.fontMapLoading = null;
	this.fov = null;
	this.getAsset = null;
	this.grenadecookingstartMilliseconds = 0;
	this.grenadetime = null;
	this.guistate = GuiState.NORMAL;
	this.handRedraw = false;
	this.handSetAttackBuild = false;
	this.handSetAttackDestroy = false;
	this.handTexture = 0;
	this.identityMatrix = null;
	this.invalidVersionDrawMessage = null;
	this.invalidVersionPacketIdentification = null;
	this.isNight = false;
	this.isplayeronground = false;
	this.issingleplayer = false;
	this.keyboardState = null;
	this.keyboardStateRaw = null;
	this.language = null;
	this.lastHeight = 0;
	this.lastOxygenTickMilliseconds = 0;
	this.lastWidth = 0;
	this.lastironsightschangeMilliseconds = 0;
	this.lastplacedblockX = 0;
	this.lastplacedblockY = 0;
	this.lastplacedblockZ = 0;
	this.lastplayerpositionX = null;
	this.lastplayerpositionY = null;
	this.lastplayerpositionZ = null;
	this.lastpositionsentMilliseconds = 0;
	this.leftpressedpicking = false;
	this.localplayeranim = null;
	this.localplayeranimationhint = null;
	this.localstance = 0;
	this.mLightLevels = null;
	this.main = null;
	this.map = null;
	this.maploadingprogress = null;
	this.materialSlots = null;
	this.maxTextureSize = 0;
	this.maxdrawdistance = 0;
	this.menustate = null;
	this.modelViewInverted = null;
	this.modmanager = null;
	this.moonPositionX = null;
	this.moonPositionY = null;
	this.moonPositionZ = null;
	this.mouseCurrentX = 0;
	this.mouseCurrentY = 0;
	this.mouseDeltaX = null;
	this.mouseDeltaY = null;
	this.mouseLeft = false;
	this.mouseMiddle = false;
	this.mousePointerLockShouldBe = false;
	this.mouseRight = false;
	this.mouseSmoothing = false;
	this.mouseSmoothingAccum = null;
	this.mouseSmoothingVelX = null;
	this.mouseSmoothingVelY = null;
	this.mouseleftclick = false;
	this.mouseleftdeclick = false;
	this.mouserightclick = false;
	this.mouserightdeclick = false;
	this.movedz = null;
	this.movespeed = null;
	this.mvMatrix = null;
	this.one = null;
	this.options = null;
	this.overheadcamera = false;
	this.overheadcameraK = null;
	this.overheadcameradistance = null;
	this.pMatrix = null;
	this.packetHandlers = null;
	this.packetLen = null;
	this.particleEffectBlockBreak = null;
	this.performanceinfo = null;
	this.pistolcycle = 0;
	this.platform = null;
	this.player = null;
	this.playerPositionSpawnX = null;
	this.playerPositionSpawnY = null;
	this.playerPositionSpawnZ = null;
	this.playerdestination = null;
	this.playertexturedefault = 0;
	this.playervelocity = null;
	this.pushX = null;
	this.pushY = null;
	this.pushZ = null;
	this.quadModel = null;
	this.reachedHalfBlock = false;
	this.reachedwall = false;
	this.reachedwall_1blockhigh = false;
	this.reconnect = false;
	this.redirectTo = null;
	this.reloadblock = 0;
	this.reloadstartMilliseconds = 0;
	this.rnd = null;
	this.rotationspeed = null;
	this.s = null;
	this.selectedmodelid = 0;
	this.sendResize = false;
	this.serverGameVersion = null;
	this.shadowssimple = false;
	this.shouldRedrawAllBlocks = false;
	this.soundnow = null;
	this.spawned = false;
	this.speculative = null;
	this.speculativeCount = 0;
	this.startedconnecting = false;
	this.stopPlayerMove = false;
	this.sunPositionX = null;
	this.sunPositionY = null;
	this.sunPositionZ = null;
	this.sunlight_ = 0;
	this.taskScheduler = null;
	this.terrainTexture = 0;
	this.terrainTextures1d = null;
	this.terrainTexturesPerAtlas = 0;
	this.textColorRenderer = null;
	this.textures = null;
	this.totaltimeMilliseconds = 0;
	this.touchMoveDx = null;
	this.touchMoveDy = null;
	this.touchOrientationDx = null;
	this.touchOrientationDy = null;
	this.tppcameradistance = null;
	this.typinglog = null;
	this.typinglogCount = 0;
	this.typinglogpos = 0;
	this.wasmouseleft = false;
	this.wasmouseright = false;
	this.whitetexture = 0;
	this.znear = null;
	this.one = 1;
	this.map = new Map();
	this.performanceinfo = new DictionaryStringString();
	this.audioEnabled = true;
	this.autoJumpEnabled = false;
	this.playerPositionSpawnX = 15 + this.one / (2);
	this.playerPositionSpawnY = 64;
	this.playerPositionSpawnZ = 15 + this.one / (2);
	this.textureId = new Array(1024);
	for (var i = 0; i < 1024; i++) {
		this.textureId[i] = new Int32Array(new ArrayBuffer(6 << 2));
	}
	this.textureIdForInventory = new Int32Array(new ArrayBuffer(1024 << 2));
	this.language = new LanguageCi();
	this.lastplacedblockX = -1;
	this.lastplacedblockY = -1;
	this.lastplacedblockZ = -1;
	this.mLightLevels = new Float32Array(new ArrayBuffer(16 << 2));
	this.sunlight_ = 15;
	this.mvMatrix = new StackMatrix4();
	this.pMatrix = new StackMatrix4();
	this.mvMatrix.push(Mat4.create());
	this.pMatrix.push(Mat4.create());
	this.whitetexture = -1;
	this.cachedTextTexturesMax = 1024;
	this.cachedTextTextures = new Array(this.cachedTextTexturesMax);
	for (var i = 0; i < this.cachedTextTexturesMax; i++) {
		this.cachedTextTextures[i] = null;
	}
	this.packetLen = new IntRef();
	this.eNABLE_DRAW2D = true;
	this.allowFreemove = true;
	this.enableCameraControl = true;
	this.textures = new DictionaryStringInt1024();
	this.serverInfo = new ServerInformation();
	this.menustate = new MenuState();
	this.mouseleftclick = false;
	this.mouseleftdeclick = false;
	this.wasmouseleft = false;
	this.mouserightclick = false;
	this.mouserightdeclick = false;
	this.wasmouseright = false;
	this.eNABLE_LAG = 0;
	this.znear = this.one / (10);
	this.cameraMatrix = new GetCameraMatrix();
	this.eNABLE_ZFAR = true;
	this.totalAmmo = new Int32Array(new ArrayBuffer(1024 << 2));
	this.loadedAmmo = new Int32Array(new ArrayBuffer(1024 << 2));
	this.allowedFontsCount = 2;
	this.allowedFonts = new Array(this.allowedFontsCount);
	this.allowedFonts[0] = "Verdana";
	this.allowedFonts[1] = "Courier New";
	this.fov = Game.getPi() / (3);
	this.cameratype = CameraType.FPP;
	this.eNABLE_TPP_VIEW = false;
	this.basemovespeed = 5;
	this.movespeed = 5;
	this.radiusWhenMoving = (this.one * 3) / (10);
	this.playervelocity = new Vector3Ref();
	this.localPlayerId = -1;
	this.dialogs = new Array(512);
	this.dialogsCount = 512;
	this.blockHealth = new DictionaryVector3Float();
	this.playertexturedefault = -1;
	this.a = new AnimationState();
	this.constRotationSpeed = (this.one * 180) / (20);
	this.modmanager = new ClientModManager1();
	this.particleEffectBlockBreak = new ModDrawParticleEffectBlockBreak();
	this.pICK_DISTANCE = 4.1;
	this.selectedmodelid = -1;
	this.grenadetime = 3;
	this.rotationspeed = (this.one * 15) / (100);
	this.entities = new Array(4096);
	for (var i = 0; i < 4096; i++) {
		this.entities[i] = null;
	}
	this.entitiesCount = 512;
	this.playerPushDistance = 2;
	this.keyboardState = new Array(256);
	for (var i = 0; i < 256; i++) {
		this.keyboardState[i] = false;
	}
	this.keyboardStateRaw = new Array(256);
	for (var i = 0; i < 256; i++) {
		this.keyboardStateRaw[i] = false;
	}
	this.overheadcameradistance = 10;
	this.tppcameradistance = 3;
	this.tPP_CAMERA_DISTANCE_MIN = 1;
	this.tPP_CAMERA_DISTANCE_MAX = 10;
	this.options = new OptionsCi();
	this.overheadcameraK = new Kamera();
	this.fillAreaLimit = 200;
	this.speculativeCount = 0;
	this.speculative = new Array(8192);
	this.typinglog = new Array(16384);
	this.typinglogCount = 0;
	this.newBlockTypes = new Array(1024);
	this.localplayeranim = new AnimationState();
	this.localplayeranimationhint = new AnimationHint();
	this.enable_move = true;
	this.handTexture = -1;
	this.modelViewInverted = new Float32Array(new ArrayBuffer(16 << 2));
	this.gLScaleTempVec3 = Vec3.create();
	this.gLRotateTempVec3 = Vec3.create();
	this.gLTranslateTempVec3 = Vec3.create();
	this.identityMatrix = Mat4.identity_(Mat4.create());
	this.set3dProjectionTempMat4 = Mat4.create();
	this.getAsset = new Array(2048);
	this.playerStats = new Packet_ServerPlayerStats();
	this.mLightLevels = new Float32Array(new ArrayBuffer(16 << 2));
	for (var i = 0; i < 16; i++) {
		this.mLightLevels[i] = (this.one * i) / (15);
	}
	this.soundnow = new BoolRef();
	this.camera = Mat4.create();
	this.packetHandlers = new Array(256);
	this.player = new Entity();
	this.player.position = new EntityPosition_();
	this.currentlyAttackedEntity = -1;
	this.chatLinesMax = 1;
	this.chatLines = new Array(this.chatLinesMax);
	this.chatLineLength = 64;
	this.audio = new AudioControl();
	this.cameraEyeX = -1;
	this.cameraEyeY = -1;
	this.cameraEyeZ = -1;
	this.controls = new Controls();
	this.movedz = 0;
	this.taskScheduler = new TaskScheduler();
	this.commitActions = ListAction.create(16384);
	this.constWallDistance = 0.3;
	this.mouseSmoothing = true;
}

Game.prototype.addChatline = function(s) {
	var game = this;
	if (game.platform.stringEmpty(s)) {
		return;
	}
	var containsLink = false;
	var linkTarget = "";
	if (game.platform.stringContains(s, "http://")) {
		containsLink = true;
		var r = new IntRef();
		var temp = game.platform.stringSplit(s, " ", r);
		for (var i = 0; i < r.value; i++) {
			if (game.platform.stringIndexOf(temp[i], "http://") != -1) {
				linkTarget = temp[i];
				break;
			}
		}
	}
	if (game.platform.stringContains(s, "https://")) {
		containsLink = true;
		var r = new IntRef();
		var temp = game.platform.stringSplit(s, " ", r);
		for (var i = 0; i < r.value; i++) {
			if (game.platform.stringIndexOf(temp[i], "https://") != -1) {
				linkTarget = temp[i];
				break;
			}
		}
	}
	var now = game.platform.timeMillisecondsFromStart();
	if (s.length > this.chatLineLength) {
		for (var i = 0; i <= Math.floor(s.length / this.chatLineLength); i++) {
			var displayLength = this.chatLineLength;
			if (s.length - i * this.chatLineLength < this.chatLineLength) {
				displayLength = s.length - i * this.chatLineLength;
			}
			if (containsLink)
				this.chatLinesAdd(Chatline.createClickable(StringTools.stringSubstring(game.platform, s, i * this.chatLineLength, displayLength), now, linkTarget));
			else
				this.chatLinesAdd(Chatline.create(StringTools.stringSubstring(game.platform, s, i * this.chatLineLength, displayLength), now));
		}
	}
	else {
		if (containsLink)
			this.chatLinesAdd(Chatline.createClickable(s, now, linkTarget));
		else
			this.chatLinesAdd(Chatline.create(s, now));
	}
}

Game.prototype.addMod = function(mod) {
	this.clientmods[this.clientmodsCount++] = mod;
	mod.start(this.modmanager);
}

Game.prototype.addSpeculative = function(s_) {
	for (var i = 0; i < this.speculativeCount; i++) {
		if (this.speculative[i] == null) {
			this.speculative[i] = s_;
			return;
		}
	}
	this.speculative[this.speculativeCount++] = s_;
}

Game.angle256ToRad = function(value) {
	var one_ = 1;
	return (one_ * value) / (255) * Game.getPi() * 2;
}

Game.prototype.applyDamageToPlayer = function(damage, damageSource, sourceId) {
	this.playerStats.currentHealth -= damage;
	if (this.playerStats.currentHealth <= 0) {
		this.playerStats.currentHealth = 0;
		this.audioPlay("death.wav");
		this.sendPacketClient(ClientPackets.death(damageSource, sourceId));
	}
	else {
		this.audioPlay(this.rnd.next() % 2 == 0 ? "grunt1.wav" : "grunt2.wav");
	}
	this.sendPacketClient(ClientPackets.health(this.playerStats.currentHealth));
}

Game.prototype.audioPlay = function(file) {
	if (!this.audioEnabled) {
		return;
	}
	this.audioPlayAt(file, this.eyesPosX(), this.eyesPosY(), this.eyesPosZ());
}

Game.prototype.audioPlayAt = function(file, x, y, z) {
	if (file == null) {
		return;
	}
	if (!this.audioEnabled) {
		return;
	}
	if (this.assetsLoadProgress.value != 1) {
		return;
	}
	var file_ = this.platform.stringReplace(file, ".wav", ".ogg");
	if (this.getFileLength(file_) == 0) {
		this.platform.consoleWriteLine(this.platform.stringFormat("File not found: {0}", file));
		return;
	}
	var s = new Sound_();
	s.name = file_;
	s.x = x;
	s.y = y;
	s.z = z;
	this.audio.add(s);
}

Game.prototype.audioPlayLoop = function(file, play, restart) {
	if (!this.audioEnabled && play) {
		return;
	}
	if (this.assetsLoadProgress.value != 1) {
		return;
	}
	var file_ = this.platform.stringReplace(file, ".wav", ".ogg");
	if (this.getFileLength(file_) == 0) {
		this.platform.consoleWriteLine(this.platform.stringFormat("File not found: {0}", file));
		return;
	}
	if (play) {
		var s = null;
		var alreadyPlaying = false;
		for (var i = 0; i < this.audio.soundsCount; i++) {
			if (this.audio.sounds[i] == null) {
				continue;
			}
			if (this.audio.sounds[i].name == file_) {
				alreadyPlaying = true;
				s = this.audio.sounds[i];
			}
		}
		if (!alreadyPlaying) {
			s = new Sound_();
			s.name = file_;
			s.loop = true;
			this.audio.add(s);
		}
		s.x = this.eyesPosX();
		s.y = this.eyesPosY();
		s.z = this.eyesPosZ();
	}
	else {
		for (var i = 0; i < this.audio.soundsCount; i++) {
			if (this.audio.sounds[i] == null) {
				continue;
			}
			if (this.audio.sounds[i].name == file_) {
				this.audio.sounds[i].stop = true;
			}
		}
	}
}

Game.prototype.blockInHand = function() {
	var item = this.d_Inventory.rightHand[this.activeMaterial];
	if (item != null && item.itemClass == 0) {
		return IntRef.create(item.blockId);
	}
	return null;
}

Game.prototype.blockUnderPlayer = function() {
	if (!this.map.isValidPos(this.platform.floatToInt(this.player.position.x), this.platform.floatToInt(this.player.position.z), this.platform.floatToInt(this.player.position.y) - 1)) {
		return -1;
	}
	var blockunderplayer = this.map.getBlock(this.platform.floatToInt(this.player.position.x), this.platform.floatToInt(this.player.position.z), this.platform.floatToInt(this.player.position.y) - 1);
	return blockunderplayer;
}

Game.prototype.boolCommandArgument = function(arguments) {
	arguments = this.platform.stringTrim(arguments);
	return arguments == "" || arguments == "1" || arguments == "on" || arguments == "yes";
}

Game.byteArrayToUshortArray = function(input, inputLength) {
	var outputLength = Math.floor(inputLength / 2);
	var output = new Int32Array(new ArrayBuffer(outputLength << 2));
	for (var i = 0; i < outputLength; i++) {
		output[i] = (input[i * 2 + 1] << 8) + input[i * 2];
	}
	return output;
}

Game.prototype.cacheAsset = function(asset) {
	if (asset.md5 == null) {
		return;
	}
	if (!this.platform.isChecksum(asset.md5)) {
		return;
	}
	if (!this.platform.isCached(asset.md5)) {
		this.platform.saveAssetToCache(asset);
	}
}

Game.prototype.cameraChange = function() {
	if (this.follow != null) {
		return;
	}
	if (this.cameratype == CameraType.FPP) {
		this.cameratype = CameraType.TPP;
		this.eNABLE_TPP_VIEW = true;
	}
	else if (this.cameratype == CameraType.TPP) {
		this.cameratype = CameraType.OVERHEAD;
		this.overheadcamera = true;
		this.setFreeMouse(true);
		this.eNABLE_TPP_VIEW = true;
		this.playerdestination = Vector3Ref.create(this.player.position.x, this.player.position.y, this.player.position.z);
	}
	else if (this.cameratype == CameraType.OVERHEAD) {
		this.cameratype = CameraType.FPP;
		this.setFreeMouse(false);
		this.eNABLE_TPP_VIEW = false;
		this.overheadcamera = false;
	}
	else {
		this.platform.throwException("");
	}
}

Game.prototype.charToString = function(c) {
	var arr = new Int32Array(new ArrayBuffer(1 << 2));
	arr[0] = c;
	return this.platform.charArrayToString(arr, 1);
}
Game.CHAT_FONT_SIZE = 11;

Game.prototype.chatLinesAdd = function(chatline) {
	if (this.chatLinesCount >= this.chatLinesMax) {
		var lines2 = new Array(this.chatLinesMax * 2);
		for (var i = 0; i < this.chatLinesMax; i++) {
			lines2[i] = this.chatLines[i];
		}
		this.chatLines = lines2;
		this.chatLinesMax *= 2;
	}
	this.chatLines[this.chatLinesCount++] = chatline;
}

Game.prototype.chatLog = function(p) {
	if (!this.platform.chatLog(this.serverInfo.serverName, p)) {
		this.platform.consoleWriteLine(this.platform.stringFormat(this.language.cannotWriteChatLog(), this.serverInfo.serverName));
	}
}

Game.prototype.circle3i = function(x, y, radius) {
	var angle;
	this.gLPushMatrix();
	this.gLLoadIdentity();
	var n = 32;
	if (this.circleModelData == null) {
		this.circleModelData = new ModelData();
		this.circleModelData.setMode(1);
		this.circleModelData.indices = new Int32Array(new ArrayBuffer(n * 2 << 2));
		this.circleModelData.xyz = new Float32Array(new ArrayBuffer(3 * n << 2));
		this.circleModelData.rgba = new Uint8Array(new ArrayBuffer(4 * n));
		this.circleModelData.uv = new Float32Array(new ArrayBuffer(2 * n << 2));
		this.circleModelData.indicesCount = n * 2;
		this.circleModelData.verticesCount = n;
	}
	for (var i = 0; i < n; i++) {
		this.circleModelData.indices[i * 2] = i;
		this.circleModelData.indices[i * 2 + 1] = (i + 1) % n;
	}
	for (var i = 0; i < n; i++) {
		angle = (i * 2 * Game.getPi()) / (n);
		this.circleModelData.xyz[i * 3 + 0] = x + this.platform.mathCos(angle) * radius;
		this.circleModelData.xyz[i * 3 + 1] = y + this.platform.mathSin(angle) * radius;
		this.circleModelData.xyz[i * 3 + 2] = 0;
	}
	for (var i = 0; i < 4 * n; i++) {
		this.circleModelData.rgba[i] = 255;
	}
	for (var i = 0; i < 2 * n; i++) {
		this.circleModelData.uv[i] = 0;
	}
	this.drawModelData(this.circleModelData);
	this.gLPopMatrix();
}

Game.prototype.clientCommand = function(s_) {
	if (s_ == "") {
		return;
	}
	var ssCount = new IntRef();
	var ss = this.platform.stringSplit(s_, " ", ssCount);
	if (StringTools.stringStartsWith(this.platform, s_, ".")) {
		var strFreemoveNotAllowed = this.language.freemoveNotAllowed();
		var cmd = StringTools.stringSubstringToEnd(this.platform, ss[0], 1);
		var arguments;
		if (this.platform.stringIndexOf(s_, " ") == -1) {
			arguments = "";
		}
		else {
			arguments = StringTools.stringSubstringToEnd(this.platform, s_, this.platform.stringIndexOf(s_, " "));
		}
		arguments = this.platform.stringTrim(arguments);
		if (cmd == "clients") {
			this.log("Clients:");
			for (var i = 0; i < this.entitiesCount; i++) {
				var entity = this.entities[i];
				if (entity == null) {
					continue;
				}
				if (entity.drawName == null) {
					continue;
				}
				if (!entity.drawName.clientAutoComplete) {
					continue;
				}
				this.log(this.platform.stringFormat2("{0} {1}", this.platform.intToString(i), this.entities[i].drawName.name));
			}
		}
		else if (cmd == "reconnect") {
			this.reconnect();
		}
		else if (cmd == "m") {
			this.mouseSmoothing = !this.mouseSmoothing;
			if (this.mouseSmoothing) {
				this.log("Mouse smoothing enabled.");
			}
			else {
				this.log("Mouse smoothing disabled.");
			}
		}
		else if (cmd == "noclip") {
			if (this.allowFreemove) {
				this.stopPlayerMove = true;
				if (this.boolCommandArgument(arguments)) {
					this.controls.setFreemove(2);
				}
				else {
					this.controls.setFreemove(0);
				}
			}
			else {
				this.log(strFreemoveNotAllowed);
				return;
			}
		}
		else if (cmd == "freemove") {
			if (this.allowFreemove) {
				this.stopPlayerMove = true;
				if (this.boolCommandArgument(arguments)) {
					this.controls.setFreemove(1);
				}
				else {
					this.controls.setFreemove(0);
				}
			}
			else {
				this.log(strFreemoveNotAllowed);
				return;
			}
		}
		else if (cmd == "gui") {
			this.eNABLE_DRAW2D = this.boolCommandArgument(arguments);
		}
		else if (arguments != "") {
			if (cmd == "fog") {
				var foglevel;
				foglevel = this.platform.intParse(arguments);
				{
					var foglevel2 = foglevel;
					if (foglevel2 > 1024) {
						foglevel2 = 1024;
					}
					if (foglevel2 % 2 == 0) {
						foglevel2--;
					}
					this.d_Config3d.viewdistance = foglevel2;
				}
				this.onResize();
			}
			else if (cmd == "fov") {
				var arg = this.platform.intParse(arguments);
				var minfov = 1;
				var maxfov = 179;
				if (!this.issingleplayer) {
					minfov = 60;
				}
				if (arg < minfov || arg > maxfov) {
					this.log(this.platform.stringFormat2("Valid field of view: {0}-{1}", this.platform.intToString(minfov), this.platform.intToString(maxfov)));
				}
				else {
					var fov_ = 2 * Game.getPi() * (this.one * arg) / (360);
					this.fov = fov_;
					this.onResize();
				}
			}
			else if (cmd == "movespeed") {
				if (this.allowFreemove) {
					if (this.platform.floatParse(arguments) <= 500) {
						this.movespeed = this.basemovespeed * this.platform.floatParse(arguments);
						this.addChatline(this.platform.stringFormat("Movespeed: {0}x", arguments));
					}
					else {
						this.addChatline("Entered movespeed to high! max. 500x");
					}
				}
				else {
					this.log(strFreemoveNotAllowed);
					return;
				}
			}
			else if (cmd == "serverinfo") {
				var splitCount = new IntRef();
				var split = this.platform.stringSplit(arguments, ":", splitCount);
				if (splitCount.value == 2) {
					var qClient = new QueryClient();
					qClient.setPlatform(this.platform);
					qClient.performQuery(split[0], this.platform.intParse(split[1]));
					if (qClient.querySuccess) {
						var r = qClient.getResult();
						this.addChatline(r.gameMode);
						this.addChatline(this.platform.intToString(r.mapSizeX));
						this.addChatline(this.platform.intToString(r.mapSizeY));
						this.addChatline(this.platform.intToString(r.mapSizeZ));
						this.addChatline(this.platform.intToString(r.maxPlayers));
						this.addChatline(r.mOTD);
						this.addChatline(r.name);
						this.addChatline(this.platform.intToString(r.playerCount));
						this.addChatline(r.playerList);
						this.addChatline(this.platform.intToString(r.port));
						this.addChatline(r.publicHash);
						this.addChatline(r.serverVersion);
					}
					this.addChatline(qClient.getServerMessage());
				}
			}
		}
		else {
			var chatline = StringTools.stringSubstring(this.platform, this.guiTypingBuffer, 0, MathCi.minInt(this.guiTypingBuffer.length, 256));
			this.sendChat(chatline);
		}
		for (var i = 0; i < this.clientmodsCount; i++) {
			var args = new ClientCommandArgs();
			args.arguments = arguments;
			args.command = cmd;
			this.clientmods[i].onClientCommand(this, args);
		}
	}
	else {
		var chatline = StringTools.stringSubstring(this.platform, this.guiTypingBuffer, 0, MathCi.minInt(StringTools.stringLength(this.platform, this.guiTypingBuffer), 4096));
		this.sendChat(chatline);
	}
}

Game.colorA = function(color) {
	var a = Game.intToByte(color >> 24);
	return a;
}

Game.colorB = function(color) {
	var b = Game.intToByte(color);
	return b;
}

Game.colorFromArgb = function(a, r, g, b) {
	var iCol = a << 24 | r << 16 | g << 8 | b;
	return iCol;
}

Game.colorG = function(color) {
	var g = Game.intToByte(color >> 8);
	return g;
}

Game.colorR = function(color) {
	var r = Game.intToByte(color >> 16);
	return r;
}

Game.prototype.combineModelData = function(modelDatas, count) {
	var ret = new ModelData();
	var totalIndices = 0;
	var totalVertices = 0;
	for (var i = 0; i < count; i++) {
		var m = modelDatas[i];
		totalIndices += m.indicesCount;
		totalVertices += m.verticesCount;
	}
	ret.indices = new Int32Array(new ArrayBuffer(totalIndices << 2));
	ret.xyz = new Float32Array(new ArrayBuffer(totalVertices * 3 << 2));
	ret.uv = new Float32Array(new ArrayBuffer(totalVertices * 2 << 2));
	ret.rgba = new Uint8Array(new ArrayBuffer(totalVertices * 4));
	for (var i = 0; i < count; i++) {
		var m = modelDatas[i];
		var retVerticesCount = ret.verticesCount;
		var retIndicesCount = ret.indicesCount;
		for (var k = 0; k < m.indicesCount; k++) {
			ret.indices[ret.indicesCount++] = m.indices[k] + retVerticesCount;
		}
		for (var k = 0; k < m.verticesCount * 3; k++) {
			ret.xyz[retVerticesCount * 3 + k] = m.xyz[k];
		}
		for (var k = 0; k < m.verticesCount * 2; k++) {
			ret.uv[retVerticesCount * 2 + k] = m.uv[k];
		}
		for (var k = 0; k < m.verticesCount * 4; k++) {
			ret.rgba[retVerticesCount * 4 + k] = m.rgba[k];
		}
		ret.verticesCount += m.verticesCount;
	}
	return ret;
}

Game.prototype.connect = function(serverAddress, port, username, auth) {
	this.main.start();
	this.main.connect(serverAddress, port);
	this.sendPacketClient(ClientPackets.createLoginPacket(this.platform, username, auth));
}

Game.prototype.connect_ = function(serverAddress, port, username, auth, serverPassword) {
	this.main.start();
	this.main.connect(serverAddress, port);
	this.sendPacketClient(ClientPackets.createLoginPacket_(this.platform, username, auth, serverPassword));
}

Game.prototype.connect__ = function() {
	if (this.connectdata.serverPassword == null || this.connectdata.serverPassword == "") {
		this.connect(this.connectdata.ip, this.connectdata.port, this.connectdata.username, this.connectdata.auth);
	}
	else {
		this.connect_(this.connectdata.ip, this.connectdata.port, this.connectdata.username, this.connectdata.auth, this.connectdata.serverPassword);
	}
	this.mapLoadingStart();
}

Game.prototype.createBulletEntity = function(fromX, fromY, fromZ, toX, toY, toZ, speed) {
	var entity = new Entity();
	var bullet = new Bullet_();
	bullet.fromX = fromX;
	bullet.fromY = fromY;
	bullet.fromZ = fromZ;
	bullet.toX = toX;
	bullet.toY = toY;
	bullet.toZ = toZ;
	bullet.speed = speed;
	entity.bullet = bullet;
	entity.sprite = new Sprite();
	entity.sprite.image = "Sponge.png";
	entity.sprite.size = 4;
	entity.sprite.animationcount = 0;
	return entity;
}

Game.prototype.currentAimRadius = function() {
	var item = this.d_Inventory.rightHand[this.activeMaterial];
	if (item == null || item.itemClass != 0) {
		return 0;
	}
	var radius = this.deserializeFloat(this.blocktypes[item.blockId].aimRadiusFloat) / (800) * this.width();
	if (this.ironSights) {
		radius = this.deserializeFloat(this.blocktypes[item.blockId].ironSightsAimRadiusFloat) / (800) * this.width();
	}
	return radius + this.radiusWhenMoving * radius * MathCi.minFloat(this.playervelocity.length() / (this.movespeed), 1);
}

Game.prototype.currentRecoil = function() {
	var item = this.d_Inventory.rightHand[this.activeMaterial];
	if (item == null || item.itemClass != 0) {
		return 0;
	}
	return this.deserializeFloat(this.blocktypes[item.blockId].recoilFloat);
}
Game.D_I_S_C_O_N_N_E_C_T_E_D__I_C_O_N__A_F_T_E_R__S_E_C_O_N_D_S = 10;

Game.prototype.deleteTexture = function(name) {
	if (name != null && this.textures.contains(name)) {
		var id = this.textures.get(name);
		this.textures.remove(name);
		this.platform.gLDeleteTexture(id);
		return true;
	}
	return false;
}

Game.prototype.deleteUnusedCachedTextTextures = function() {
	var now = this.platform.timeMillisecondsFromStart();
	for (var i = 0; i < this.cachedTextTexturesMax; i++) {
		var t = this.cachedTextTextures[i];
		if (t == null) {
			continue;
		}
		if ((this.one * (now - t.texture.lastuseMilliseconds)) / (1000) > 1) {
			this.platform.gLDeleteTexture(t.texture.textureId);
			this.cachedTextTextures[i] = null;
		}
	}
}

Game.prototype.deserializeFloat = function(value) {
	return (this.one * value) / (32);
}

Game.prototype.dialogsCount_ = function() {
	var count = 0;
	for (var i = 0; i < this.dialogsCount; i++) {
		if (this.dialogs[i] != null) {
			count++;
		}
	}
	return count;
}

Game.prototype.dispose = function() {
	for (var i = 0; i < this.clientmodsCount; i++) {
		if (this.clientmods[i] == null) {
			continue;
		}
		this.clientmods[i].dispose(this);
	}
	for (var i = 0; i < this.textures.count; i++) {
		if (this.textures.items[i] == null) {
			continue;
		}
		this.platform.gLDeleteTexture(this.textures.items[i].value);
	}
	for (var i = 0; i < this.cachedTextTexturesMax; i++) {
		if (this.cachedTextTextures[i] == null) {
			continue;
		}
		if (this.cachedTextTextures[i].texture == null) {
			continue;
		}
		this.platform.gLDeleteTexture(this.cachedTextTextures[i].texture.textureId);
	}
}

Game.prototype.dist = function(x1, y1, z1, x2, y2, z2) {
	var dx = x2 - x1;
	var dy = y2 - y1;
	var dz = z2 - z1;
	return this.platform.mathSqrt(dx * dx + dy * dy + dz * dz);
}

Game.prototype.draw2d = function(dt) {
	if (!this.eNABLE_DRAW2D) {
		return;
	}
	this.orthoMode(this.width(), this.height());
	for (var i = 0; i < this.clientmodsCount; i++) {
		if (this.clientmods[i] == null) {
			continue;
		}
		this.clientmods[i].onNewFrameDraw2d(this, dt);
	}
	this.perspectiveMode();
}

Game.prototype.draw2dBitmapFile = function(filename, x, y, w, h) {
	this.draw2dTexture(this.getTexture(filename), x, y, w, h, null, 0, Game.colorFromArgb(255, 255, 255, 255), false);
}

Game.prototype.draw2dText = function(text, font, x, y, color, enabledepthtest) {
	if (text == null || this.platform.stringTrim(text) == "") {
		return;
	}
	if (color == null) {
		color = IntRef.create(Game.colorFromArgb(255, 255, 255, 255));
	}
	var t = new Text_();
	t.text = text;
	t.color = color.value;
	t.font = font;
	var ct;
	if (this.getCachedTextTexture(t) == null) {
		ct = this.makeTextTexture(t);
		if (ct == null) {
			return;
		}
		for (var i = 0; i < this.cachedTextTexturesMax; i++) {
			if (this.cachedTextTextures[i] == null) {
				var ct1 = new CachedTextTexture();
				ct1.text = t;
				ct1.texture = ct;
				this.cachedTextTextures[i] = ct1;
				break;
			}
		}
	}
	ct = this.getCachedTextTexture(t);
	ct.lastuseMilliseconds = this.platform.timeMillisecondsFromStart();
	this.draw2dTexture(ct.textureId, x, y, ct.sizeX, ct.sizeY, null, 0, Game.colorFromArgb(255, 255, 255, 255), enabledepthtest);
	this.deleteUnusedCachedTextTextures();
}

Game.prototype.draw2dTexture = function(textureid, x1, y1, width, height, inAtlasId, atlastextures, color, enabledepthtest) {
	this.platform.gLDisableAlphaTest();
	if (color == Game.colorFromArgb(255, 255, 255, 255) && inAtlasId == null) {
		this.draw2dTextureSimple(textureid, x1, y1, width, height, enabledepthtest);
	}
	else {
		this.draw2dTextureInAtlas(textureid, x1, y1, width, height, inAtlasId, atlastextures, color, enabledepthtest);
	}
	this.platform.gLEnableAlphaTest();
}

Game.prototype.draw2dTextureInAtlas = function(textureid, x1, y1, width, height, inAtlasId, atlastextures, color, enabledepthtest) {
	var rect = RectFRef.create(0, 0, 1, 1);
	if (inAtlasId != null) {
		TextureAtlasCi.textureCoords2d(inAtlasId.value, atlastextures, rect);
	}
	this.platform.glDisableCullFace();
	this.platform.glEnableTexture2d();
	this.platform.bindTexture2d(textureid);
	if (!enabledepthtest) {
		this.platform.glDisableDepthTest();
	}
	var data = QuadModelData.getQuadModelData2(rect.x, rect.y, rect.w, rect.h, x1, y1, width, height, Game.intToByte(Game.colorR(color)), Game.intToByte(Game.colorG(color)), Game.intToByte(Game.colorB(color)), Game.intToByte(Game.colorA(color)));
	this.drawModelData(data);
	if (!enabledepthtest) {
		this.platform.glEnableDepthTest();
	}
	this.platform.glEnableCullFace();
	this.platform.glEnableTexture2d();
}

Game.prototype.draw2dTexturePart = function(textureid, srcwidth, srcheight, dstx, dsty, dstwidth, dstheight, color, enabledepthtest) {
	var rect = RectFRef.create(0, 0, srcwidth, srcheight);
	this.platform.glDisableCullFace();
	this.platform.glEnableTexture2d();
	this.platform.bindTexture2d(textureid);
	if (!enabledepthtest) {
		this.platform.glDisableDepthTest();
	}
	var data = QuadModelData.getQuadModelData2(rect.x, rect.y, rect.w, rect.h, dstx, dsty, dstwidth, dstheight, Game.intToByte(Game.colorR(color)), Game.intToByte(Game.colorG(color)), Game.intToByte(Game.colorB(color)), Game.intToByte(Game.colorA(color)));
	this.drawModelData(data);
	if (!enabledepthtest) {
		this.platform.glEnableDepthTest();
	}
	this.platform.glEnableCullFace();
	this.platform.glEnableTexture2d();
}

Game.prototype.draw2dTextureSimple = function(textureid, x1, y1, width, height, enabledepthtest) {
	var rect = RectFRef.create(0, 0, 1, 1);
	this.platform.glDisableCullFace();
	this.platform.glEnableTexture2d();
	this.platform.bindTexture2d(textureid);
	if (!enabledepthtest) {
		this.platform.glDisableDepthTest();
	}
	if (this.quadModel == null) {
		this.quadModel = this.platform.createModel(QuadModelData.getQuadModelData());
	}
	this.gLPushMatrix();
	this.gLTranslate(x1, y1, 0);
	this.gLScale(width, height, 0);
	this.gLScale(this.one / (2), this.one / (2), 0);
	this.gLTranslate(this.one, this.one, 0);
	this.drawModel(this.quadModel);
	this.gLPopMatrix();
	if (!enabledepthtest) {
		this.platform.glEnableDepthTest();
	}
	this.platform.glEnableCullFace();
	this.platform.glEnableTexture2d();
}

Game.prototype.draw2dTextures = function(todraw, todrawLength, textureid) {
	var modelDatas = new Array(512);
	var modelDatasCount = 0;
	for (var i = 0; i < todrawLength; i++) {
		var d = todraw[i];
		var x1 = d.x1;
		var y1 = d.y1;
		var width = d.width;
		var height = d.height;
		var inAtlasId = d.inAtlasId;
		var textureId = textureid;
		var color = d.color;
		var rect = RectFRef.create(0, 0, 1, 1);
		if (inAtlasId != null) {
			TextureAtlasCi.textureCoords2d(inAtlasId.value, this.texturesPacked(), rect);
		}
		var modelData = QuadModelData.getQuadModelData2(rect.x, rect.y, rect.w, rect.h, x1, y1, width, height, Game.intToByte(Game.colorR(color)), Game.intToByte(Game.colorG(color)), Game.intToByte(Game.colorB(color)), Game.intToByte(Game.colorA(color)));
		modelDatas[modelDatasCount++] = modelData;
	}
	var combined = this.combineModelData(modelDatas, modelDatasCount);
	this.platform.glDisableCullFace();
	this.platform.glEnableTexture2d();
	this.platform.bindTexture2d(textureid);
	this.platform.glDisableDepthTest();
	this.drawModelData(combined);
	this.platform.glEnableDepthTest();
	this.platform.glDisableCullFace();
	this.platform.glEnableTexture2d();
}

Game.prototype.drawModel = function(model) {
	this.setMatrixUniformModelView();
	this.platform.drawModel(model);
}

Game.prototype.drawModelData = function(data) {
	this.setMatrixUniformModelView();
	this.platform.drawModelData(data);
}

Game.prototype.drawModels = function(model, count) {
	this.setMatrixUniformModelView();
	this.platform.drawModels(model, count);
}

Game.prototype.enablePlayerUpdatePosition = function(kKey) {
	return true;
}

Game.prototype.enablePlayerUpdatePositionContainsKey = function(kKey) {
	return false;
}

Game.prototype.entityAddLocal = function(entity) {
	for (var i = 256; i < this.entitiesCount; i++) {
		if (this.entities[i] == null) {
			this.entities[i] = entity;
			return;
		}
	}
	this.entities[this.entitiesCount++] = entity;
}

Game.prototype.escapeMenuStart = function() {
	this.guistate = GuiState.ESCAPE_MENU;
	this.menustate = new MenuState();
	this.platform.exitMousePointerLock();
	this.escapeMenuRestart = true;
}

Game.prototype.exitAndSwitchServer = function(newServer) {
	if (this.issingleplayer) {
		this.platform.singlePlayerServerExit();
	}
	this.redirectTo = newServer;
	this.exitToMainMenu = true;
}

Game.prototype.exitToMainMenu_ = function() {
	if (this.issingleplayer) {
		this.platform.singlePlayerServerExit();
	}
	this.redirectTo = null;
	this.exitToMainMenu = true;
}

Game.prototype.eyesPosX = function() {
	return this.player.position.x;
}

Game.prototype.eyesPosY = function() {
	return this.player.position.y + this.getCharacterEyesHeight();
}

Game.prototype.eyesPosZ = function() {
	return this.player.position.z;
}

Game.prototype.floorFloat = function(a) {
	if (a >= 0) {
		return this.platform.floatToInt(a);
	}
	else {
		return this.platform.floatToInt(a) - 1;
	}
}

Game.prototype.followId = function() {
	if (this.follow == null) {
		return null;
	}
	for (var i = 0; i < this.entitiesCount; i++) {
		if (this.entities[i] == null) {
			continue;
		}
		if (this.entities[i].drawName == null) {
			continue;
		}
		var p = this.entities[i].drawName;
		if (p.name == this.follow) {
			return IntRef.create(i);
		}
	}
	return null;
}

Game.prototype.frameTick = function(dt) {
	var args_ = new NewFrameEventArgs();
	args_.setDt(dt);
	for (var i = 0; i < this.clientmodsCount; i++) {
		this.clientmods[i].onNewFrameFixed(this, args_);
	}
	for (var i = 0; i < this.entitiesCount; i++) {
		var e = this.entities[i];
		if (e == null) {
			continue;
		}
		for (var k = 0; k < e.scriptsCount; k++) {
			e.scripts[k].onNewFrameFixed(this, i, dt);
		}
	}
	this.revertSpeculative(dt);
	if (this.guistate == GuiState.MAP_LOADING) {
		return;
	}
	var orientationX = this.platform.mathSin(this.player.position.roty);
	var orientationY = 0;
	var orientationZ = -this.platform.mathCos(this.player.position.roty);
	this.platform.audioUpdateListener(this.eyesPosX(), this.eyesPosY(), this.eyesPosZ(), orientationX, orientationY, orientationZ);
	this.playervelocity.x = this.player.position.x - this.lastplayerpositionX;
	this.playervelocity.y = this.player.position.y - this.lastplayerpositionY;
	this.playervelocity.z = this.player.position.z - this.lastplayerpositionZ;
	this.playervelocity.x *= 75;
	this.playervelocity.y *= 75;
	this.playervelocity.z *= 75;
	this.lastplayerpositionX = this.player.position.x;
	this.lastplayerpositionY = this.player.position.y;
	this.lastplayerpositionZ = this.player.position.z;
}

Game.prototype.gLLoadIdentity = function() {
	if (this.currentMatrixModeProjection) {
		if (this.pMatrix.count() > 0) {
			this.pMatrix.pop();
		}
		this.pMatrix.push(this.identityMatrix);
	}
	else {
		if (this.mvMatrix.count() > 0) {
			this.mvMatrix.pop();
		}
		this.mvMatrix.push(this.identityMatrix);
	}
}

Game.prototype.gLLoadMatrix = function(m) {
	if (this.currentMatrixModeProjection) {
		if (this.pMatrix.count() > 0) {
			this.pMatrix.pop();
		}
		this.pMatrix.push(m);
	}
	else {
		if (this.mvMatrix.count() > 0) {
			this.mvMatrix.pop();
		}
		this.mvMatrix.push(m);
	}
}

Game.prototype.gLMatrixModeModelView = function() {
	this.currentMatrixModeProjection = false;
}

Game.prototype.gLMatrixModeProjection = function() {
	this.currentMatrixModeProjection = true;
}

Game.prototype.gLOrtho = function(left, right, bottom, top, zNear, zFar) {
	if (this.currentMatrixModeProjection) {
		var m = this.pMatrix.peek();
		Mat4.ortho(m, left, right, bottom, top, zNear, zFar);
	}
	else {
		this.platform.throwException("GLOrtho");
	}
}

Game.prototype.gLPopMatrix = function() {
	if (this.currentMatrixModeProjection) {
		if (this.pMatrix.count() > 1) {
			this.pMatrix.pop();
		}
	}
	else {
		if (this.mvMatrix.count() > 1) {
			this.mvMatrix.pop();
		}
	}
}

Game.prototype.gLPushMatrix = function() {
	if (this.currentMatrixModeProjection) {
		this.pMatrix.push(this.pMatrix.peek());
	}
	else {
		this.mvMatrix.push(this.mvMatrix.peek());
	}
}

Game.prototype.gLRotate = function(angle, x, y, z) {
	angle /= 360;
	angle *= 2 * Game.getPi();
	var m;
	if (this.currentMatrixModeProjection) {
		m = this.pMatrix.peek();
	}
	else {
		m = this.mvMatrix.peek();
	}
	Vec3.set(this.gLRotateTempVec3, x, y, z);
	Mat4.rotate(m, m, angle, this.gLRotateTempVec3);
}

Game.prototype.gLScale = function(x, y, z) {
	var m;
	if (this.currentMatrixModeProjection) {
		m = this.pMatrix.peek();
	}
	else {
		m = this.mvMatrix.peek();
	}
	Vec3.set(this.gLScaleTempVec3, x, y, z);
	Mat4.scale(m, m, this.gLScaleTempVec3);
}

Game.prototype.gLTranslate = function(x, y, z) {
	var m;
	if (this.currentMatrixModeProjection) {
		m = this.pMatrix.peek();
	}
	else {
		m = this.mvMatrix.peek();
	}
	Vec3.set(this.gLTranslateTempVec3, x, y, z);
	Mat4.translate(m, m, this.gLTranslateTempVec3);
}

Game.prototype.getCachedTextTexture = function(t) {
	for (var i = 0; i < this.cachedTextTexturesMax; i++) {
		var ct = this.cachedTextTextures[i];
		if (ct == null) {
			continue;
		}
		if (ct.text.equals_(t)) {
			return ct.texture;
		}
	}
	return null;
}

Game.prototype.getCameraBlock = function() {
	var bx = this.mathFloor(this.cameraEyeX);
	var by = this.mathFloor(this.cameraEyeZ);
	var bz = this.mathFloor(this.cameraEyeY);
	if (!this.map.isValidPos(bx, by, bz)) {
		return 0;
	}
	return this.map.getBlockValid(bx, by, bz);
}

Game.prototype.getCharacterEyesHeight = function() {
	return this.entities[this.localPlayerId].drawModel.eyeHeight;
}

Game.prototype.getCurrentBlockHealth = function(x, y, z) {
	if (this.blockHealth.containsKey(x, y, z)) {
		return this.blockHealth.get(x, y, z);
	}
	var blocktype = this.map.getBlock(x, y, z);
	return this.d_Data.strength()[blocktype];
}

Game.prototype.getDialogId = function(name) {
	for (var i = 0; i < this.dialogsCount; i++) {
		if (this.dialogs[i] == null) {
			continue;
		}
		if (this.dialogs[i].key == name) {
			return i;
		}
	}
	return -1;
}

Game.prototype.getFile = function(p) {
	var pLowercase = this.platform.stringToLower(p);
	for (var i = 0; i < this.assets.count; i++) {
		if (this.assets.items[i].name == pLowercase) {
			return this.assets.items[i].data;
		}
	}
	return null;
}

Game.prototype.getFileLength = function(p) {
	var pLowercase = this.platform.stringToLower(p);
	for (var i = 0; i < this.assets.count; i++) {
		if (this.assets.items[i].name == pLowercase) {
			return this.assets.items[i].dataLength;
		}
	}
	return 0;
}

Game.prototype.getFreeMouse = function() {
	if (this.overheadcamera) {
		return true;
	}
	return !this.platform.isMousePointerLocked();
}

Game.prototype.getKey = function(key) {
	if (this.options == null) {
		return key;
	}
	if (this.options.keys[key] != 0) {
		return this.options.keys[key];
	}
	return key;
}

Game.prototype.getLight = function(x, y, z) {
	var light = this.map.maybeGetLight(x, y, z);
	if (light == -1) {
		if (x >= 0 && x < this.map.mapSizeX && y >= 0 && y < this.map.mapSizeY && z >= this.d_Heightmap.getBlock(x, y)) {
			return this.sunlight_;
		}
		else {
			return 0;
		}
	}
	else {
		return light;
	}
}

Game.getPi = function() {
	var a = 3141592;
	return a / (1000000);
}

Game.prototype.getPlatform = function() {
	return this.platform;
}

Game.prototype.getPlayerEyesBlock = function() {
	var pX = this.player.position.x;
	var pY = this.player.position.y;
	var pZ = this.player.position.z;
	pY += this.entities[this.localPlayerId].drawModel.eyeHeight;
	var bx = this.mathFloor(pX);
	var by = this.mathFloor(pZ);
	var bz = this.mathFloor(pY);
	if (!this.map.isValidPos(bx, by, bz)) {
		if (pY < this.waterLevel()) {
			return -1;
		}
		return 0;
	}
	return this.map.getBlockValid(bx, by, bz);
}

Game.prototype.getPlayerEyesBlockX = function() {
	return this.platform.floatToInt(this.mathFloor(this.player.position.x));
}

Game.prototype.getPlayerEyesBlockY = function() {
	return this.platform.floatToInt(this.mathFloor(this.player.position.z));
}

Game.prototype.getPlayerEyesBlockZ = function() {
	return this.platform.floatToInt(this.mathFloor(this.player.position.y + this.entities[this.localPlayerId].drawModel.eyeHeight));
}

Game.prototype.getRedirect = function() {
	return this.redirectTo;
}

Game.prototype.getTexture = function(p) {
	if (!this.textures.contains(p)) {
		var found = new BoolRef();
		var bmp = this.platform.bitmapCreateFromPng(this.getFile(p), this.getFileLength(p));
		var texture = this.platform.loadTextureFromBitmap(bmp);
		this.textures.set(p, texture);
		this.platform.bitmapDelete(bmp);
	}
	return this.textures.get(p);
}

Game.prototype.getTextureOrLoad = function(name, bmp) {
	if (!this.textures.contains(name)) {
		var found = new BoolRef();
		this.textures.set(name, this.platform.loadTextureFromBitmap(bmp));
	}
	return this.textures.get(name);
}

Game.prototype.gotoDraw2d = function(dt) {
	this.setAmbientLight(Game.colorFromArgb(255, 255, 255, 255));
	this.draw2d(dt);
	var args_ = new NewFrameEventArgs();
	args_.setDt(dt);
	for (var i = 0; i < this.clientmodsCount; i++) {
		this.clientmods[i].onNewFrame(this, args_);
	}
	this.mouseleftclick = this.mouserightclick = false;
	this.mouseleftdeclick = this.mouserightdeclick = false;
	if (!this.issingleplayer || this.issingleplayer && this.platform.singlePlayerServerLoaded() || !this.platform.singlePlayerServerAvailable()) {
		if (!this.startedconnecting) {
			this.startedconnecting = true;
			this.connect__();
		}
	}
}

Game.prototype.guiStateBackToGame = function() {
	this.guistate = GuiState.NORMAL;
	this.setFreeMouse(false);
}

Game.prototype.handleMaterialKeys = function(eKey) {
	if (eKey == this.getKey(110)) {
		this.activeMaterial = 0;
	}
	if (eKey == this.getKey(111)) {
		this.activeMaterial = 1;
	}
	if (eKey == this.getKey(112)) {
		this.activeMaterial = 2;
	}
	if (eKey == this.getKey(113)) {
		this.activeMaterial = 3;
	}
	if (eKey == this.getKey(114)) {
		this.activeMaterial = 4;
	}
	if (eKey == this.getKey(115)) {
		this.activeMaterial = 5;
	}
	if (eKey == this.getKey(116)) {
		this.activeMaterial = 6;
	}
	if (eKey == this.getKey(117)) {
		this.activeMaterial = 7;
	}
	if (eKey == this.getKey(118)) {
		this.activeMaterial = 8;
	}
	if (eKey == this.getKey(109)) {
		this.activeMaterial = 9;
	}
}

Game.prototype.hasAsset = function(md5, name) {
	for (var i = 0; i < this.assets.count; i++) {
		if (this.assets.items[i].md5 == md5) {
			if (this.assets.items[i].name == name) {
				return true;
			}
		}
	}
	return false;
}

Game.prototype.height = function() {
	return this.platform.getCanvasHeight();
}
Game.HOUR_DETAIL = 4;

Game.intToByte = function(a) {
	return a & 0xff;
}

Game.prototype.invalidPlayerWarning = function(playerid) {
	this.platform.consoleWriteLine(this.platform.stringFormat("Position update of nonexistent player {0}.", this.platform.intToString(playerid)));
}

Game.prototype.invalidVersionAllow = function() {
	if (this.invalidVersionDrawMessage != null) {
		this.invalidVersionDrawMessage = null;
		this.processServerIdentification(this.invalidVersionPacketIdentification);
		this.invalidVersionPacketIdentification = null;
	}
}

Game.prototype.inventoryClick = function(pos) {
	this.sendPacketClient(ClientPackets.inventoryClick(pos));
}

Game.prototype.inventoryPositionMainArea = function(x, y) {
	var pos = new Packet_InventoryPosition();
	pos.type = 0;
	pos.areaX = x;
	pos.areaY = y;
	return pos;
}

Game.prototype.inventoryPositionMaterialSelector = function(materialId) {
	var pos = new Packet_InventoryPosition();
	pos.type = 2;
	pos.materialId = materialId;
	return pos;
}

Game.prototype.invokeMapLoadingProgress = function(progressPercent, progressBytes, status) {
	this.maploadingprogress = new MapLoadingProgressEventArgs();
	this.maploadingprogress.progressPercent = progressPercent;
	this.maploadingprogress.progressBytes = progressBytes;
	this.maploadingprogress.progressStatus = status;
}

Game.prototype.isAnyPlayerInPos = function(blockposX, blockposY, blockposZ) {
	for (var i = 0; i < this.entitiesCount; i++) {
		var e = this.entities[i];
		if (e == null) {
			continue;
		}
		if (e.drawModel == null) {
			continue;
		}
		if (e.networkPosition == null || e.networkPosition != null && e.networkPosition.positionLoaded) {
			if (this.isPlayerInPos(e.position.x, e.position.y, e.position.z, blockposX, blockposY, blockposZ, e.drawModel.modelHeight)) {
				return true;
			}
		}
	}
	return this.isPlayerInPos(this.player.position.x, this.player.position.y, this.player.position.z, blockposX, blockposY, blockposZ, this.player.drawModel.modelHeight);
}

Game.prototype.isEmptyForPhysics = function(block) {
	return block.drawType == 9 || block.walkableType != 2 && block.walkableType != 1;
}

Game.prototype.isFillBlock = function(blocktype) {
	return blocktype == this.d_Data.blockIdFillArea() || blocktype == this.d_Data.blockIdFillStart() || blocktype == this.d_Data.blockIdCuboid();
}

Game.prototype.isLava = function(blockType) {
	var name = this.blocktypes[blockType].name;
	if (name == null) {
		return false;
	}
	return this.platform.stringContains(name, "Lava");
}

Game.prototype.isPlayerInPos = function(playerposX, playerposY, playerposZ, blockposX, blockposY, blockposZ, playerHeight) {
	for (var i = 0; i < this.floorFloat(playerHeight) + 1; i++) {
		if (ScriptCharacterPhysics.boxPointDistance(blockposX, blockposZ, blockposY, blockposX + 1, blockposZ + 1, blockposY + 1, playerposX, playerposY + i + this.constWallDistance, playerposZ) < this.constWallDistance) {
			return true;
		}
	}
	return false;
}

Game.prototype.isRail = function(block) {
	return block.rail > 0;
}

Game.prototype.isTileEmptyForPhysics = function(x, y, z) {
	if (z >= this.map.mapSizeZ) {
		return true;
	}
	if (x < 0 || y < 0 || z < 0) {
		return this.controls.getFreemove() != 0;
	}
	if (x >= this.map.mapSizeX || y >= this.map.mapSizeY) {
		return this.controls.getFreemove() != 0;
	}
	var block = this.map.getBlockValid(x, y, z);
	return block == 0 || block == this.d_Data.blockIdFillArea() || this.isWater(block);
}

Game.prototype.isTileEmptyForPhysicsClose = function(x, y, z) {
	return this.isTileEmptyForPhysics(x, y, z) || this.map.isValidPos(x, y, z) && this.blocktypes[this.map.getBlock(x, y, z)].drawType == 11 || this.map.isValidPos(x, y, z) && this.isEmptyForPhysics(this.blocktypes[this.map.getBlock(x, y, z)]);
}

Game.isTransparentForLight = function(b) {
	return b.drawType != 1 && b.drawType != 8;
}

Game.prototype.isUsableBlock = function(blocktype) {
	return this.d_Data.isRailTile(blocktype) || this.blocktypes[blocktype].isUsable;
}

Game.prototype.isValid = function(blocktype) {
	return this.blocktypes[blocktype].name != null;
}

Game.prototype.isWater = function(blockType) {
	var name = this.blocktypes[blockType].name;
	if (name == null) {
		return false;
	}
	return this.platform.stringContains(name, "Water");
}

Game.prototype.isWearingWeapon = function() {
	return this.d_Inventory.rightHand[this.activeMaterial] != null;
}
Game.KEY_ALT_LEFT = 5;
Game.KEY_ALT_RIGHT = 6;

Game.prototype.keyDown = function(eKey) {
	this.keyboardStateRaw[eKey] = true;
	if (this.guistate != GuiState.MAP_LOADING) {
		for (var i = 0; i < this.clientmodsCount; i++) {
			var args_ = new KeyEventArgs();
			args_.setKeyCode(eKey);
			this.clientmods[i].onKeyDown(this, args_);
			if (args_.getHandled()) {
				return;
			}
		}
	}
	this.keyboardState[eKey] = true;
	this.invalidVersionAllow();
	if (eKey == this.getKey(15)) {
		var lagSeconds = (this.one * (this.platform.timeMillisecondsFromStart() - this.lastReceivedMilliseconds)) / (1000);
		if (lagSeconds >= 10 || this.guistate == GuiState.MAP_LOADING) {
			this.reconnect();
		}
	}
	if (eKey == this.getKey(1) || eKey == this.getKey(2)) {
		this.isShiftPressed = true;
	}
	if (this.guistate == GuiState.NORMAL) {
		var strFreemoveNotAllowed = "You are not allowed to enable freemove.";
		if (eKey == this.getKey(10)) {
			if (!this.allowFreemove) {
				this.log(strFreemoveNotAllowed);
				return;
			}
			this.movespeed = this.basemovespeed * 1;
			this.log("Move speed: 1x.");
		}
		if (eKey == this.getKey(11)) {
			if (!this.allowFreemove) {
				this.log(strFreemoveNotAllowed);
				return;
			}
			this.movespeed = this.basemovespeed * 10;
			this.log(this.platform.stringFormat(this.language.moveSpeed(), this.platform.intToString(10)));
		}
		if (eKey == this.getKey(12)) {
			if (!this.allowFreemove) {
				this.log(strFreemoveNotAllowed);
				return;
			}
			this.stopPlayerMove = true;
			if (this.controls.getFreemove() == 0) {
				this.controls.setFreemove(1);
				this.log(this.language.moveFree());
			}
			else if (this.controls.getFreemove() == 1) {
				this.controls.setFreemove(2);
				this.log(this.language.moveFreeNoclip());
			}
			else if (this.controls.getFreemove() == 2) {
				this.controls.setFreemove(0);
				this.log(this.language.moveNormal());
			}
		}
		if (eKey == this.getKey(91)) {
			this.drawblockinfo = !this.drawblockinfo;
		}
		var playerx = this.platform.floatToInt(this.player.position.x);
		var playery = this.platform.floatToInt(this.player.position.z);
		if (playerx >= 0 && playerx < this.map.mapSizeX && playery >= 0 && playery < this.map.mapSizeY) {
			this.performanceinfo.set("Terrain height", this.platform.intToString(this.d_Heightmap.getBlock(playerx, playery)));
		}
		if (eKey == this.getKey(14)) {
			this.cameraChange();
		}
		if (eKey == this.getKey(121) || eKey == this.getKey(80)) {
			if (this.cameratype == CameraType.OVERHEAD) {
				this.overheadcameradistance -= 1;
			}
			else if (this.cameratype == CameraType.TPP) {
				this.tppcameradistance -= 1;
			}
		}
		if (eKey == this.getKey(120) || eKey == this.getKey(79)) {
			if (this.cameratype == CameraType.OVERHEAD) {
				this.overheadcameradistance += 1;
			}
			else if (this.cameratype == CameraType.TPP) {
				this.tppcameradistance += 1;
			}
		}
		if (this.overheadcameradistance < this.tPP_CAMERA_DISTANCE_MIN) {
			this.overheadcameradistance = this.tPP_CAMERA_DISTANCE_MIN;
		}
		if (this.overheadcameradistance > this.tPP_CAMERA_DISTANCE_MAX) {
			this.overheadcameradistance = this.tPP_CAMERA_DISTANCE_MAX;
		}
		if (this.tppcameradistance < this.tPP_CAMERA_DISTANCE_MIN) {
			this.tppcameradistance = this.tPP_CAMERA_DISTANCE_MIN;
		}
		if (this.tppcameradistance > this.tPP_CAMERA_DISTANCE_MAX) {
			this.tppcameradistance = this.tPP_CAMERA_DISTANCE_MAX;
		}
		if (eKey == this.getKey(15)) {
			this.redrawAllBlocks();
		}
		if (eKey == 17) {
			this.toggleVsync();
			if (this.eNABLE_LAG == 0) {
				this.log(this.language.frameRateVsync());
			}
			if (this.eNABLE_LAG == 1) {
				this.log(this.language.frameRateUnlimited());
			}
			if (this.eNABLE_LAG == 2) {
				this.log(this.language.frameRateLagSimulation());
			}
		}
		if (eKey == this.getKey(52)) {
			this.sendPacketClient(ClientPackets.specialKeyTabPlayerList());
		}
		if (eKey == this.getKey(87)) {
			if (this.currentAttackedBlock != null) {
				var posX = this.currentAttackedBlock.x;
				var posY = this.currentAttackedBlock.y;
				var posZ = this.currentAttackedBlock.z;
				var blocktype = this.map.getBlock(this.currentAttackedBlock.x, this.currentAttackedBlock.y, this.currentAttackedBlock.z);
				if (this.isUsableBlock(blocktype)) {
					if (this.d_Data.isRailTile(blocktype)) {
						this.player.position.x = posX + this.one / (2);
						this.player.position.y = posZ + 1;
						this.player.position.z = posY + this.one / (2);
						this.stopPlayerMove = true;
						this.controls.setFreemove(0);
					}
					else {
						this.sendSetBlock(posX, posY, posZ, 2, 0, this.activeMaterial);
					}
				}
			}
			if (this.currentlyAttackedEntity != -1) {
				if (this.entities[this.currentlyAttackedEntity].usable) {
					for (var i = 0; i < this.clientmodsCount; i++) {
						if (this.clientmods[i] == null) {
							continue;
						}
						var args = new OnUseEntityArgs();
						args.entityId = this.currentlyAttackedEntity;
						this.clientmods[i].onUseEntity(this, args);
					}
					this.sendPacketClient(ClientPackets.useEntity(this.currentlyAttackedEntity));
				}
			}
		}
		if (eKey == this.getKey(97)) {
			this.respawn();
		}
		if (eKey == this.getKey(94)) {
			this.sendPacketClient(ClientPackets.specialKeySelectTeam());
		}
		if (eKey == this.getKey(98)) {
			this.sendPacketClient(ClientPackets.specialKeySetSpawn());
			this.playerPositionSpawnX = this.player.position.x;
			this.playerPositionSpawnY = this.player.position.y;
			this.playerPositionSpawnZ = this.player.position.z;
			this.player.position.x = this.platform.floatToInt(this.player.position.x) + this.one / (2);
			this.player.position.z = this.platform.floatToInt(this.player.position.z) + this.one / (2);
		}
		if (eKey == this.getKey(88)) {
			this.toggleFog();
			this.log(this.platform.stringFormat(this.language.fogDistance(), this.platform.intToString(this.platform.floatToInt(this.d_Config3d.viewdistance))));
			this.onResize();
		}
		if (eKey == this.getKey(84)) {
			this.showInventory();
			return;
		}
		this.handleMaterialKeys(eKey);
	}
	if (this.guistate == GuiState.INVENTORY) {
		if (eKey == this.getKey(84) || eKey == this.getKey(50)) {
			this.guiStateBackToGame();
		}
		return;
	}
	if (this.guistate == GuiState.MAP_LOADING) {
		if (eKey == this.getKey(50)) {
			this.exitToMainMenu_();
		}
	}
	if (this.guistate == GuiState.CRAFTING_RECIPES) {
		if (eKey == this.getKey(50)) {
			this.guiStateBackToGame();
		}
	}
	if (this.guistate == GuiState.NORMAL) {
		if (eKey == this.getKey(50)) {
			this.escapeMenuStart();
			return;
		}
	}
}

Game.prototype.keyPress = function(eKeyChar) {
	for (var i = 0; i < this.clientmodsCount; i++) {
		if (this.clientmods[i] == null) {
			continue;
		}
		var args_ = new KeyPressEventArgs();
		args_.setKeyChar(eKeyChar);
		this.clientmods[i].onKeyPress(this, args_);
		if (args_.getHandled()) {
			return;
		}
	}
}

Game.prototype.keyUp = function(eKey) {
	this.keyboardStateRaw[eKey] = false;
	for (var i = 0; i < this.clientmodsCount; i++) {
		var args_ = new KeyEventArgs();
		args_.setKeyCode(eKey);
		this.clientmods[i].onKeyUp(this, args_);
		if (args_.getHandled()) {
			return;
		}
	}
	this.keyboardState[eKey] = false;
	if (eKey == this.getKey(1) || eKey == this.getKey(2)) {
		this.isShiftPressed = false;
	}
}

Game.prototype.lavaSwimmingCamera = function() {
	return this.isLava(this.getCameraBlock());
}

Game.prototype.length = function(x, y, z) {
	return this.platform.mathSqrt(x * x + y * y + z * z);
}

Game.prototype.log = function(p) {
	this.addChatline(p);
}

Game.prototype.mainThreadOnRenderFrame = function(deltaTime) {
	this.updateResize();
	if (this.guistate == GuiState.MAP_LOADING) {
		this.platform.glClearColorRgbaf(0, 0, 0, 1);
	}
	else {
		this.platform.glClearColorRgbaf((this.one * 0) / (255), (this.one * 0) / (255), (this.one * 0) / (255), (this.one * 255) / (255));
	}
	this.mouseSmoothingAccum += deltaTime;
	var constMouseDt = 1 / (300);
	while (this.mouseSmoothingAccum > constMouseDt) {
		this.mouseSmoothingAccum -= constMouseDt;
		this.updateMouseViewportControl(constMouseDt);
	}
	this.platform.applicationDoEvents();
	this.accumulator += deltaTime;
	if (this.accumulator > 1) {
		this.accumulator = 1;
	}
	var dt = this.one / (75);
	while (this.accumulator >= dt) {
		this.frameTick(dt);
		this.accumulator -= dt;
	}
	if (this.guistate == GuiState.MAP_LOADING) {
		this.gotoDraw2d(deltaTime);
		return;
	}
	if (this.eNABLE_LAG == 2) {
		this.platform.threadSpinWait(20000000);
	}
	this.setAmbientLight(this.terraincolor());
	this.platform.glClearColorBufferAndDepthBuffer();
	this.platform.bindTexture2d(this.d_TerrainTextures.terrainTexture());
	for (var i = 0; i < this.clientmodsCount; i++) {
		if (this.clientmods[i] == null) {
			continue;
		}
		this.clientmods[i].onBeforeNewFrameDraw3d(this, deltaTime);
	}
	this.gLMatrixModeModelView();
	this.gLLoadMatrix(this.camera);
	this.cameraMatrix.lastmvmatrix = this.camera;
	this.d_FrustumCulling.calcFrustumEquations();
	var drawgame = this.guistate != GuiState.MAP_LOADING;
	if (drawgame) {
		this.platform.glEnableDepthTest();
		for (var i = 0; i < this.clientmodsCount; i++) {
			if (this.clientmods[i] == null) {
				continue;
			}
			this.clientmods[i].onNewFrameDraw3d(this, deltaTime);
		}
	}
	this.gotoDraw2d(deltaTime);
}

Game.prototype.makeTextTexture = function(t) {
	var ct = new CachedTexture();
	var bmp = this.textColorRenderer.createTextTexture(t);
	ct.sizeX = this.platform.bitmapGetWidth(bmp);
	ct.sizeY = this.platform.bitmapGetHeight(bmp);
	ct.textureId = this.platform.loadTextureFromBitmap(bmp);
	this.platform.bitmapDelete(bmp);
	return ct;
}

Game.prototype.mapLoaded = function() {
	this.redrawAllBlocks();
	this.materialSlots = this.d_Data.defaultMaterialSlots();
	this.guiStateBackToGame();
	this.playerPositionSpawnX = this.player.position.x;
	this.playerPositionSpawnY = this.player.position.y;
	this.playerPositionSpawnZ = this.player.position.z;
}

Game.prototype.mapLoadingStart = function() {
	this.guistate = GuiState.MAP_LOADING;
	this.setFreeMouse(true);
	this.maploadingprogress = new MapLoadingProgressEventArgs();
	this.fontMapLoading = FontCi.create("Arial", 14, 0);
}

Game.prototype.materialSlots_ = function(i) {
	var item = this.d_Inventory.rightHand[i];
	var m = this.d_Data.blockIdDirt();
	if (item != null && item.itemClass == 0) {
		m = this.d_Inventory.rightHand[i].blockId;
	}
	return m;
}

Game.prototype.mathFloor = function(a) {
	if (a >= 0) {
		return this.platform.floatToInt(a);
	}
	else {
		return this.platform.floatToInt(a) - 1;
	}
}

Game.prototype.mouseDown = function(args) {
	if (args.getButton() == 0) {
		this.mouseLeft = true;
	}
	if (args.getButton() == 1) {
		this.mouseMiddle = true;
	}
	if (args.getButton() == 2) {
		this.mouseRight = true;
	}
	if (args.getButton() == 0) {
		this.mouseleftclick = true;
	}
	if (args.getButton() == 2) {
		this.mouserightclick = true;
	}
	for (var i = 0; i < this.clientmodsCount; i++) {
		if (this.clientmods[i] == null) {
			continue;
		}
		this.clientmods[i].onMouseDown(this, args);
	}
	if (this.mousePointerLockShouldBe) {
		this.platform.requestMousePointerLock();
		this.mouseDeltaX = 0;
		this.mouseDeltaY = 0;
	}
	this.invalidVersionAllow();
}

Game.prototype.mouseMove = function(e) {
	if (!e.getEmulated() || e.getForceUsage()) {
		this.mouseCurrentX = e.getX();
		this.mouseCurrentY = e.getY();
	}
	if (e.getEmulated() || e.getForceUsage()) {
		this.mouseDeltaX += e.getMovementX();
		this.mouseDeltaY += e.getMovementY();
	}
	for (var i = 0; i < this.clientmodsCount; i++) {
		if (this.clientmods[i] == null) {
			continue;
		}
		this.clientmods[i].onMouseMove(this, e);
	}
}

Game.prototype.mouseUp = function(args) {
	if (args.getButton() == 0) {
		this.mouseLeft = false;
	}
	if (args.getButton() == 1) {
		this.mouseMiddle = false;
	}
	if (args.getButton() == 2) {
		this.mouseRight = false;
	}
	if (args.getButton() == 0) {
		this.mouseleftdeclick = true;
	}
	if (args.getButton() == 2) {
		this.mouserightdeclick = true;
	}
	for (var i = 0; i < this.clientmodsCount; i++) {
		if (this.clientmods[i] == null) {
			continue;
		}
		this.clientmods[i].onMouseUp(this, args);
	}
}

Game.prototype.mouseWheelChanged = function(e) {
	var eDeltaPrecise = e.getDeltaPrecise();
	if (this.keyboardState[this.getKey(1)]) {
		if (this.cameratype == CameraType.OVERHEAD) {
			this.overheadcameradistance -= eDeltaPrecise;
			if (this.overheadcameradistance < this.tPP_CAMERA_DISTANCE_MIN) {
				this.overheadcameradistance = this.tPP_CAMERA_DISTANCE_MIN;
			}
			if (this.overheadcameradistance > this.tPP_CAMERA_DISTANCE_MAX) {
				this.overheadcameradistance = this.tPP_CAMERA_DISTANCE_MAX;
			}
		}
		if (this.cameratype == CameraType.TPP) {
			this.tppcameradistance -= eDeltaPrecise;
			if (this.tppcameradistance < this.tPP_CAMERA_DISTANCE_MIN) {
				this.tppcameradistance = this.tPP_CAMERA_DISTANCE_MIN;
			}
			if (this.tppcameradistance > this.tPP_CAMERA_DISTANCE_MAX) {
				this.tppcameradistance = this.tPP_CAMERA_DISTANCE_MAX;
			}
		}
	}
	for (var i = 0; i < this.clientmodsCount; i++) {
		if (this.clientmods[i] == null) {
			continue;
		}
		this.clientmods[i].onMouseWheelChanged(this, e);
	}
}

Game.prototype.moveSpeedNow = function() {
	var movespeednow = this.movespeed;
	{
		var blockunderplayer = this.blockUnderPlayer();
		if (blockunderplayer != -1) {
			var floorSpeed = this.d_Data.walkSpeed()[blockunderplayer];
			if (floorSpeed != 0) {
				movespeednow *= floorSpeed;
			}
		}
	}
	if (this.keyboardState[this.getKey(1)]) {
		movespeednow *= (this.one * 2) / (10);
	}
	var item = this.d_Inventory.rightHand[this.activeMaterial];
	if (item != null && item.itemClass == 0) {
		var itemSpeed = this.deserializeFloat(this.blocktypes[item.blockId].walkSpeedWhenUsedFloat);
		if (itemSpeed != 0) {
			movespeednow *= itemSpeed;
		}
		if (this.ironSights) {
			var ironSightsSpeed = this.deserializeFloat(this.blocktypes[item.blockId].ironSightsMoveSpeedFloat);
			if (ironSightsSpeed != 0) {
				movespeednow *= ironSightsSpeed;
			}
		}
	}
	return movespeednow;
}

Game.prototype.moveToInventory = function(from) {
	this.sendPacketClient(ClientPackets.moveToInventory(from));
}

Game.prototype.nearest = function(pick2, pick2Count, x, y, z) {
	var minDist = 1000000;
	var nearest = null;
	for (var i = 0; i < pick2Count; i++) {
		var dist = this.dist(pick2[i].blockPos[0], pick2[i].blockPos[1], pick2[i].blockPos[2], x, y, z);
		if (dist < minDist) {
			minDist = dist;
			nearest = pick2[i];
		}
	}
	return nearest;
}

Game.prototype.nextFloat = function(min, max) {
	return this.rnd.nextFloat() * (max - min) + min;
}

Game.prototype.onBackPressed = function() {
}

Game.prototype.onFocusChanged = function() {
	if (this.guistate == GuiState.NORMAL) {
		this.escapeMenuStart();
	}
}

Game.prototype.onRenderFrame = function(deltaTime) {
	this.taskScheduler.update(this, deltaTime);
}

Game.prototype.onResize = function() {
	this.platform.glViewport(0, 0, this.width(), this.height());
	this.set3dProjection2();
	if (this.sendResize) {
		this.sendGameResolution();
	}
}

Game.prototype.onTouchEnd = function(e) {
	this.mouseCurrentX = 0;
	this.mouseCurrentY = 0;
	for (var i = 0; i < this.clientmodsCount; i++) {
		if (this.clientmods[i] == null) {
			continue;
		}
		this.clientmods[i].onTouchEnd(this, e);
		if (e.getHandled()) {
			return;
		}
	}
}

Game.prototype.onTouchMove = function(e) {
	for (var i = 0; i < this.clientmodsCount; i++) {
		if (this.clientmods[i] == null) {
			continue;
		}
		this.clientmods[i].onTouchMove(this, e);
		if (e.getHandled()) {
			return;
		}
	}
}

Game.prototype.onTouchStart = function(e) {
	this.invalidVersionAllow();
	this.mouseCurrentX = e.getX();
	this.mouseCurrentY = e.getY();
	this.mouseleftclick = true;
	for (var i = 0; i < this.clientmodsCount; i++) {
		if (this.clientmods[i] == null) {
			continue;
		}
		this.clientmods[i].onTouchStart(this, e);
		if (e.getHandled()) {
			return;
		}
	}
}

Game.prototype.orthoMode = function(width, height) {
	this.gLMatrixModeProjection();
	this.gLPushMatrix();
	this.gLLoadIdentity();
	this.gLOrtho(0, width, height, 0, 0, 1);
	this.setMatrixUniformProjection();
	this.gLMatrixModeModelView();
	this.gLPushMatrix();
	this.gLLoadIdentity();
	this.setMatrixUniformModelView();
}

Game.prototype.perspectiveMode = function() {
	this.gLMatrixModeProjection();
	this.gLPopMatrix();
	this.setMatrixUniformProjection();
	this.gLMatrixModeModelView();
	this.gLPopMatrix();
	this.setMatrixUniformModelView();
}

Game.prototype.pick = function(s_, line, retCount) {
	var minX = this.platform.floatToInt(MathCi.minFloat(line.start[0], line.end[0]));
	var minY = this.platform.floatToInt(MathCi.minFloat(line.start[1], line.end[1]));
	var minZ = this.platform.floatToInt(MathCi.minFloat(line.start[2], line.end[2]));
	if (minX < 0) {
		minX = 0;
	}
	if (minY < 0) {
		minY = 0;
	}
	if (minZ < 0) {
		minZ = 0;
	}
	var maxX = this.platform.floatToInt(MathCi.maxFloat(line.start[0], line.end[0]));
	var maxY = this.platform.floatToInt(MathCi.maxFloat(line.start[1], line.end[1]));
	var maxZ = this.platform.floatToInt(MathCi.maxFloat(line.start[2], line.end[2]));
	if (maxX > this.map.mapSizeX) {
		maxX = this.map.mapSizeX;
	}
	if (maxY > this.map.mapSizeZ) {
		maxY = this.map.mapSizeZ;
	}
	if (maxZ > this.map.mapSizeY) {
		maxZ = this.map.mapSizeY;
	}
	var sizex = maxX - minX + 1;
	var sizey = maxY - minY + 1;
	var sizez = maxZ - minZ + 1;
	var size = BitTools.nextPowerOfTwo(MathCi.maxInt(sizex, MathCi.maxInt(sizey, sizez)));
	s_.startBox = Box3D.create(minX, minY, minZ, size);
	var pick2 = s_.lineIntersection(IsBlockEmpty_.create(this), GetBlockHeight_.create(this), line, retCount);
	this.pickSort(pick2, retCount.value, line.start[0], line.start[1], line.start[2]);
	return pick2;
}

Game.prototype.pickSort = function(pick, pickCount, x, y, z) {
	var changed = false;
	do {
		changed = false;
		for (var i = 0; i < pickCount - 1; i++) {
			var dist = this.dist(pick[i].blockPos[0], pick[i].blockPos[1], pick[i].blockPos[2], x, y, z);
			var distNext = this.dist(pick[i + 1].blockPos[0], pick[i + 1].blockPos[1], pick[i + 1].blockPos[2], x, y, z);
			if (dist > distNext) {
				changed = true;
				var swapTemp = pick[i];
				pick[i] = pick[i + 1];
				pick[i + 1] = swapTemp;
			}
		}
	}
	while (changed);
}

Game.prototype.playSoundAt = function(name, x, y, z) {
	if (x == 0 && y == 0 && z == 0) {
		this.audioPlay(name);
	}
	else {
		this.audioPlayAt(name, x, z, y);
	}
}

Game.prototype.processServerIdentification = function(packet) {
	this.localPlayerId = packet.identification.assignedClientId;
	this.serverInfo.connectdata = this.connectdata;
	this.serverInfo.serverName = packet.identification.serverName;
	this.serverInfo.serverMotd = packet.identification.serverMotd;
	this.d_TerrainChunkTesselator.eNABLE_TEXTURE_TILING = packet.identification.renderHint_ == 0;
	var requiredMd5 = packet.identification.requiredBlobMd5;
	var requiredName = packet.identification.requiredBlobName;
	this.chatLog("[GAME] Processed server identification");
	var getCount = 0;
	if (requiredMd5 != null) {
		this.chatLog(this.platform.stringFormat("[GAME] Server has {0} assets", this.platform.intToString(requiredMd5.itemsCount)));
		for (var i = 0; i < requiredMd5.itemsCount; i++) {
			var md5 = requiredMd5.items[i];
			if (this.platform.isCached(md5)) {
				var cachedAsset = this.platform.loadAssetFromCache(md5);
				var name;
				if (requiredName != null) {
					name = requiredName.items[i];
				}
				else {
					name = cachedAsset.name;
				}
				this.setFile(name, cachedAsset.md5, cachedAsset.data, cachedAsset.dataLength);
			}
			else {
				if (requiredName != null) {
					if (!this.hasAsset(md5, requiredName.items[i])) {
						this.getAsset[getCount++] = md5;
					}
				}
				else {
					this.getAsset[getCount++] = md5;
				}
			}
		}
		this.chatLog(this.platform.stringFormat("[GAME] Will download {0} missing assets", this.platform.intToString(getCount)));
	}
	this.sendGameResolution();
	this.chatLog("[GAME] Sent window resolution to server");
	this.sendResize = true;
	this.sendRequestBlob(this.getAsset, getCount);
	this.chatLog("[GAME] Sent BLOB request");
	if (packet.identification.mapSizeX != this.map.mapSizeX || packet.identification.mapSizeY != this.map.mapSizeY || packet.identification.mapSizeZ != this.map.mapSizeZ) {
		this.map.reset(packet.identification.mapSizeX, packet.identification.mapSizeY, packet.identification.mapSizeZ);
		this.d_Heightmap.restart();
	}
	this.shadowssimple = packet.identification.disableShadows == 1 ? true : false;
	this.maxdrawdistance = 256;
	this.chatLog("[GAME] Map initialized");
}

Game.prototype.queueActionCommit = function(action) {
	this.commitActions.add(action);
}

Game.radToAngle256 = function(value) {
	return value / (2 * Game.getPi()) * 255;
}

Game.prototype.reconnect = function() {
	this.reconnect = true;
}

Game.prototype.redrawAllBlocks = function() {
	this.shouldRedrawAllBlocks = true;
}

Game.prototype.redrawBlock = function(x, y, z) {
	this.map.setBlockDirty(x, y, z);
}

Game.prototype.respawn = function() {
	this.sendPacketClient(ClientPackets.specialKeyRespawn());
	this.stopPlayerMove = true;
}

Game.prototype.revertSpeculative = function(dt) {
	for (var i = 0; i < this.speculativeCount; i++) {
		var s_ = this.speculative[i];
		if (s_ == null) {
			continue;
		}
		if ((this.one * (this.platform.timeMillisecondsFromStart() - s_.timeMilliseconds)) / (1000) > 2) {
			this.redrawBlock(s_.x, s_.y, s_.z);
			this.speculative[i] = null;
		}
	}
}

Game.prototype.scale = function() {
	if (this.platform.isSmallScreen()) {
		var scale = (this.one * this.width()) / (1280);
		return scale;
	}
	else {
		return this.one;
	}
}

Game.prototype.sendChat = function(s) {
	this.sendPacketClient(ClientPackets.chat(s, this.isTeamchat ? 1 : 0));
}

Game.prototype.sendFillArea = function(startx, starty, startz, endx, endy, endz, blockType) {
	this.sendPacketClient(ClientPackets.fillArea(startx, starty, startz, endx, endy, endz, blockType, this.activeMaterial));
}

Game.prototype.sendGameResolution = function() {
	this.sendPacketClient(ClientPackets.gameResolution(this.width(), this.height()));
}

Game.prototype.sendLeave = function(reason) {
	this.sendPacketClient(ClientPackets.leave(reason));
}

Game.prototype.sendPacket = function(packet, packetLength) {
	var msg = new INetOutgoingMessage();
	msg.write(packet, packetLength);
	this.main.sendMessage(msg, MyNetDeliveryMethod.RELIABLE_ORDERED);
}

Game.prototype.sendPacketClient = function(packetClient) {
	var packet = this.serialize(packetClient, this.packetLen);
	this.sendPacket(packet, this.packetLen.value);
}

Game.prototype.sendPingReply = function() {
	this.sendPacketClient(ClientPackets.pingReply());
}

Game.prototype.sendRequestBlob = function(required, requiredCount) {
	this.sendPacketClient(ClientPackets.requestBlob(this, required, requiredCount));
}

Game.prototype.sendSetBlock = function(x, y, z, mode, type, materialslot) {
	this.sendPacketClient(ClientPackets.setBlock(x, y, z, mode, type, materialslot));
}

Game.prototype.sendSetBlockAndUpdateSpeculative = function(material, x, y, z, mode) {
	this.sendSetBlock(x, y, z, mode, material, this.activeMaterial);
	var item = this.d_Inventory.rightHand[this.activeMaterial];
	if (item != null && item.itemClass == 0) {
		var blockid = material;
		if (mode == 0) {
			blockid = 0;
		}
		var s_ = new Speculative();
		s_.x = x;
		s_.y = y;
		s_.z = z;
		s_.blocktype = this.map.getBlock(x, y, z);
		s_.timeMilliseconds = this.platform.timeMillisecondsFromStart();
		this.addSpeculative(s_);
		this.setBlock(x, y, z, blockid);
		this.redrawBlock(x, y, z);
	}
	else {
	}
}

Game.prototype.serialize = function(packet, retLength) {
	var ms = new CitoMemoryStream();
	Packet_ClientSerializer.serialize(ms, packet);
	var data = ms.toArray();
	retLength.value = ms.length();
	return data;
}

Game.prototype.serializeFloat = function(p) {
	return this.platform.floatToInt(p * 32);
}

Game.prototype.set3dProjection = function(zfar, fov) {
	var aspect_ratio = (this.one * this.width()) / (this.height());
	Mat4.perspective(this.set3dProjectionTempMat4, fov, aspect_ratio, this.znear, zfar);
	this.cameraMatrix.lastpmatrix = this.set3dProjectionTempMat4;
	this.gLMatrixModeProjection();
	this.gLLoadMatrix(this.set3dProjectionTempMat4);
	this.setMatrixUniformProjection();
}

Game.prototype.set3dProjection1 = function(zfar_) {
	this.set3dProjection(zfar_, this.currentfov());
}

Game.prototype.set3dProjection2 = function() {
	this.set3dProjection1(this.zfar());
}

Game.prototype.setAmbientLight = function(color) {
	var r = Game.colorR(color);
	var g = Game.colorG(color);
	var b = Game.colorB(color);
	this.platform.glLightModelAmbient(r, g, b);
}

Game.prototype.setBlock = function(x, y, z, tileType) {
	this.map.setBlockRaw(x, y, z, tileType);
	this.map.setChunkDirty(Math.floor(x / 16), Math.floor(y / 16), Math.floor(z / 16), true, true);
	this.shadowsOnSetBlock(x, y, z);
	this.lastplacedblockX = x;
	this.lastplacedblockY = y;
	this.lastplacedblockZ = z;
}

Game.prototype.setCamera = function(type) {
	if (type == CameraType.FPP) {
		this.cameratype = CameraType.FPP;
		this.setFreeMouse(false);
		this.eNABLE_TPP_VIEW = false;
		this.overheadcamera = false;
	}
	else if (type == CameraType.TPP) {
		this.cameratype = CameraType.TPP;
		this.eNABLE_TPP_VIEW = true;
	}
	else {
		this.cameratype = CameraType.OVERHEAD;
		this.overheadcamera = true;
		this.setFreeMouse(true);
		this.eNABLE_TPP_VIEW = true;
		this.playerdestination = Vector3Ref.create(this.player.position.x, this.player.position.y, this.player.position.z);
	}
}

Game.prototype.setCharacterEyesHeight = function(value) {
	this.entities[this.localPlayerId].drawModel.eyeHeight = value;
}

Game.prototype.setFile = function(name, md5, downloaded, downloadedLength) {
	var nameLowercase = this.platform.stringToLower(name);
	if (nameLowercase == "mousecursor.png") {
		this.platform.setWindowCursor(0, 0, 32, 32, downloaded, downloadedLength);
	}
	var newAsset = new Asset();
	newAsset.data = downloaded;
	newAsset.dataLength = downloadedLength;
	newAsset.name = nameLowercase;
	newAsset.md5 = md5;
	for (var i = 0; i < this.assets.count; i++) {
		if (this.assets.items[i] == null) {
			continue;
		}
		if (this.assets.items[i].name == nameLowercase) {
			if (this.options.useServerTextures) {
				this.assets.items[i] = newAsset;
			}
			this.cacheAsset(newAsset);
			return;
		}
	}
	this.assets.items[this.assets.count++] = newAsset;
	this.cacheAsset(newAsset);
}

Game.prototype.setFog = function() {
	if (this.d_Config3d.viewdistance >= 512) {
		return;
	}
	var density = (this.one * 25) / (10000);
	var fogR;
	var fogG;
	var fogB;
	var fogA;
	if (this.skySphereNight && !this.shadowssimple) {
		fogR = 0;
		fogG = 0;
		fogB = 0;
		fogA = 255;
	}
	else {
		fogR = 0;
		fogG = 0;
		fogB = 0;
		fogA = 255;
	}
	this.platform.glEnableFog();
	this.platform.glHintFogHintNicest();
	this.platform.glFogFogModeExp2();
	this.platform.glFogFogColor(fogR, fogG, fogB, fogA);
	this.platform.glFogFogDensity(density);
}

Game.prototype.setFreeMouse = function(value) {
	this.mousePointerLockShouldBe = !value;
	if (value) {
		this.platform.exitMousePointerLock();
	}
	else {
		this.platform.requestMousePointerLock();
	}
}

Game.prototype.setMatrixUniformModelView = function() {
	this.platform.setMatrixUniformModelView(this.mvMatrix.peek());
}

Game.prototype.setMatrixUniformProjection = function() {
	this.platform.setMatrixUniformProjection(this.pMatrix.peek());
}

Game.prototype.setMatrixUniforms = function() {
	this.platform.setMatrixUniformProjection(this.pMatrix.peek());
	this.platform.setMatrixUniformModelView(this.mvMatrix.peek());
}

Game.prototype.setPlatform = function(value) {
	this.platform = value;
}

Game.prototype.setTileAndUpdate = function(x, y, z, type) {
	this.setBlock(x, y, z, type);
	this.redrawBlock(x, y, z);
}

Game.prototype.shadowsOnSetBlock = function(x, y, z) {
	var oldheight = this.d_Heightmap.getBlock(x, y);
	this.updateColumnHeight(x, y);
	var newheight = this.d_Heightmap.getBlock(x, y);
	var min = MathCi.minInt(oldheight, newheight);
	var max = MathCi.maxInt(oldheight, newheight);
	for (var i = min; i < max; i++) {
		if (Math.floor(i / 16) != Math.floor(z / 16)) {
			this.map.setChunkDirty(Math.floor(x / 16), Math.floor(y / 16), Math.floor(i / 16), true, true);
		}
	}
	for (var xx = 0; xx < 3; xx++) {
		for (var yy = 0; yy < 3; yy++) {
			for (var zz = 0; zz < 3; zz++) {
				var cx = Math.floor(x / 16) + xx - 1;
				var cy = Math.floor(y / 16) + yy - 1;
				var cz = Math.floor(z / 16) + zz - 1;
				if (this.map.isValidChunkPos(cx, cy, cz)) {
					this.map.setChunkDirty(cx, cy, cz, true, false);
				}
			}
		}
	}
}

Game.prototype.showEscapeMenu = function() {
	this.guistate = GuiState.ESCAPE_MENU;
	this.menustate = new MenuState();
	this.setFreeMouse(true);
}

Game.prototype.showInventory = function() {
	this.guistate = GuiState.INVENTORY;
	this.menustate = new MenuState();
	this.setFreeMouse(true);
}

Game.prototype.start = function() {
	this.textColorRenderer = new TextColorRenderer();
	this.textColorRenderer.platform = this.platform;
	this.language.platform = this.platform;
	this.language.loadTranslations();
	var gamedata = new GameData();
	gamedata.start();
	var config3d = new Config3d();
	if (this.platform.isFastSystem()) {
		config3d.viewdistance = 128;
	}
	else {
		config3d.viewdistance = 32;
	}
	var terrainTextures = new ITerrainTextures();
	terrainTextures.game = this;
	this.d_TextureAtlasConverter = new TextureAtlasConverter();
	this.d_TerrainTextures = terrainTextures;
	var frustumculling = new FrustumCulling();
	frustumculling.d_GetCameraMatrix = this.cameraMatrix;
	frustumculling.platform = this.platform;
	this.d_FrustumCulling = frustumculling;
	var terrainchunktesselator = new TerrainChunkTesselatorCi();
	this.d_TerrainChunkTesselator = terrainchunktesselator;
	this.d_Batcher = new MeshBatcher();
	this.d_Batcher.d_FrustumCulling = frustumculling;
	this.d_Batcher.game = this;
	this.d_FrustumCulling = frustumculling;
	this.d_Data = gamedata;
	this.d_DataMonsters = new GameDataMonsters();
	this.d_Config3d = config3d;
	var particle = new ModDrawParticleEffectBlockBreak();
	this.particleEffectBlockBreak = particle;
	this.d_Data = gamedata;
	this.d_TerrainTextures = terrainTextures;
	this.map.reset(256, 256, 128);
	var sunmoonrenderer = new SunMoonRenderer();
	this.d_SunMoonRenderer = sunmoonrenderer;
	this.d_SunMoonRenderer = sunmoonrenderer;
	this.d_Heightmap = new InfiniteMapChunked2d();
	this.d_Heightmap.d_Map = this;
	this.d_Heightmap.restart();
	this.d_TerrainChunkTesselator = terrainchunktesselator;
	terrainchunktesselator.game = this;
	var inventory = new Packet_Inventory();
	inventory.rightHand = new Array(10);
	var dataItems = new GameDataItemsClient();
	dataItems.game = this;
	var inventoryUtil = new InventoryUtilClient();
	this.d_Inventory = inventory;
	this.d_InventoryUtil = inventoryUtil;
	inventoryUtil.d_Inventory = inventory;
	inventoryUtil.d_Items = dataItems;
	this.d_Inventory = inventory;
	this.platform.addOnCrash(OnCrashHandlerLeave.create(this));
	this.rnd = this.platform.randomCreate();
	this.clientmods = new Array(128);
	this.clientmodsCount = 0;
	this.modmanager.game = this;
	this.addMod(new ModDrawMain());
	this.addMod(new ModUpdateMain());
	this.addMod(new ModNetworkProcess());
	this.addMod(new ModUnloadRendererChunks());
	this.addMod(new ModAutoCamera());
	this.addMod(new ModFpsHistoryGraph());
	this.addMod(new ModWalkSound());
	this.addMod(new ModFallDamageToPlayer());
	this.addMod(new ModBlockDamageToPlayer());
	this.addMod(new ModLoadPlayerTextures());
	this.addMod(new ModSendPosition());
	this.addMod(new ModInterpolatePositions());
	this.addMod(new ModRail());
	this.addMod(new ModCompass());
	this.addMod(new ModGrenade());
	this.addMod(new ModBullet());
	this.addMod(new ModExpire());
	this.addMod(new ModReloadAmmo());
	this.addMod(new ModPush());
	if (this.platform.isFastSystem()) {
		this.addMod(new ModSkySphereAnimated());
	}
	else {
		this.addMod(new ModSkySphereStatic());
	}
	this.addMod(sunmoonrenderer);
	this.addMod(new ModDrawTestModel());
	this.addMod(new ModDrawLinesAroundSelectedBlock());
	this.addMod(new ModDebugChunk());
	this.addMod(new ModDrawArea());
	this.addMod(new ModDrawTerrain());
	this.addMod(new ModDrawPlayers());
	this.addMod(new ModDrawPlayerNames());
	this.addMod(new ModDrawText());
	this.addMod(new ModDrawParticleEffectBlockBreak());
	this.addMod(new ModDrawSprites());
	this.addMod(new ModDrawMinecarts());
	this.addMod(new ModDrawHand2d());
	this.addMod(new ModDrawHand3d());
	this.addMod(new ModGuiCrafting());
	this.addMod(new ModDialog());
	this.addMod(new ModPicking());
	this.addMod(new ModClearInactivePlayersDrawInfo());
	this.addMod(new ModCameraKeys());
	this.addMod(new ModSendActiveMaterial());
	this.addMod(new ModCamera());
	this.addMod(new ModNetworkEntity());
	this.addMod(new ModGuiInventory());
	this.addMod(new ModGuiTouchButtons());
	this.addMod(new ModGuiEscapeMenu());
	this.addMod(new ModGuiMapLoading());
	this.addMod(new ModDraw2dMisc());
	this.addMod(new ModGuiPlayerStats());
	this.addMod(new ModGuiChat());
	this.addMod(new ModScreenshot());
	this.addMod(new ModAudio());
	this.s = new BlockOctreeSearcher();
	this.s.platform = this.platform;
	this.lastReceivedMilliseconds = this.platform.timeMillisecondsFromStart();
	this.eNABLE_DRAW_TEST_CHARACTER = this.platform.isDebuggerAttached();
	var maxTextureSize_ = this.platform.glGetMaxTextureSize();
	if (maxTextureSize_ < 1024) {
		maxTextureSize_ = 1024;
	}
	this.maxTextureSize = maxTextureSize_;
	this.mapLoadingStart();
	this.platform.glClearColorRgbaf(0, 0, 0, 1);
	if (this.d_Config3d.eNABLE_BACKFACECULLING) {
		this.platform.glDepthMask(true);
		this.platform.glEnableDepthTest();
		this.platform.glCullFaceBack();
		this.platform.glEnableCullFace();
	}
	this.platform.glEnableLighting();
	this.platform.glEnableColorMaterial();
	this.platform.glColorMaterialFrontAndBackAmbientAndDiffuse();
	this.platform.glShadeModelSmooth();
}

Game.prototype.startTyping = function() {
	this.guiTyping = TypingState.TYPING;
	this.isTyping = true;
	this.guiTypingBuffer = "";
	this.isTeamchat = false;
}

Game.prototype.stopTyping = function() {
	this.guiTyping = TypingState.NONE;
}

Game.stringEquals = function(strA, strB) {
	if (strA == null && strB == null) {
		return true;
	}
	if (strA == null || strB == null) {
		return false;
	}
	return strA == strB;
}

Game.prototype.swimmingBody = function() {
	var block = this.map.getBlock(this.platform.floatToInt(this.player.position.x), this.platform.floatToInt(this.player.position.z), this.platform.floatToInt(this.player.position.y + 1));
	if (block == -1) {
		return true;
	}
	return this.d_Data.walkableType1()[block] == 1;
}

Game.prototype.swimmingEyes = function() {
	var eyesBlock = this.getPlayerEyesBlock();
	if (eyesBlock == -1) {
		return true;
	}
	return this.d_Data.walkableType1()[eyesBlock] == 1;
}

Game.prototype.textSizeHeight = function(s, font) {
	var width = new IntRef();
	var height = new IntRef();
	this.platform.textSize(s, font, width, height);
	return height.value;
}

Game.prototype.textSizeWidth = function(s, font) {
	var width = new IntRef();
	var height = new IntRef();
	this.platform.textSize(s, font, width, height);
	return width.value;
}

Game.prototype.toggleFog = function() {
	var drawDistances = new Int32Array(new ArrayBuffer(10 << 2));
	var drawDistancesCount = 0;
	drawDistances[drawDistancesCount++] = 32;
	if (this.maxdrawdistance >= 64) {
		drawDistances[drawDistancesCount++] = 64;
	}
	if (this.maxdrawdistance >= 128) {
		drawDistances[drawDistancesCount++] = 128;
	}
	if (this.maxdrawdistance >= 256) {
		drawDistances[drawDistancesCount++] = 256;
	}
	if (this.maxdrawdistance >= 512) {
		drawDistances[drawDistancesCount++] = 512;
	}
	for (var i = 0; i < drawDistancesCount; i++) {
		if (this.d_Config3d.viewdistance == drawDistances[i]) {
			this.d_Config3d.viewdistance = drawDistances[(i + 1) % drawDistancesCount];
			this.redrawAllBlocks();
			return;
		}
	}
	this.d_Config3d.viewdistance = drawDistances[0];
	this.redrawAllBlocks();
}

Game.prototype.toggleVsync = function() {
	this.eNABLE_LAG++;
	this.eNABLE_LAG = this.eNABLE_LAG % 3;
	this.useVsync();
}

Game.prototype.update = function(dt) {
	for (var i = 0; i < this.clientmodsCount; i++) {
		if (this.clientmods[i] == null) {
			continue;
		}
		this.clientmods[i].onNewFrameReadOnlyMainThread(this, dt);
	}
}

Game.prototype.updateColumnHeight = function(x, y) {
	var height = this.map.mapSizeZ - 1;
	for (var i = this.map.mapSizeZ - 1; i >= 0; i--) {
		height = i;
		if (!Game.isTransparentForLight(this.blocktypes[this.map.getBlock(x, y, i)])) {
			break;
		}
	}
	this.d_Heightmap.setBlock(x, y, height);
}

Game.prototype.updateMouseViewportControl = function(dt) {
	if (this.mouseSmoothing) {
		var constMouseSmoothing1 = 0.85;
		var constMouseSmoothing2 = 0.8;
		this.mouseSmoothingVelX = this.mouseSmoothingVelX + this.mouseDeltaX / (4) * constMouseSmoothing2;
		this.mouseSmoothingVelY = this.mouseSmoothingVelY + this.mouseDeltaY / (4) * constMouseSmoothing2;
		this.mouseSmoothingVelX = this.mouseSmoothingVelX * constMouseSmoothing1;
		this.mouseSmoothingVelY = this.mouseSmoothingVelY * constMouseSmoothing1;
	}
	else {
		this.mouseSmoothingVelX = this.mouseDeltaX;
		this.mouseSmoothingVelY = this.mouseDeltaY;
	}
	if (this.guistate == GuiState.NORMAL && this.enableCameraControl && this.platform.focused()) {
		if (!this.overheadcamera) {
			if (this.platform.isMousePointerLocked()) {
				this.player.position.roty += (this.mouseSmoothingVelX * this.rotationspeed * 1) / (75);
				this.player.position.rotx += (this.mouseSmoothingVelY * this.rotationspeed * 1) / (75);
				this.player.position.rotx = MathCi.clampFloat(this.player.position.rotx, Game.getPi() / (2) + (this.one * 15) / (1000), Game.getPi() / (2) + Game.getPi() - (this.one * 15) / (1000));
			}
			this.player.position.rotx += this.touchOrientationDy * this.constRotationSpeed * this.one / (75);
			this.player.position.roty += this.touchOrientationDx * this.constRotationSpeed * this.one / (75);
			this.touchOrientationDx = 0;
			this.touchOrientationDy = 0;
		}
		if (this.cameratype == CameraType.OVERHEAD) {
			if (this.mouseMiddle || this.mouseRight) {
				this.overheadcameraK.turnLeft(this.mouseDeltaX / (70));
				this.overheadcameraK.turnUp(this.mouseDeltaY / (3));
			}
		}
	}
	this.mouseDeltaX = 0;
	this.mouseDeltaY = 0;
}

Game.prototype.updateResize = function() {
	if (this.lastWidth != this.platform.getCanvasWidth() || this.lastHeight != this.platform.getCanvasHeight()) {
		this.lastWidth = this.platform.getCanvasWidth();
		this.lastHeight = this.platform.getCanvasHeight();
		this.onResize();
	}
}

Game.prototype.updateTextRendererFont = function() {
	this.platform.setTextRendererFont(this.font);
}

Game.prototype.useInventory = function(packet_Inventory) {
	this.d_Inventory = packet_Inventory;
	this.d_InventoryUtil.d_Inventory = packet_Inventory;
}

Game.prototype.useTerrainTextureAtlas2d = function(atlas2d, atlas2dWidth) {
	this.terrainTexture = this.platform.loadTextureFromBitmap(atlas2d);
	var terrainTextures1d_;
	var terrainTextures1dCount = 0;
	{
		this.terrainTexturesPerAtlas = Math.floor(this.atlas1dheight() / Math.floor(atlas2dWidth / this.atlas2dtiles()));
		var atlasesidCount = new IntRef();
		var atlases1d = this.d_TextureAtlasConverter.atlas2dInto1d(this.platform, atlas2d, this.atlas2dtiles(), this.atlas1dheight(), atlasesidCount);
		terrainTextures1d_ = new Int32Array(new ArrayBuffer(atlasesidCount.value << 2));
		for (var i = 0; i < atlasesidCount.value; i++) {
			var bmp = atlases1d[i];
			var texture = this.platform.loadTextureFromBitmap(bmp);
			terrainTextures1d_[terrainTextures1dCount++] = texture;
			this.platform.bitmapDelete(bmp);
		}
	}
	this.terrainTextures1d = terrainTextures1d_;
}

Game.prototype.useTerrainTextures = function(textureIds, textureIdsCount) {
	var tilesize = 32;
	var atlas2d = BitmapData_.create(tilesize * this.atlas2dtiles(), tilesize * this.atlas2dtiles());
	for (var i = 0; i < textureIdsCount; i++) {
		if (textureIds[i] == null) {
			continue;
		}
		var fileData = this.getFile(StringTools.stringAppend(this.platform, textureIds[i], ".png"));
		if (fileData == null) {
			fileData = this.getFile("Unknown.png");
		}
		if (fileData == null) {
			continue;
		}
		var bmp = this.platform.bitmapCreateFromPng(fileData, this.platform.byteArrayLength(fileData));
		if (this.platform.bitmapGetWidth(bmp) != tilesize) {
			this.platform.bitmapDelete(bmp);
			continue;
		}
		if (this.platform.bitmapGetHeight(bmp) != tilesize) {
			this.platform.bitmapDelete(bmp);
			continue;
		}
		var bmpPixels = new Int32Array(new ArrayBuffer(tilesize * tilesize << 2));
		this.platform.bitmapGetPixelsArgb(bmp, bmpPixels);
		var x = i % this.texturesPacked();
		var y = Math.floor(i / this.texturesPacked());
		for (var xx = 0; xx < tilesize; xx++) {
			for (var yy = 0; yy < tilesize; yy++) {
				var c = bmpPixels[xx + yy * tilesize];
				atlas2d.setPixel(x * tilesize + xx, y * tilesize + yy, c);
			}
		}
		this.platform.bitmapDelete(bmp);
	}
	var bitmap = this.platform.bitmapCreate(atlas2d.width, atlas2d.height);
	this.platform.bitmapSetPixelsArgb(bitmap, atlas2d.argb);
	this.useTerrainTextureAtlas2d(bitmap, atlas2d.width);
}

Game.prototype.useVsync = function() {
	this.platform.setVSync(this.eNABLE_LAG == 1 ? false : true);
}

Game.prototype.validFont = function(family) {
	for (var i = 0; i < this.allowedFontsCount; i++) {
		if (this.allowedFonts[i] == family) {
			return family;
		}
	}
	return this.allowedFonts[0];
}

Game.prototype.vec3Equal = function(ax, ay, az, bx, by, bz) {
	return ax == bx && ay == by && az == bz;
}

Game.prototype.vectorAngleGet = function(qX, qY, qZ) {
	return this.platform.mathAcos(qX / (this.length(qX, qY, qZ))) * MathCi.sign(qZ);
}

Game.prototype.waterLevel = function() {
	return Math.floor(this.map.mapSizeZ / 2);
}

Game.prototype.waterSwimmingCamera = function() {
	if (this.getCameraBlock() == -1) {
		return true;
	}
	return this.isWater(this.getCameraBlock());
}

Game.prototype.waterSwimmingEyes = function() {
	if (this.getPlayerEyesBlock() == -1) {
		return true;
	}
	return this.isWater(this.getPlayerEyesBlock());
}

Game.prototype.weaponAttackStrength = function() {
	return this.nextFloat(2, 4);
}

Game.prototype.wearItem = function(from, to) {
	this.sendPacketClient(ClientPackets.wearItem(from, to));
}

Game.prototype.whiteTexture = function() {
	if (this.whitetexture == -1) {
		var bmp = this.platform.bitmapCreate(1, 1);
		var pixels = new Int32Array(new ArrayBuffer(1 << 2));
		pixels[0] = Game.colorFromArgb(255, 255, 255, 255);
		this.platform.bitmapSetPixelsArgb(bmp, pixels);
		this.whitetexture = this.platform.loadTextureFromBitmap(bmp);
	}
	return this.whitetexture;
}

Game.prototype.width = function() {
	return this.platform.getCanvasWidth();
}

Game.prototype.atlas1dheight = function() {
	return this.maxTextureSize;
}

Game.prototype.atlas2dtiles = function() {
	return 32;
}

Game.prototype.blockheight = function(x, y, z_) {
	for (var z = z_; z >= 0; z--) {
		if (this.map.getBlock(x, y, z) != 0) {
			return z + 1;
		}
	}
	return 0;
}
Game.CLEARCOLOR_A = 255;
Game.CLEARCOLOR_B = 0;
Game.CLEARCOLOR_G = 0;
Game.CLEARCOLOR_R = 0;

Game.prototype.currentfov = function() {
	if (this.ironSights) {
		var item = this.d_Inventory.rightHand[this.activeMaterial];
		if (item != null && item.itemClass == 0) {
			if (this.deserializeFloat(this.blocktypes[item.blockId].ironSightsFovFloat) != 0) {
				return this.fov * this.deserializeFloat(this.blocktypes[item.blockId].ironSightsFovFloat);
			}
		}
	}
	return this.fov;
}
Game.ENTITY_LOCAL_ID_START = 256;
Game.ENTITY_MONSTER_ID_COUNT = 128;
Game.ENTITY_MONSTER_ID_START = 128;

Game.prototype.getblockheight = function(x, y, z) {
	var RailHeight = (this.one * 3) / (10);
	if (!this.map.isValidPos(x, y, z)) {
		return 1;
	}
	if (this.blocktypes[this.map.getBlock(x, y, z)].rail != 0) {
		return RailHeight;
	}
	if (this.blocktypes[this.map.getBlock(x, y, z)].drawType == 11) {
		return this.one / (2);
	}
	if (this.blocktypes[this.map.getBlock(x, y, z)].drawType == 12) {
		return this.one / (20);
	}
	return 1;
}
Game.MAXLIGHT = 15;
Game.MINLIGHT = 0;
Game.PLAYERTEXTUREDEFAULTFILENAME = "mineplayer.png";

Game.prototype.terraincolor = function() {
	if (this.waterSwimmingCamera()) {
		return Game.colorFromArgb(255, 78, 95, 140);
	}
	else if (this.lavaSwimmingCamera()) {
		return Game.colorFromArgb(255, 222, 101, 46);
	}
	else {
		return Game.colorFromArgb(255, 255, 255, 255);
	}
}

Game.prototype.texturesPacked = function() {
	return 32;
}

Game.prototype.xcenter = function(width) {
	return this.platform.floatToInt(Math.floor(this.platform.getCanvasWidth() / 2) - width / (2));
}

Game.prototype.ycenter = function(height) {
	return this.platform.floatToInt(Math.floor(this.platform.getCanvasHeight() / 2) - height / (2));
}

Game.prototype.zfar = function() {
	if (this.d_Config3d.viewdistance >= 256) {
		return this.d_Config3d.viewdistance * 2;
	}
	return this.eNABLE_ZFAR ? this.d_Config3d.viewdistance : 99999;
}

function GameData()
{
	this.mBlockIdAdminium = 0;
	this.mBlockIdCompass = 0;
	this.mBlockIdCraftingTable = 0;
	this.mBlockIdCuboid = 0;
	this.mBlockIdDirt = 0;
	this.mBlockIdEmpty = 0;
	this.mBlockIdEmptyHand = 0;
	this.mBlockIdFillArea = 0;
	this.mBlockIdFillStart = 0;
	this.mBlockIdLadder = 0;
	this.mBlockIdLava = 0;
	this.mBlockIdMinecart = 0;
	this.mBlockIdRailstart = 0;
	this.mBlockIdSponge = 0;
	this.mBlockIdStationaryLava = 0;
	this.mBlockIdTrampoline = 0;
	this.mBreakSound = null;
	this.mBuildSound = null;
	this.mCloneSound = null;
	this.mDamageToPlayer = null;
	this.mDefaultMaterialSlots = null;
	this.mIsFlower = null;
	this.mIsSlipperyWalk = null;
	this.mLightRadius = null;
	this.mRail = null;
	this.mStartInventoryAmount = null;
	this.mStrength = null;
	this.mWalkSound = null;
	this.mWalkSpeed = null;
	this.mWalkableType = null;
	this.mWhenPlayerPlacesGetsConvertedTo = null;
	this.mBlockIdEmpty = 0;
	this.mBlockIdDirt = -1;
	this.mBlockIdSponge = -1;
	this.mBlockIdTrampoline = -1;
	this.mBlockIdAdminium = -1;
	this.mBlockIdCompass = -1;
	this.mBlockIdLadder = -1;
	this.mBlockIdEmptyHand = -1;
	this.mBlockIdCraftingTable = -1;
	this.mBlockIdLava = -1;
	this.mBlockIdStationaryLava = -1;
	this.mBlockIdFillStart = -1;
	this.mBlockIdCuboid = -1;
	this.mBlockIdFillArea = -1;
	this.mBlockIdMinecart = -1;
	this.mBlockIdRailstart = -128;
}

GameData.prototype.blockIdAdminium = function() {
	return this.mBlockIdAdminium;
}

GameData.prototype.blockIdCompass = function() {
	return this.mBlockIdCompass;
}

GameData.prototype.blockIdCraftingTable = function() {
	return this.mBlockIdCraftingTable;
}

GameData.prototype.blockIdCuboid = function() {
	return this.mBlockIdCuboid;
}

GameData.prototype.blockIdDirt = function() {
	return this.mBlockIdDirt;
}

GameData.prototype.blockIdEmpty = function() {
	return this.mBlockIdEmpty;
}

GameData.prototype.blockIdEmptyHand = function() {
	return this.mBlockIdEmptyHand;
}

GameData.prototype.blockIdFillArea = function() {
	return this.mBlockIdFillArea;
}

GameData.prototype.blockIdFillStart = function() {
	return this.mBlockIdFillStart;
}

GameData.prototype.blockIdLadder = function() {
	return this.mBlockIdLadder;
}

GameData.prototype.blockIdLava = function() {
	return this.mBlockIdLava;
}

GameData.prototype.blockIdMinecart = function() {
	return this.mBlockIdMinecart;
}

GameData.prototype.blockIdRailstart = function() {
	return this.mBlockIdRailstart;
}

GameData.prototype.blockIdSponge = function() {
	return this.mBlockIdSponge;
}

GameData.prototype.blockIdStationaryLava = function() {
	return this.mBlockIdStationaryLava;
}

GameData.prototype.blockIdTrampoline = function() {
	return this.mBlockIdTrampoline;
}

GameData.prototype.breakSound = function() {
	return this.mBreakSound;
}

GameData.prototype.buildSound = function() {
	return this.mBuildSound;
}

GameData.prototype.cloneSound = function() {
	return this.mCloneSound;
}

GameData.prototype.damageToPlayer = function() {
	return this.mDamageToPlayer;
}

GameData.prototype.defaultMaterialSlots = function() {
	return this.mDefaultMaterialSlots;
}

GameData.prototype.deserializeFloat = function(p) {
	var one = 1;
	return (one * p) / (32);
}

GameData.prototype.initialize = function(count) {
	this.mWhenPlayerPlacesGetsConvertedTo = new Int32Array(new ArrayBuffer(count << 2));
	this.mIsFlower = new Array(count);
	this.mRail = new Int32Array(new ArrayBuffer(count << 2));
	this.mWalkSpeed = new Float32Array(new ArrayBuffer(count << 2));
	for (var i = 0; i < count; i++) {
		this.mWalkSpeed[i] = 1;
	}
	this.mIsSlipperyWalk = new Array(count);
	this.mWalkSound = new Array(count);
	for (var i = 0; i < count; i++) {
		this.mWalkSound[i] = new Array(8);
	}
	this.mBreakSound = new Array(count);
	for (var i = 0; i < count; i++) {
		this.mBreakSound[i] = new Array(8);
	}
	this.mBuildSound = new Array(count);
	for (var i = 0; i < count; i++) {
		this.mBuildSound[i] = new Array(8);
	}
	this.mCloneSound = new Array(count);
	for (var i = 0; i < count; i++) {
		this.mCloneSound[i] = new Array(8);
	}
	this.mLightRadius = new Int32Array(new ArrayBuffer(count << 2));
	this.mStartInventoryAmount = new Int32Array(new ArrayBuffer(count << 2));
	this.mStrength = new Float32Array(new ArrayBuffer(count << 2));
	this.mDamageToPlayer = new Int32Array(new ArrayBuffer(count << 2));
	this.mWalkableType = new Int32Array(new ArrayBuffer(count << 2));
	this.mDefaultMaterialSlots = new Int32Array(new ArrayBuffer(10 << 2));
}

GameData.prototype.isFlower = function() {
	return this.mIsFlower;
}

GameData.prototype.isRailTile = function(id) {
	return id >= this.blockIdRailstart() && id < this.blockIdRailstart() + 64;
}

GameData.prototype.isSlipperyWalk = function() {
	return this.mIsSlipperyWalk;
}

GameData.prototype.lightRadius = function() {
	return this.mLightRadius;
}

GameData.prototype.rail = function() {
	return this.mRail;
}

GameData.prototype.setSpecialBlock = function(b, id) {
	switch (b.name) {
	case "Empty":
		this.mBlockIdEmpty = id;
		return true;
	case "Dirt":
		this.mBlockIdDirt = id;
		return true;
	case "Sponge":
		this.mBlockIdSponge = id;
		return true;
	case "Trampoline":
		this.mBlockIdTrampoline = id;
		return true;
	case "Adminium":
		this.mBlockIdAdminium = id;
		return true;
	case "Compass":
		this.mBlockIdCompass = id;
		return true;
	case "Ladder":
		this.mBlockIdLadder = id;
		return true;
	case "EmptyHand":
		this.mBlockIdEmptyHand = id;
		return true;
	case "CraftingTable":
		this.mBlockIdCraftingTable = id;
		return true;
	case "Lava":
		this.mBlockIdLava = id;
		return true;
	case "StationaryLava":
		this.mBlockIdStationaryLava = id;
		return true;
	case "FillStart":
		this.mBlockIdFillStart = id;
		return true;
	case "Cuboid":
		this.mBlockIdCuboid = id;
		return true;
	case "FillArea":
		this.mBlockIdFillArea = id;
		return true;
	case "Minecart":
		this.mBlockIdMinecart = id;
		return true;
	case "Rail0":
		this.mBlockIdRailstart = id;
		return true;
	default:
		return false;
	}
}
GameData.SOUND_COUNT = 8;

GameData.prototype.start = function() {
	this.initialize(1024);
}

GameData.prototype.startInventoryAmount = function() {
	return this.mStartInventoryAmount;
}

GameData.prototype.strength = function() {
	return this.mStrength;
}

GameData.prototype.update = function() {
}

GameData.prototype.useBlockType = function(id, b) {
	if (b.name == null) {
		return;
	}
	if (b.whenPlacedGetsConvertedTo != 0) {
		this.mWhenPlayerPlacesGetsConvertedTo[id] = b.whenPlacedGetsConvertedTo;
	}
	else {
		this.mWhenPlayerPlacesGetsConvertedTo[id] = id;
	}
	this.isFlower()[id] = b.drawType == 5;
	this.rail()[id] = b.rail;
	this.walkSpeed()[id] = this.deserializeFloat(b.walkSpeedFloat);
	this.isSlipperyWalk()[id] = b.isSlipperyWalk;
	this.walkSound()[id] = new Array(8);
	this.breakSound()[id] = new Array(8);
	this.buildSound()[id] = new Array(8);
	this.cloneSound()[id] = new Array(8);
	if (b.sounds != null) {
		for (var i = 0; i < b.sounds.walkCount; i++) {
			this.walkSound()[id][i] = b.sounds.walk[i];
		}
		for (var i = 0; i < b.sounds.break1Count; i++) {
			this.breakSound()[id][i] = b.sounds.break1[i];
		}
		for (var i = 0; i < b.sounds.buildCount; i++) {
			this.buildSound()[id][i] = b.sounds.build[i];
		}
		for (var i = 0; i < b.sounds.cloneCount; i++) {
			this.cloneSound()[id][i] = b.sounds.clone[i];
		}
	}
	this.lightRadius()[id] = b.lightRadius;
	this.strength()[id] = b.strength;
	this.damageToPlayer()[id] = b.damageToPlayer;
	this.walkableType1()[id] = b.walkableType;
	this.setSpecialBlock(b, id);
}

GameData.prototype.useBlockTypes = function(blocktypes, count) {
	for (var i = 0; i < count; i++) {
		if (blocktypes[i] != null) {
			this.useBlockType(i, blocktypes[i]);
		}
	}
}

GameData.prototype.walkSound = function() {
	return this.mWalkSound;
}

GameData.prototype.walkSpeed = function() {
	return this.mWalkSpeed;
}

GameData.prototype.walkableType1 = function() {
	return this.mWalkableType;
}

GameData.prototype.whenPlayerPlacesGetsConvertedTo = function() {
	return this.mWhenPlayerPlacesGetsConvertedTo;
}

function GameDataItemsClient()
{
	this.game = null;
}

GameDataItemsClient.prototype.canWear = function(selectedWear, item) {
	if (item == null) {
		return true;
	}
	if (item == null) {
		return true;
	}
	switch (selectedWear) {
	case 0:
		return item.itemClass == 0;
	case 1:
		return false;
	case 2:
		return false;
	case 3:
		return false;
	case 4:
		return false;
	default:
		return false;
	}
}

GameDataItemsClient.prototype.itemGraphics = function(item) {
	return null;
}

GameDataItemsClient.prototype.itemInfo = function(item) {
	if (item.itemClass == 0) {
		return this.game.language.get(StringTools.stringAppend(this.game.platform, "Block_", this.game.blocktypes[item.blockId].name));
	}
	this.game.platform.throwException("ItemClass");
	return "ItemClass";
}

GameDataItemsClient.prototype.itemSizeX = function(item) {
	if (item.itemClass == 0) {
		return 1;
	}
	this.game.platform.throwException("ItemClass");
	return 1;
}

GameDataItemsClient.prototype.itemSizeY = function(item) {
	if (item.itemClass == 0) {
		return 1;
	}
	this.game.platform.throwException("ItemClass");
	return 1;
}

GameDataItemsClient.prototype.stack = function(itemA, itemB) {
	if (itemA.itemClass == 0 && itemB.itemClass == 0) {
		var ret = new Packet_Item();
		ret.itemClass = itemA.itemClass;
		ret.blockId = itemA.blockId;
		ret.blockCount = itemA.blockCount + itemB.blockCount;
		return ret;
	}
	else {
		return null;
	}
}

GameDataItemsClient.prototype.textureIdForInventory = function() {
	return this.game.textureIdForInventory;
}

function GameDataMonsters()
{
	this.monsterCode = null;
	this.monsterName = null;
	this.monsterSkin = null;
	var n = 5;
	this.monsterCode = new Array(n);
	this.monsterName = new Array(n);
	this.monsterSkin = new Array(n);
	this.monsterCode[0] = "imp.txt";
	this.monsterName[0] = "Imp";
	this.monsterSkin[0] = "imp.png";
	this.monsterCode[1] = "imp.txt";
	this.monsterName[1] = "Fire Imp";
	this.monsterSkin[1] = "impfire.png";
	this.monsterCode[2] = "dragon.txt";
	this.monsterName[2] = "Dragon";
	this.monsterSkin[2] = "dragon.png";
	this.monsterCode[3] = "zombie.txt";
	this.monsterName[3] = "Zombie";
	this.monsterSkin[3] = "zombie.png";
	this.monsterCode[4] = "cyclops.txt";
	this.monsterName[4] = "Cyclops";
	this.monsterSkin[4] = "cyclops.png";
}

function GameExit()
{
	this.exit = false;
	this.restart = false;
}

GameExit.prototype.getExit = function() {
	return this.exit;
}

GameExit.prototype.getRestart = function() {
	return this.restart;
}

GameExit.prototype.setExit = function(p) {
	this.exit = p;
}

GameExit.prototype.setRestart = function(p) {
	this.restart = p;
}

function GamePlatform()
{
}

function GameVersionHelper()
{
}

GameVersionHelper.dateToInt = function(year, month, day) {
	return year * 10000 + month * 100 + day;
}

GameVersionHelper.isVersionDate = function(platform, version) {
	var versionCharsCount = new IntRef();
	var versionChars = platform.stringToCharArray(version, versionCharsCount);
	if (versionCharsCount.value >= 10) {
		if (versionChars[4] == 45 && versionChars[7] == 45) {
			return true;
		}
	}
	return false;
}

GameVersionHelper.serverVersionAtLeast = function(platform, serverGameVersion, year, month, day) {
	if (serverGameVersion == null) {
		return true;
	}
	if (GameVersionHelper.versionToInt(platform, serverGameVersion) < GameVersionHelper.dateToInt(year, month, day)) {
		return false;
	}
	return true;
}

GameVersionHelper.versionToInt = function(platform, version) {
	var max = 1000000000;
	if (!GameVersionHelper.isVersionDate(platform, version)) {
		return max;
	}
	var year = new FloatRef();
	var month = new FloatRef();
	var day = new FloatRef();
	if (platform.floatTryParse(StringTools.stringSubstring(platform, version, 0, 4), year)) {
		if (platform.floatTryParse(StringTools.stringSubstring(platform, version, 5, 2), month)) {
			if (platform.floatTryParse(StringTools.stringSubstring(platform, version, 8, 2), day)) {
				var year_ = platform.floatToInt(year.value);
				var month_ = platform.floatToInt(month.value);
				var day_ = platform.floatToInt(day.value);
				return year_ * 10000 + month_ * 100 + day_;
			}
		}
	}
	return max;
}

function GetBlockHeight_()
{
	this.w = null;
}
GetBlockHeight_.prototype = new DelegateGetBlockHeight();

GetBlockHeight_.create = function(w_) {
	var g = new GetBlockHeight_();
	g.w = w_;
	return g;
}

GetBlockHeight_.prototype.getBlockHeight = function(x, y, z) {
	return this.w.getblockheight(x, y, z);
}

function IGetCameraMatrix()
{
}

function GetCameraMatrix()
{
	this.lastmvmatrix = null;
	this.lastpmatrix = null;
}
GetCameraMatrix.prototype = new IGetCameraMatrix();

GetCameraMatrix.prototype.getModelViewMatrix = function() {
	return this.lastmvmatrix;
}

GetCameraMatrix.prototype.getProjectionMatrix = function() {
	return this.lastpmatrix;
}

function GlKeys()
{
}
GlKeys.A = 83;
GlKeys.ALT_LEFT = 5;
GlKeys.ALT_RIGHT = 6;
GlKeys.B = 84;
GlKeys.BACK = 53;
GlKeys.BACK_SLASH = 129;
GlKeys.BACK_SPACE = 53;
GlKeys.BRACKET_LEFT = 122;
GlKeys.BRACKET_RIGHT = 123;
GlKeys.C = 85;
GlKeys.CAPS_LOCK = 60;
GlKeys.CLEAR = 65;
GlKeys.COMMA = 126;
GlKeys.CONTROL_LEFT = 3;
GlKeys.CONTROL_RIGHT = 4;
GlKeys.D = 86;
GlKeys.DELETE = 55;
GlKeys.DOWN = 46;
GlKeys.E = 87;
GlKeys.END = 59;
GlKeys.ENTER = 49;
GlKeys.ESCAPE = 50;
GlKeys.F = 88;
GlKeys.F1 = 10;
GlKeys.F10 = 19;
GlKeys.F11 = 20;
GlKeys.F12 = 21;
GlKeys.F13 = 22;
GlKeys.F14 = 23;
GlKeys.F15 = 24;
GlKeys.F16 = 25;
GlKeys.F17 = 26;
GlKeys.F18 = 27;
GlKeys.F19 = 28;
GlKeys.F2 = 11;
GlKeys.F20 = 29;
GlKeys.F21 = 30;
GlKeys.F22 = 31;
GlKeys.F23 = 32;
GlKeys.F24 = 33;
GlKeys.F25 = 34;
GlKeys.F26 = 35;
GlKeys.F27 = 36;
GlKeys.F28 = 37;
GlKeys.F29 = 38;
GlKeys.F3 = 12;
GlKeys.F30 = 39;
GlKeys.F31 = 40;
GlKeys.F32 = 41;
GlKeys.F33 = 42;
GlKeys.F34 = 43;
GlKeys.F35 = 44;
GlKeys.F4 = 13;
GlKeys.F5 = 14;
GlKeys.F6 = 15;
GlKeys.F7 = 16;
GlKeys.F8 = 17;
GlKeys.F9 = 18;
GlKeys.G = 89;
GlKeys.H = 90;
GlKeys.HOME = 58;
GlKeys.I = 91;
GlKeys.INSERT = 54;
GlKeys.J = 92;
GlKeys.K = 93;
GlKeys.KEYPAD0 = 67;
GlKeys.KEYPAD1 = 68;
GlKeys.KEYPAD2 = 69;
GlKeys.KEYPAD3 = 70;
GlKeys.KEYPAD4 = 71;
GlKeys.KEYPAD5 = 72;
GlKeys.KEYPAD6 = 73;
GlKeys.KEYPAD7 = 74;
GlKeys.KEYPAD8 = 75;
GlKeys.KEYPAD9 = 76;
GlKeys.KEYPAD_ADD = 80;
GlKeys.KEYPAD_DECIMAL = 81;
GlKeys.KEYPAD_DIVIDE = 77;
GlKeys.KEYPAD_ENTER = 82;
GlKeys.KEYPAD_MINUS = 79;
GlKeys.KEYPAD_MULTIPLY = 78;
GlKeys.KEYPAD_PLUS = 80;
GlKeys.KEYPAD_SUBTRACT = 79;
GlKeys.L = 94;
GlKeys.L_ALT = 5;
GlKeys.L_BRACKET = 122;
GlKeys.L_CONTROL = 3;
GlKeys.L_SHIFT = 1;
GlKeys.L_WIN = 7;
GlKeys.LAST_KEY = 130;
GlKeys.LEFT = 47;
GlKeys.M = 95;
GlKeys.MENU = 9;
GlKeys.MINUS = 120;
GlKeys.N = 96;
GlKeys.NUM_LOCK = 64;
GlKeys.NUMBER0 = 109;
GlKeys.NUMBER1 = 110;
GlKeys.NUMBER2 = 111;
GlKeys.NUMBER3 = 112;
GlKeys.NUMBER4 = 113;
GlKeys.NUMBER5 = 114;
GlKeys.NUMBER6 = 115;
GlKeys.NUMBER7 = 116;
GlKeys.NUMBER8 = 117;
GlKeys.NUMBER9 = 118;
GlKeys.O = 97;
GlKeys.P = 98;
GlKeys.PAGE_DOWN = 57;
GlKeys.PAGE_UP = 56;
GlKeys.PAUSE = 63;
GlKeys.PERIOD = 127;
GlKeys.PLUS = 121;
GlKeys.PRINT_SCREEN = 62;
GlKeys.Q = 99;
GlKeys.QUOTE = 125;
GlKeys.R = 100;
GlKeys.R_ALT = 6;
GlKeys.R_BRACKET = 123;
GlKeys.R_CONTROL = 4;
GlKeys.R_SHIFT = 2;
GlKeys.R_WIN = 8;
GlKeys.RIGHT = 48;
GlKeys.S = 101;
GlKeys.SCROLL_LOCK = 61;
GlKeys.SEMICOLON = 124;
GlKeys.SHIFT_LEFT = 1;
GlKeys.SHIFT_RIGHT = 2;
GlKeys.SLASH = 128;
GlKeys.SLEEP = 66;
GlKeys.SPACE = 51;
GlKeys.T = 102;
GlKeys.TAB = 52;
GlKeys.TILDE = 119;
GlKeys.U = 103;
GlKeys.UNKNOWN = 0;
GlKeys.UP = 45;
GlKeys.V = 104;
GlKeys.W = 105;
GlKeys.WIN_LEFT = 7;
GlKeys.WIN_RIGHT = 8;
GlKeys.X = 106;
GlKeys.Y = 107;
GlKeys.Z = 108;

function GlMatrixMath()
{
}

GlMatrixMath.abs = function(len) {
	if (len < 0) {
		return -len;
	}
	else {
		return len;
	}
}

GlMatrixMath.gLMAT_EPSILON = function() {
	var one = 1;
	return one / (1000000);
}

GlMatrixMath.pI = function() {
	var a = 3141592;
	return a / (1000000);
}

GlMatrixMath.max = function(a, b) {
	if (a > b) {
		return a;
	}
	else {
		return b;
	}
}

GlMatrixMath.min = function(a, b) {
	if (a < b) {
		return a;
	}
	else {
		return b;
	}
}

function GlobalVar()
{
}
GlobalVar.M_A_X__B_L_O_C_K_T_Y_P_E_S = 1024;
GlobalVar.M_A_X__B_L_O_C_K_T_Y_P_E_S__S_Q_R_T = 32;

function Grenade_()
{
	this.block = 0;
	this.sourcePlayer = 0;
	this.velocityX = null;
	this.velocityY = null;
	this.velocityZ = null;
}

var GuiState = {
	NORMAL : 0,
	ESCAPE_MENU : 1,
	INVENTORY : 2,
	MAP_LOADING : 3,
	CRAFTING_RECIPES : 4,
	MODAL_DIALOG : 5
}

function HashSetVector3IntRef()
{
	this.max = 0;
	this.values = null;
	this.max = 16;
	this.start();
}

HashSetVector3IntRef.prototype.set = function(value) {
	var i = 0;
	for (i = 0; i < this.max; i++) {
		if (this.values[i] == null) {
			break;
		}
		if (this.values[i].x == value.x && this.values[i].y == value.y && this.values[i].z == value.z) {
			return;
		}
	}
	this.values[i] = Vector3IntRef.create(value.x, value.y, value.z);
}

HashSetVector3IntRef.prototype.start = function() {
	this.values = new Array(this.max);
}

function HttpResponseCi()
{
	this.done = false;
	this.error = false;
	this.value = null;
	this.valueLength = 0;
}

HttpResponseCi.prototype.getDone = function() {
	return this.done;
}

HttpResponseCi.prototype.getError = function() {
	return this.error;
}

HttpResponseCi.prototype.getString = function(platform) {
	return platform.stringFromUtf8ByteArray(this.value, this.valueLength);
}

HttpResponseCi.prototype.getValue = function() {
	return this.value;
}

HttpResponseCi.prototype.getValueLength = function() {
	return this.valueLength;
}

HttpResponseCi.prototype.setDone = function(value_) {
	this.done = value_;
}

HttpResponseCi.prototype.setError = function(value_) {
	this.error = value_;
}

HttpResponseCi.prototype.setValue = function(value_) {
	this.value = value_;
}

HttpResponseCi.prototype.setValueLength = function(value_) {
	this.valueLength = value_;
}

function IInterpolation()
{
}

function IMapStorage2()
{
}

function INetworkInterpolation()
{
}

function IPEndPointCiDefault()
{
	this.address = null;
}
IPEndPointCiDefault.prototype = new IPEndPointCi();

IPEndPointCiDefault.prototype.addressToString = function() {
	return this.address;
}

IPEndPointCiDefault.create = function(address_) {
	var e = new IPEndPointCiDefault();
	e.address = address_;
	return e;
}

function ITerrainTextures()
{
	this.game = null;
}

ITerrainTextures.prototype.terrainTexture = function() {
	return this.game.terrainTexture;
}

ITerrainTextures.prototype.terrainTextures1d = function() {
	return this.game.terrainTextures1d;
}

ITerrainTextures.prototype.terrainTexturesPerAtlas = function() {
	return this.game.terrainTexturesPerAtlas;
}

ITerrainTextures.prototype.texturesPacked = function() {
	return this.game.texturesPacked();
}

function ImageOnLoadHandler()
{
}

function InfiniteMapChunked2d()
{
	this.chunks = null;
	this.d_Map = null;
}

InfiniteMapChunked2d.prototype.clearChunk = function(x, y) {
	var px = Math.floor(x / 16);
	var py = Math.floor(y / 16);
	this.chunks[MapUtilCi.index2d(px, py, Math.floor(this.d_Map.map.mapSizeX / 16))] = null;
}

InfiniteMapChunked2d.prototype.getBlock = function(x, y) {
	var chunk = this.getChunk(x, y);
	return chunk[MapUtilCi.index2d(x % 16, y % 16, 16)];
}

InfiniteMapChunked2d.prototype.getChunk = function(x, y) {
	var chunk = null;
	var kx = Math.floor(x / 16);
	var ky = Math.floor(y / 16);
	if (this.chunks[MapUtilCi.index2d(kx, ky, Math.floor(this.d_Map.map.mapSizeX / 16))] == null) {
		chunk = new Int32Array(new ArrayBuffer(256 << 2));
		for (var i = 0; i < 256; i++) {
			chunk[i] = 0;
		}
		this.chunks[MapUtilCi.index2d(kx, ky, Math.floor(this.d_Map.map.mapSizeX / 16))] = chunk;
	}
	chunk = this.chunks[MapUtilCi.index2d(kx, ky, Math.floor(this.d_Map.map.mapSizeX / 16))];
	return chunk;
}

InfiniteMapChunked2d.prototype.restart = function() {
	var n = Math.floor(this.d_Map.map.mapSizeX / 16) * Math.floor(this.d_Map.map.mapSizeY / 16);
	this.chunks = new Array(n);
	for (var i = 0; i < n; i++) {
		this.chunks[i] = null;
	}
}

InfiniteMapChunked2d.prototype.setBlock = function(x, y, blocktype) {
	this.getChunk(x, y)[MapUtilCi.index2d(x % 16, y % 16, 16)] = blocktype;
}
InfiniteMapChunked2d.CHUNKSIZE = 16;

function IntRef()
{
	this.value = 0;
}

IntRef.create = function(value_) {
	var intref = new IntRef();
	intref.value = value_;
	return intref;
}

IntRef.prototype.getValue = function() {
	return this.value;
}

IntRef.prototype.setValue = function(value_) {
	this.value = value_;
}

function InterpolatedObject()
{
}

function InterpolationCi()
{
}

InterpolationCi.interpolateColor = function(platform, progress, colors, colorsLength) {
	var one = 1;
	var colora = platform.floatToInt((colorsLength - 1) * progress);
	if (colora < 0) {
		colora = 0;
	}
	if (colora >= colorsLength) {
		colora = colorsLength - 1;
	}
	var colorb = colora + 1;
	if (colorb >= colorsLength) {
		colorb = colorsLength - 1;
	}
	var a = colors[colora];
	var b = colors[colorb];
	var p = (progress - (one * colora) / (colorsLength - 1)) * (colorsLength - 1);
	var A = platform.floatToInt(Game.colorA(a) + (Game.colorA(b) - Game.colorA(a)) * p);
	var R = platform.floatToInt(Game.colorR(a) + (Game.colorR(b) - Game.colorR(a)) * p);
	var G = platform.floatToInt(Game.colorG(a) + (Game.colorG(b) - Game.colorG(a)) * p);
	var B = platform.floatToInt(Game.colorB(a) + (Game.colorB(b) - Game.colorB(a)) * p);
	return Game.colorFromArgb(A, R, G, B);
}

function Intersection()
{
}

Intersection.checkLineBox = function(box, line, hit) {
	return Intersection.checkLineBox1(box.minEdge, box.maxEdge, line.start, line.end, hit);
}

Intersection.checkLineBox1 = function(B1, B2, L1, L2, Hit) {
	if (L2[0] < B1[0] && L1[0] < B1[0])
		return false;
	if (L2[0] > B2[0] && L1[0] > B2[0])
		return false;
	if (L2[1] < B1[1] && L1[1] < B1[1])
		return false;
	if (L2[1] > B2[1] && L1[1] > B2[1])
		return false;
	if (L2[2] < B1[2] && L1[2] < B1[2])
		return false;
	if (L2[2] > B2[2] && L1[2] > B2[2])
		return false;
	if (L1[0] > B1[0] && L1[0] < B2[0] && L1[1] > B1[1] && L1[1] < B2[1] && L1[2] > B1[2] && L1[2] < B2[2]) {
		Hit[0] = L1[0];
		Hit[1] = L1[1];
		Hit[2] = L1[2];
		return true;
	}
	if (Intersection.getIntersection(L1[0] - B1[0], L2[0] - B1[0], L1, L2, Hit) && Intersection.inBox(Hit, B1, B2, 1) || Intersection.getIntersection(L1[1] - B1[1], L2[1] - B1[1], L1, L2, Hit) && Intersection.inBox(Hit, B1, B2, 2) || Intersection.getIntersection(L1[2] - B1[2], L2[2] - B1[2], L1, L2, Hit) && Intersection.inBox(Hit, B1, B2, 3) || Intersection.getIntersection(L1[0] - B2[0], L2[0] - B2[0], L1, L2, Hit) && Intersection.inBox(Hit, B1, B2, 1) || Intersection.getIntersection(L1[1] - B2[1], L2[1] - B2[1], L1, L2, Hit) && Intersection.inBox(Hit, B1, B2, 2) || Intersection.getIntersection(L1[2] - B2[2], L2[2] - B2[2], L1, L2, Hit) && Intersection.inBox(Hit, B1, B2, 3))
		return true;
	return false;
}

Intersection.checkLineBoxExact = function(line, box) {
	var dir_ = new Float32Array(new ArrayBuffer(3 << 2));
	dir_[0] = line.end[0] - line.start[0];
	dir_[1] = line.end[1] - line.start[1];
	dir_[2] = line.end[2] - line.start[2];
	var hit = new Float32Array(new ArrayBuffer(3 << 2));
	if (!Intersection.hitBoundingBox(box.minEdge, box.maxEdge, line.start, dir_, hit)) {
		return null;
	}
	return hit;
}

Intersection.getIntersection = function(fDst1, fDst2, P1, P2, Hit) {
	if (fDst1 * fDst2 >= 0)
		return false;
	if (fDst1 == fDst2)
		return false;
	Hit[0] = P1[0] + (P2[0] - P1[0]) * (-fDst1) / (fDst2 - fDst1);
	Hit[1] = P1[1] + (P2[1] - P1[1]) * (-fDst1) / (fDst2 - fDst1);
	Hit[2] = P1[2] + (P2[2] - P1[2]) * (-fDst1) / (fDst2 - fDst1);
	return true;
}

Intersection.hitBoundingBox = function(minB, maxB, origin, dir, coord) {
	var inside = true;
	var quadrant = new Uint8Array(new ArrayBuffer(3));
	var i;
	var whichPlane;
	var maxT = new Float32Array(new ArrayBuffer(3 << 2));
	var candidatePlane = new Float32Array(new ArrayBuffer(3 << 2));
	for (i = 0; i < 3; i++)
		if (origin[i] < minB[i]) {
			quadrant[i] = 1;
			candidatePlane[i] = minB[i];
			inside = false;
		}
		else if (origin[i] > maxB[i]) {
			quadrant[i] = 0;
			candidatePlane[i] = maxB[i];
			inside = false;
		}
		else {
			quadrant[i] = 2;
		}
	if (inside) {
		coord = origin;
		return true;
	}
	for (i = 0; i < 3; i++)
		if (quadrant[i] != 2 && dir[i] != 0)
			maxT[i] = (candidatePlane[i] - origin[i]) / (dir[i]);
		else
			maxT[i] = -1;
	whichPlane = 0;
	for (i = 1; i < 3; i++)
		if (maxT[whichPlane] < maxT[i])
			whichPlane = i;
	if (maxT[whichPlane] < 0)
		return false;
	for (i = 0; i < 3; i++)
		if (whichPlane != i) {
			coord[i] = origin[i] + maxT[whichPlane] * dir[i];
			if (coord[i] < minB[i] || coord[i] > maxB[i])
				return false;
		}
		else {
			coord[i] = candidatePlane[i];
		}
	return true;
}

Intersection.inBox = function(Hit, B1, B2, Axis) {
	if (Axis == 1 && Hit[2] > B1[2] && Hit[2] < B2[2] && Hit[1] > B1[1] && Hit[1] < B2[1])
		return true;
	if (Axis == 2 && Hit[2] > B1[2] && Hit[2] < B2[2] && Hit[0] > B1[0] && Hit[0] < B2[0])
		return true;
	if (Axis == 3 && Hit[0] > B1[0] && Hit[0] < B2[0] && Hit[1] > B1[1] && Hit[1] < B2[1])
		return true;
	return false;
}

function InventoryUtilClient()
{
	this.cellCountX = 0;
	this.cellCountY = 0;
	this.d_Inventory = null;
	this.d_Items = null;
	this.cellCountX = 12;
	this.cellCountY = 42;
}

InventoryUtilClient.prototype.freeHand = function(ActiveMaterial_) {
	var freehand = null;
	if (this.d_Inventory.rightHand[ActiveMaterial_] == null)
		return IntRef.create(ActiveMaterial_);
	for (var i = 0; i < 10; i++) {
		if (this.d_Inventory.rightHand[i] == null) {
			return freehand;
		}
	}
	return null;
}

InventoryUtilClient.prototype.isValidCell = function(p) {
	return !(p.x < 0 || p.y < 0 || p.x >= this.cellCountX || p.y >= this.cellCountY);
}

InventoryUtilClient.prototype.itemAtCell = function(p) {
	for (var i = 0; i < this.d_Inventory.itemsCount; i++) {
		var k = this.d_Inventory.items[i];
		var item = k.value_;
		for (var x = 0; x < this.d_Items.itemSizeX(item); x++) {
			for (var y = 0; y < this.d_Items.itemSizeY(item); y++) {
				var px = k.x + x;
				var py = k.y + y;
				if (p.x == px && p.y == py) {
					return PointRef.create(k.x, k.y);
				}
			}
		}
	}
	return null;
}

InventoryUtilClient.prototype.itemAtWearPlace = function(wearPlace, activeMaterial) {
	switch (wearPlace) {
	case 0:
		return this.d_Inventory.rightHand[activeMaterial];
	case 1:
		return this.d_Inventory.mainArmor;
	case 2:
		return this.d_Inventory.boots;
	case 3:
		return this.d_Inventory.helmet;
	case 4:
		return this.d_Inventory.gauntlet;
	default:
		return null;
	}
}

InventoryUtilClient.prototype.itemsAtArea = function(pX, pY, sizeX, sizeY, retCount) {
	var itemsAtArea = new Array(256);
	var itemsAtAreaCount = 0;
	for (var xx = 0; xx < sizeX; xx++) {
		for (var yy = 0; yy < sizeY; yy++) {
			var cell = PointRef.create(pX + xx, pY + yy);
			if (!this.isValidCell(cell)) {
				return null;
			}
			if (this.itemAtCell(cell) != null) {
				var contains = false;
				for (var i = 0; i < itemsAtAreaCount; i++) {
					if (itemsAtArea[i] == null) {
						continue;
					}
					if (itemsAtArea[i].x == this.itemAtCell(cell).x && itemsAtArea[i].y == this.itemAtCell(cell).y) {
						contains = true;
					}
				}
				if (!contains) {
					itemsAtArea[itemsAtAreaCount++] = this.itemAtCell(cell);
				}
			}
		}
	}
	retCount.value = itemsAtAreaCount;
	return itemsAtArea;
}

function IsBlockEmpty_()
{
	this.w = null;
}
IsBlockEmpty_.prototype = new DelegateIsBlockEmpty();

IsBlockEmpty_.create = function(w_) {
	var g = new IsBlockEmpty_();
	g.w = w_;
	return g;
}

IsBlockEmpty_.prototype.isBlockEmpty = function(x, y, z) {
	return this.w.isTileEmptyForPhysics(x, y, z);
}

function Kamera()
{
	this.angle = null;
	this.center = null;
	this.maximumAngle = 0;
	this.minimumAngle = 0;
	this.minimumDistance = null;
	this.distance = null;
	this.one = null;
	this.tt = null;
	this.one = 1;
	this.distance = 5;
	this.angle = 45;
	this.minimumDistance = 2;
	this.tt = 0;
	this.maximumAngle = 89;
	this.minimumAngle = 0;
	this.center = new Vector3Ref();
}

Kamera.prototype.getAngle = function() {
	return this.angle;
}

Kamera.prototype.getCameraHeightFromCenter = function(platform) {
	return platform.mathSin((this.angle * Game.getPi()) / (180)) * this.distance;
}

Kamera.prototype.getCenter = function(ret) {
	ret.x = this.center.x;
	ret.y = this.center.y;
	ret.z = this.center.z;
}

Kamera.prototype.getDistance = function() {
	return this.distance;
}

Kamera.prototype.getFlatDistance = function(platform) {
	return platform.mathCos((this.angle * Game.getPi()) / (180)) * this.distance;
}

Kamera.prototype.getPosition = function(platform, ret) {
	var cx = platform.mathCos((this.tt * this.one) / (2)) * this.getFlatDistance(platform) + this.center.x;
	var cy = platform.mathSin((this.tt * this.one) / (2)) * this.getFlatDistance(platform) + this.center.z;
	ret.x = cx;
	ret.y = this.center.y + this.getCameraHeightFromCenter(platform);
	ret.z = cy;
}

Kamera.prototype.getT = function() {
	return this.tt;
}

Kamera.prototype.move = function(camera_move, p) {
	p *= 2;
	p *= 2;
	if (camera_move.turnLeft) {
		this.turnLeft(p);
	}
	if (camera_move.turnRight) {
		this.turnRight(p);
	}
	if (camera_move.distanceUp) {
		this.setDistance(this.getDistance() + p);
	}
	if (camera_move.distanceDown) {
		this.setDistance(this.getDistance() - p);
	}
	if (camera_move.angleUp) {
		this.angle += p * 10;
	}
	if (camera_move.angleDown) {
		this.angle -= p * 10;
	}
	this.setDistance(camera_move.distance);
	this.setValidAngle();
}

Kamera.prototype.setAngle = function(value) {
	this.angle = value;
}

Kamera.prototype.setDistance = function(value) {
	this.distance = value;
	if (this.distance < this.minimumDistance) {
		this.distance = this.minimumDistance;
	}
}

Kamera.prototype.setT = function(value) {
	this.tt = value;
}

Kamera.prototype.setValidAngle = function() {
	if (this.angle > this.maximumAngle) {
		this.angle = this.maximumAngle;
	}
	if (this.angle < this.minimumAngle) {
		this.angle = this.minimumAngle;
	}
}

Kamera.prototype.turnLeft = function(p) {
	this.tt += p;
}

Kamera.prototype.turnRight = function(p) {
	this.tt -= p;
}

Kamera.prototype.turnUp = function(p) {
	this.angle += p;
	this.setValidAngle();
}

function Key()
{
	this.field = 0;
	this.wireType = 0;
}

Key.create = function(field, wireType) {
	var k = new Key();
	k.field = field;
	k.wireType = wireType;
	return k;
}

Key.prototype.getField = function() {
	return this.field;
}

Key.prototype.getWireType = function() {
	return this.wireType;
}

Key.prototype.setField = function(value) {
	this.field = value;
}

Key.prototype.setWireType = function(value) {
	this.wireType = value;
}

function KeyEventArgs()
{
	this.handled = false;
	this.keyCode = 0;
	this.modifierAlt = false;
	this.modifierCtrl = false;
	this.modifierShift = false;
}

KeyEventArgs.prototype.getAltPressed = function() {
	return this.modifierAlt;
}

KeyEventArgs.prototype.getCtrlPressed = function() {
	return this.modifierCtrl;
}

KeyEventArgs.prototype.getHandled = function() {
	return this.handled;
}

KeyEventArgs.prototype.getKeyCode = function() {
	return this.keyCode;
}

KeyEventArgs.prototype.getShiftPressed = function() {
	return this.modifierShift;
}

KeyEventArgs.prototype.setAltPressed = function(value) {
	this.modifierAlt = value;
}

KeyEventArgs.prototype.setCtrlPressed = function(value) {
	this.modifierCtrl = value;
}

KeyEventArgs.prototype.setHandled = function(value) {
	this.handled = value;
}

KeyEventArgs.prototype.setKeyCode = function(value) {
	this.keyCode = value;
}

KeyEventArgs.prototype.setShiftPressed = function(value) {
	this.modifierShift = value;
}

function KeyEventHandler()
{
}

function KeyHelp()
{
	this.defaultKey = 0;
	this.text = null;
}

function KeyPressEventArgs()
{
	this.handled = false;
	this.keyChar = 0;
}

KeyPressEventArgs.prototype.getHandled = function() {
	return this.handled;
}

KeyPressEventArgs.prototype.getKeyChar = function() {
	return this.keyChar;
}

KeyPressEventArgs.prototype.setHandled = function(value) {
	this.handled = value;
}

KeyPressEventArgs.prototype.setKeyChar = function(value) {
	this.keyChar = value;
}

function KeyValue()
{
	this.key_ = null;
	this.value = null;
}

KeyValue.create = function(key, value) {
	var k = new KeyValue();
	k.key_ = key;
	k.value = value;
	return k;
}

function KeyValueStringInt()
{
	this.key = null;
	this.value = 0;
}

function KeyValueStringString()
{
	this.key = null;
	this.value = null;
}

function Keyframe()
{
	this.animationName = null;
	this.frame = 0;
	this.keyframeType = 0;
	this.nodeName = null;
	this.x = null;
	this.y = null;
	this.z = null;
}

function KeyframeType()
{
}

KeyframeType.getName = function(p) {
	if (p == 1) {
		return "pos";
	}
	if (p == 2) {
		return "rot";
	}
	if (p == 3) {
		return "siz";
	}
	if (p == 4) {
		return "piv";
	}
	if (p == 5) {
		return "sca";
	}
	return "";
}

KeyframeType.getValue = function(p) {
	if (p == "pos") {
		return 1;
	}
	if (p == "rot") {
		return 2;
	}
	if (p == "siz") {
		return 3;
	}
	if (p == "piv") {
		return 4;
	}
	if (p == "sca") {
		return 5;
	}
	return 0;
}
KeyframeType.PIVOT = 4;
KeyframeType.POSITION = 1;
KeyframeType.ROTATION = 2;
KeyframeType.SCALE = 5;
KeyframeType.SIZE = 3;

function Language()
{
	this.overrideLanguage = null;
}

Language.prototype.addEnglish = function() {
	this.add("en", "MainMenu_AssetsLoadProgress", "Loading... {0}%");
	this.add("en", "MainMenu_Singleplayer", "Singleplayer");
	this.add("en", "MainMenu_Multiplayer", "Multiplayer");
	this.add("en", "MainMenu_Quit", "&cQuit");
	this.add("en", "MainMenu_ButtonBack", "Back");
	this.add("en", "MainMenu_SingleplayerButtonCreate", "Create or open...");
	this.add("en", "MainMenu_Login", "Login");
	this.add("en", "MainMenu_LoginUsername", "Username");
	this.add("en", "MainMenu_LoginPassword", "Password");
	this.add("en", "MainMenu_LoginRemember", "Remember me");
	this.add("en", "MainMenu_ChoiceYes", "Yes");
	this.add("en", "MainMenu_ChoiceNo", "No");
	this.add("en", "MainMenu_LoginInvalid", "&4Invalid username or password");
	this.add("en", "MainMenu_LoginConnecting", "Connecting...");
	this.add("en", "MainMenu_MultiplayerConnect", "Connect");
	this.add("en", "MainMenu_MultiplayerConnectIP", "Connect to IP");
	this.add("en", "MainMenu_MultiplayerRefresh", "Refresh");
	this.add("en", "MainMenu_MultiplayerLoading", "Loading...");
	this.add("en", "MainMenu_ConnectToIpConnect", "Connect");
	this.add("en", "MainMenu_ConnectToIpIp", "IP");
	this.add("en", "MainMenu_ConnectToIpPort", "Port");
	this.add("en", "CannotWriteChatLog", "Cannot write to chat log file {0}.");
	this.add("en", "ChunkUpdates", "Chunk updates: {0}");
	this.add("en", "Connecting", "Connecting...");
	this.add("en", "ConnectingProgressKilobytes", "{0} KB");
	this.add("en", "ConnectingProgressPercent", "{0}%");
	this.add("en", "DefaultKeys", "Default keys");
	this.add("en", "Exit", "Return to main menu");
	this.add("en", "FogDistance", "Fog distance: {0}");
	this.add("en", "FontOption", "Font: {0}");
	this.add("en", "FrameRateLagSimulation", "Frame rate: lag simulation.");
	this.add("en", "FrameRateUnlimited", "Frame rate: unlimited.");
	this.add("en", "FrameRateVsync", "Frame rate: vsync.");
	this.add("en", "FreemoveNotAllowed", "Freemove is not allowed on this server.");
	this.add("en", "GameName", "Manic Digger");
	this.add("en", "Graphics", "Graphics");
	this.add("en", "InvalidVersionConnectAnyway", "Invalid game version. Local: {0}, Server: {1}. Do you want to connect anyway?");
	this.add("en", "KeyBlockInfo", "Block information");
	this.add("en", "KeyChange", "{0}: {1}");
	this.add("en", "KeyChat", "Chat");
	this.add("en", "KeyCraft", "Craft");
	this.add("en", "KeyFreeMove", "Free move");
	this.add("en", "KeyFullscreen", "Fullscreen");
	this.add("en", "KeyJump", "Jump");
	this.add("en", "KeyMoveBack", "Move back");
	this.add("en", "KeyMoveFoward", "Move foward");
	this.add("en", "KeyMoveLeft", "Move left");
	this.add("en", "KeyMoveRight", "Move right");
	this.add("en", "KeyMoveSpeed", "{0}x move speed");
	this.add("en", "KeyPlayersList", "Players list");
	this.add("en", "KeyReloadWeapon", "Reload weapon");
	this.add("en", "KeyRespawn", "Respawn");
	this.add("en", "KeyReverseMinecart", "Reverse minecart");
	this.add("en", "Keys", "Keys");
	this.add("en", "KeyScreenshot", "Screenshot");
	this.add("en", "KeySetSpawnPosition", "Set spawn position");
	this.add("en", "KeyShowMaterialSelector", "Open inventory");
	this.add("en", "KeyTeamChat", "Team Chat");
	this.add("en", "KeyTextEditor", "Texteditor");
	this.add("en", "KeyThirdPersonCamera", "Third-person camera");
	this.add("en", "KeyToggleFogDistance", "Toggle fog distance");
	this.add("en", "KeyUse", "Use");
	this.add("en", "MoveFree", "Move: Free.");
	this.add("en", "MoveFreeNoclip", "Move: Free, Noclip.");
	this.add("en", "MoveNormal", "Move: Normal.");
	this.add("en", "MoveSpeed", "Move Speed: {0}.");
	this.add("en", "NoMaterialsForCrafting", "No materials for crafting.");
	this.add("en", "Off", "OFF");
	this.add("en", "On", "ON");
	this.add("en", "Options", "Options");
	this.add("en", "Other", "Other");
	this.add("en", "PressToUse", "(press {0} to use)");
	this.add("en", "Respawn", "Respawn");
	this.add("en", "ReturnToGame", "Return to game");
	this.add("en", "ReturnToMainMenu", "Back");
	this.add("en", "ReturnToOptionsMenu", "Return to options menu");
	this.add("en", "ShadowsOption", "Shadows: {0}");
	this.add("en", "SoundOption", "Sound: {0}");
	this.add("en", "AutoJumpOption", "Auto Jump: {0}");
	this.add("en", "ClientLanguageOption", "Language: {0}");
	this.add("en", "SpawnPositionSet", "Spawn position set.");
	this.add("en", "SpawnPositionSetTo", "Spawn position set to: {0}");
	this.add("en", "Triangles", "Triangles: {0}");
	this.add("en", "UseServerTexturesOption", "Use server textures (restart): {0}");
	this.add("en", "ViewDistanceOption", "View distance: {0}");
	this.add("en", "OptionSmoothShadows", "Smooth shadows: {0}");
	this.add("en", "OptionFramerate", "Framerate: {0}");
	this.add("en", "OptionResolution", "Resolution: {0}");
	this.add("en", "OptionFullscreen", "Fullscreen: {0}");
	this.add("en", "OptionDarkenSides", "Darken block sides: {0}");
	this.add("en", "Server_CannotWriteLogFile", "Cannot write to server log file {0}.");
	this.add("en", "Server_LoadingSavegame", "Loading savegame...");
	this.add("en", "Server_CreatingSavegame", "Creating new savegame file.");
	this.add("en", "Server_LoadedSavegame", "Savegame loaded: ");
	this.add("en", "Server_ConfigNotFound", "Server configuration file not found, creating new.");
	this.add("en", "Server_ConfigCorruptBackup", "ServerConfig corrupt! Created new. Backup saved as ServerConfig.txt.old");
	this.add("en", "Server_ConfigCorruptNoBackup", "ServerConfig corrupt! Created new. COULD NOT BACKUP OLD!");
	this.add("en", "Server_ConfigLoaded", "Server configuration loaded.");
	this.add("en", "Server_ClientConfigNotFound", "Server client configuration file not found, creating new.");
	this.add("en", "Server_ClientConfigGuestGroupNotFound", "Default guest group not found!");
	this.add("en", "Server_ClientConfigRegisteredGroupNotFound", "Default registered group not found!");
	this.add("en", "Server_ClientConfigLoaded", "Server client configuration loaded.");
	this.add("en", "Server_InvalidSpawnCoordinates", "Invalid default spawn coordinates!");
	this.add("en", "Server_ProgressDownloadingData", "Downloading data...");
	this.add("en", "Server_ProgressGenerating", "Generating world...");
	this.add("en", "Server_ProgressDownloadingMap", "Downloading map...");
	this.add("en", "Server_NoChatPrivilege", "{0}Insufficient privileges to chat.");
	this.add("en", "Server_FillAreaInvalid", "Fillarea is invalid or contains blocks in an area you are not allowed to build in.");
	this.add("en", "Server_FillAreaTooLarge", "Fill area is too large.");
	this.add("en", "Server_NoSpectatorBuild", "Spectators are not allowed to build.");
	this.add("en", "Server_NoBuildPrivilege", "Insufficient privileges to build.");
	this.add("en", "Server_NoBuildPermissionHere", "You need permission to build in this section of the world.");
	this.add("en", "Server_NoSpectatorUse", "Spectators are not allowed to use blocks.");
	this.add("en", "Server_NoUsePrivilege", "Insufficient privileges to use blocks.");
	this.add("en", "Server_PlayerJoin", "Player {0} joins.");
	this.add("en", "Server_PlayerDisconnect", "Player {0} disconnected.");
	this.add("en", "Server_UsernameBanned", "Your username has been banned from this server.{0}");
	this.add("en", "Server_NoGuests", "Guests are not allowed on this server. Login or register an account.");
	this.add("en", "Server_UsernameInvalid", "Invalid username (allowed characters: a-z,A-Z,0-9,-,_; max. length: 16).");
	this.add("en", "Server_PasswordInvalid", "Invalid server password.");
	this.add("en", "Server_ClientException", "Your client threw an exception at server.");
	this.add("en", "Server_IPBanned", "Your IP has been banned from this server.{0}");
	this.add("en", "Server_TooManyPlayers", "Too many players! Try to connect later.");
	this.add("en", "Server_HTTPServerError", "Cannot start HTTP server on TCP port {0}.");
	this.add("en", "Server_HTTPServerStarted", "HTTP server listening on TCP port {0}.");
	this.add("en", "Server_HeartbeatSent", "Heartbeat sent.");
	this.add("en", "Server_HeartbeatError", "Unable to send heartbeat.");
	this.add("en", "Server_BanlistLoaded", "Server banlist loaded.");
	this.add("en", "Server_BanlistCorruptNoBackup", "Banlist corrupt! Created new. COULD NOT BACKUP OLD!");
	this.add("en", "Server_BanlistCorrupt", "Banlist corrupt! Created new. Backup saved as ServerBanlist.txt.old");
	this.add("en", "Server_BanlistNotFound", "Server banlist not found, creating new.");
	this.add("en", "Server_SetupAccept", "y");
	this.add("en", "Server_SetupEnableHTTP", "Dou you want to enable the builtin HTTP server? (Y/N)");
	this.add("en", "Server_SetupMaxClients", "Enter the maximum number of clients (Default: 16)");
	this.add("en", "Server_SetupMaxClientsInvalidValue", "Number may not be negative. Using default (16)");
	this.add("en", "Server_SetupMaxClientsInvalidInput", "Invalid input. Using default (16)");
	this.add("en", "Server_SetupPort", "Enter the port the server shall run on (Default: 25565)");
	this.add("en", "Server_SetupPortInvalidValue", "Out of port range. Using default (25565)");
	this.add("en", "Server_SetupPortInvalidInput", "Invalid input. Using default (25565)");
	this.add("en", "Server_SetupWelcomeMessage", "Enter the welcome message (displayed when joining your server)");
	this.add("en", "Server_SetupMOTD", "Enter the MOTD (displayed on server list)");
	this.add("en", "Server_SetupName", "Please enter the server's name");
	this.add("en", "Server_SetupPublic", "Do you want the server to be public (visible on the server list)? (Y/N)");
	this.add("en", "Server_SetupQuestion", "Would you like to set up some basic parameters? (Y/N)");
	this.add("en", "Server_SetupFirstStart", "It seems this is the first time you started this server.");
	this.add("en", "Server_GameSaved", "Game saved. ({0} seconds)");
	this.add("en", "Server_InvalidBackupName", "Invalid backup filename: ");
	this.add("en", "Server_MonitorConfigLoaded", "Server monitor configuration loaded.");
	this.add("en", "Server_MonitorConfigNotFound", "Server monitor configuration file not found, creating new.");
	this.add("en", "Server_MonitorChatMuted", "Spam protection: {0} has been muted for {1} seconds.");
	this.add("en", "Server_MonitorChatNotSent", "Spam protection: Your message has not been sent.");
	this.add("en", "Server_MonitorBuildingDisabled", "{0} exceeds set block limit.");
	this.add("en", "Server_CommandInvalidArgs", "Invalid arguments. Type /help to see command's usage.");
	this.add("en", "Server_CommandInvalidSpawnPosition", "Invalid spawn position.");
	this.add("en", "Server_CommandNonexistantPlayer", "{0}Player {1} does not exist.");
	this.add("en", "Server_CommandInvalidPosition", "Invalid position.");
	this.add("en", "Server_CommandInsufficientPrivileges", "{0}Insufficient privileges to access this command.");
	this.add("en", "Server_CommandBackupFailed", "{0}Backup could not be created. Check filename.");
	this.add("en", "Server_CommandBackupCreated", "{0}Backup created.");
	this.add("en", "Server_CommandException", "Command exception.");
	this.add("en", "Server_CommandUnknown", "Unknown command /");
	this.add("en", "Server_CommandPlayerNotFound", "{0}Player {1} not found.");
	this.add("en", "Server_CommandPMNoAnswer", "{0}No PM to answer.");
	this.add("en", "Server_CommandGroupNotFound", "{0}Group {1} not found.");
	this.add("en", "Server_CommandTargetGroupSuperior", "{0}The target group is superior your group.");
	this.add("en", "Server_CommandTargetUserSuperior", "{0}Target user is superior or equal.");
	this.add("en", "Server_CommandSetGroupTo", "{0}{1} set group of {2} to {3}.");
	this.add("en", "Server_CommandOpTargetOffline", "{0}Player {1} is offline. Use /chgrp_offline command.");
	this.add("en", "Server_CommandOpTargetOnline", "{0}Player {1} is online. Use /chgrp command.");
	this.add("en", "Server_CommandInvalidGroup", "{0}Invalid group.");
	this.add("en", "Server_CommandSetOfflineGroupTo", "{0}{1} set group of {2} to {3} (offline).");
	this.add("en", "Server_CommandRemoveSuccess", "{0}Client {1} removed from config.");
	this.add("en", "Server_CommandRemoveNotFound", "{0}No entry of client {1} found.");
	this.add("en", "Server_CommandLoginNoPW", "{0}Group {1} doesn't allow password access.");
	this.add("en", "Server_CommandLoginSuccess", "{0}{1} logs in group {2}.");
	this.add("en", "Server_CommandLoginInfo", "Type /help see your available privileges.");
	this.add("en", "Server_CommandLoginInvalidPassword", "{0}Invalid password.");
	this.add("en", "Server_CommandWelcomeChanged", "{0}{1} set new welcome message: {2}");
	this.add("en", "Server_CommandKickBanReason", " Reason: ");
	this.add("en", "Server_CommandKickMessage", "{0}{1} was kicked by {2}.{3}");
	this.add("en", "Server_CommandKickNotification", "You were kicked by an administrator.{0}");
	this.add("en", "Server_CommandNonexistantID", "{0}Player ID {1} does not exist.");
	this.add("en", "Server_CommandBanMessage", "{0}{1} was permanently banned by {2}.{3}");
	this.add("en", "Server_CommandBanNotification", "You were permanently banned by an administrator.{0}");
	this.add("en", "Server_CommandIPBanMessage", "{0}{1} was permanently IP banned by {2}.{3}");
	this.add("en", "Server_CommandIPBanNotification", "You were permanently IP banned by an administrator.{0}");
	this.add("en", "Server_CommandTimeBanMessage", "{0}{1} was banned by {2} for {3} minutes.{4}");
	this.add("en", "Server_CommandTimeBanNotification", "You were banned by an administrator for {0} minutes.{1}");
	this.add("en", "Server_CommandTimeIPBanMessage", "{0}{1} was IP banned by {2} for {3} minutes.{4}");
	this.add("en", "Server_CommandTimeIPBanNotification", "You were IP banned by an administrator for {0} minutes.{1}");
	this.add("en", "Server_CommandTimeBanInvalidValue", "Duration must be greater than 0!");
	this.add("en", "Server_CommandBanOfflineTargetOnline", "{0}Player {1} is online. Use /ban command.");
	this.add("en", "Server_CommandBanOfflineMessage", "{0}{1} (offline) was banned by {2}.{3}");
	this.add("en", "Server_CommandUnbanSuccess", "{0}Player {1} unbanned.");
	this.add("en", "Server_CommandUnbanIPNotFound", "{0}IP {1} not found.");
	this.add("en", "Server_CommandUnbanIPSuccess", "{0}IP {1} unbanned.");
	this.add("en", "Server_CommandGiveAll", "{0}Given all blocks to {1}");
	this.add("en", "Server_CommandGiveSuccess", "{0}Given {1} {2} to {3}.");
	this.add("en", "Server_CommandResetInventorySuccess", "{0}{1}reset inventory of {2}.");
	this.add("en", "Server_CommandResetInventoryOfflineSuccess", "{0}{1}reset inventory of {2} (offline).");
	this.add("en", "Server_CommandMonstersToggle", "{0} turned monsters {1}.");
	this.add("en", "Server_CommandAreaAddIdInUse", "{0}Area ID already in use.");
	this.add("en", "Server_CommandAreaAddSuccess", "{0}New area added: {1}");
	this.add("en", "Server_CommandAreaDeleteNonexistant", "{0}Area does not exist.");
	this.add("en", "Server_CommandAreaDeleteSuccess", "{0}Area deleted.");
	this.add("en", "Server_CommandAnnouncementMessage", "{0}Announcement: {1}");
	this.add("en", "Server_CommandSetSpawnInvalidCoordinates", "{0}Invalid spawn coordinates.");
	this.add("en", "Server_CommandSetSpawnDefaultSuccess", "{0}Default spawn position set to {1},{2},{3}.");
	this.add("en", "Server_CommandSetSpawnGroupSuccess", "{0}Spawn position of group {1} set to {2},{3},{4}.");
	this.add("en", "Server_CommandSetSpawnPlayerSuccess", "{0}Spawn position of player {1} set to {2},{3},{4}.");
	this.add("en", "Server_CommandPrivilegeAddHasAlready", "{0}Player {1} already has privilege {2}.");
	this.add("en", "Server_CommandPrivilegeAddSuccess", "{0}New privilege for {1}: {2}");
	this.add("en", "Server_CommandPrivilegeRemoveNoPriv", "{0}Player {1} doesn't have privilege {2}.");
	this.add("en", "Server_CommandPrivilegeRemoveSuccess", "{0} {1} lost privilege: {2}");
	this.add("en", "Server_CommandRestartSuccess", "{0}{1} restarted server.");
	this.add("en", "Server_CommandShutdownSuccess", "{0}{1} shut down the server.");
	this.add("en", "Server_CommandRestartModsSuccess", "{0}{1} restarted mods.");
	this.add("en", "Server_CommandTeleportInvalidCoordinates", "{0}Invalid coordinates.");
	this.add("en", "Server_CommandTeleportSuccess", "{0}New Position ({1},{2},{3}).");
	this.add("en", "Server_CommandTeleportTargetMessage", "{0}You have been teleported to ({1},{2},{3}) by {4}.");
	this.add("en", "Server_CommandTeleportSourceMessage", "{0}You teleported {1} to ({2},{3},{4}).");
	this.add("en", "Server_CommandFillLimitDefaultSuccess", "{0}Default fill area limit set to {1}.");
	this.add("en", "Server_CommandFillLimitGroupSuccess", "{0}Fill area limit of group {1} set to {2}.");
	this.add("en", "Server_CommandFillLimitPlayerSuccess", "{0}Fill area limit of player {1} set to {2}.");
	this.add("en", "Server_CommandInvalidType", "Invalid type.");
}

Language.prototype.autoJumpOption = function() {
	return this.get("AutoJumpOption");
}

Language.prototype.cannotWriteChatLog = function() {
	return this.get("CannotWriteChatLog");
}

Language.prototype.clientLanguageOption = function() {
	return this.get("ClientLanguageOption");
}

Language.prototype.connecting = function() {
	return this.get("Connecting");
}

Language.prototype.connectingProgressKilobytes = function() {
	return this.get("ConnectingProgressKilobytes");
}

Language.prototype.connectingProgressPercent = function() {
	return this.get("ConnectingProgressPercent");
}

Language.prototype.defaultKeys = function() {
	return this.get("DefaultKeys");
}

Language.prototype.exit = function() {
	return this.get("Exit");
}

Language.prototype.fogDistance = function() {
	return this.get("FogDistance");
}

Language.prototype.fontOption = function() {
	return this.get("FontOption");
}

Language.prototype.frameRateLagSimulation = function() {
	return this.get("FrameRateLagSimulation");
}

Language.prototype.frameRateUnlimited = function() {
	return this.get("FrameRateUnlimited");
}

Language.prototype.frameRateVsync = function() {
	return this.get("FrameRateVsync");
}

Language.prototype.freemoveNotAllowed = function() {
	return this.get("FreemoveNotAllowed");
}

Language.prototype.gameName = function() {
	return this.get("GameName");
}

Language.prototype.graphics = function() {
	return this.get("Graphics");
}

Language.prototype.invalidVersionConnectAnyway = function() {
	return this.get("InvalidVersionConnectAnyway");
}

Language.prototype.keyBlockInfo = function() {
	return this.get("KeyBlockInfo");
}

Language.prototype.keyChange = function() {
	return this.get("KeyChange");
}

Language.prototype.keyChat = function() {
	return this.get("KeyChat");
}

Language.prototype.keyCraft = function() {
	return this.get("KeyCraft");
}

Language.prototype.keyFreeMove = function() {
	return this.get("KeyFreeMove");
}

Language.prototype.keyFullscreen = function() {
	return this.get("KeyFullscreen");
}

Language.prototype.keyJump = function() {
	return this.get("KeyJump");
}

Language.prototype.keyMoveBack = function() {
	return this.get("KeyMoveBack");
}

Language.prototype.keyMoveFoward = function() {
	return this.get("KeyMoveFoward");
}

Language.prototype.keyMoveLeft = function() {
	return this.get("KeyMoveLeft");
}

Language.prototype.keyMoveRight = function() {
	return this.get("KeyMoveRight");
}

Language.prototype.keyMoveSpeed = function() {
	return this.get("KeyMoveSpeed");
}

Language.prototype.keyPlayersList = function() {
	return this.get("KeyPlayersList");
}

Language.prototype.keyReloadWeapon = function() {
	return this.get("KeyReloadWeapon");
}

Language.prototype.keyRespawn = function() {
	return this.get("KeyRespawn");
}

Language.prototype.keyReverseMinecart = function() {
	return this.get("KeyReverseMinecart");
}

Language.prototype.keyScreenshot = function() {
	return this.get("KeyScreenshot");
}

Language.prototype.keySetSpawnPosition = function() {
	return this.get("KeySetSpawnPosition");
}

Language.prototype.keyShowMaterialSelector = function() {
	return this.get("KeyShowMaterialSelector");
}

Language.prototype.keyTeamChat = function() {
	return this.get("KeyTeamChat");
}

Language.prototype.keyTextEditor = function() {
	return this.get("KeyTextEditor");
}

Language.prototype.keyThirdPersonCamera = function() {
	return this.get("KeyThirdPersonCamera");
}

Language.prototype.keyToggleFogDistance = function() {
	return this.get("KeyToggleFogDistance");
}

Language.prototype.keyUse = function() {
	return this.get("KeyUse");
}

Language.prototype.keys = function() {
	return this.get("Keys");
}

Language.prototype.moveFree = function() {
	return this.get("MoveFree");
}

Language.prototype.moveFreeNoclip = function() {
	return this.get("MoveFreeNoclip");
}

Language.prototype.moveNormal = function() {
	return this.get("MoveNormal");
}

Language.prototype.moveSpeed = function() {
	return this.get("MoveSpeed");
}

Language.prototype.noMaterialsForCrafting = function() {
	return this.get("NoMaterialsForCrafting");
}

Language.prototype.off = function() {
	return this.get("Off");
}

Language.prototype.on = function() {
	return this.get("On");
}

Language.prototype.optionFramerate = function() {
	return this.get("OptionFramerate");
}

Language.prototype.optionFullscreen = function() {
	return this.get("OptionFullscreen");
}

Language.prototype.optionResolution = function() {
	return this.get("OptionResolution");
}

Language.prototype.optionSmoothShadows = function() {
	return this.get("OptionSmoothShadows");
}

Language.prototype.options = function() {
	return this.get("Options");
}

Language.prototype.other = function() {
	return this.get("Other");
}

Language.prototype.pressToUse = function() {
	return this.get("PressToUse");
}

Language.prototype.respawn = function() {
	return this.get("Respawn");
}

Language.prototype.returnToGame = function() {
	return this.get("ReturnToGame");
}

Language.prototype.returnToMainMenu = function() {
	return this.get("ReturnToMainMenu");
}

Language.prototype.returnToOptionsMenu = function() {
	return this.get("ReturnToOptionsMenu");
}

Language.prototype.serverBanlistCorrupt = function() {
	return this.get("Server_BanlistCorrupt");
}

Language.prototype.serverBanlistCorruptNoBackup = function() {
	return this.get("Server_BanlistCorruptNoBackup");
}

Language.prototype.serverBanlistLoaded = function() {
	return this.get("Server_BanlistLoaded");
}

Language.prototype.serverBanlistNotFound = function() {
	return this.get("Server_BanlistNotFound");
}

Language.prototype.serverCannotWriteLog = function() {
	return this.get("Server_CannotWriteLogFile");
}

Language.prototype.serverClientConfigGuestGroupNotFound = function() {
	return this.get("Server_ClientConfigGuestGroupNotFound");
}

Language.prototype.serverClientConfigLoaded = function() {
	return this.get("Server_ClientConfigLoaded");
}

Language.prototype.serverClientConfigNotFound = function() {
	return this.get("Server_ClientConfigNotFound");
}

Language.prototype.serverClientConfigRegisteredGroupNotFound = function() {
	return this.get("Server_ClientConfigRegisteredGroupNotFound");
}

Language.prototype.serverClientException = function() {
	return this.get("Server_ClientException");
}

Language.prototype.serverConfigCorruptBackup = function() {
	return this.get("Server_ConfigCorruptBackup");
}

Language.prototype.serverConfigCorruptNoBackup = function() {
	return this.get("Server_ConfigCorruptNoBackup");
}

Language.prototype.serverConfigLoaded = function() {
	return this.get("Server_ConfigLoaded");
}

Language.prototype.serverConfigNotFound = function() {
	return this.get("Server_ConfigNotFound");
}

Language.prototype.serverCreatingSavegame = function() {
	return this.get("Server_CreatingSavegame");
}

Language.prototype.serverFillAreaInvalid = function() {
	return this.get("Server_FillAreaInvalid");
}

Language.prototype.serverFillAreaTooLarge = function() {
	return this.get("Server_FillAreaTooLarge");
}

Language.prototype.serverGameSaved = function() {
	return this.get("Server_GameSaved");
}

Language.prototype.serverHTTPServerError = function() {
	return this.get("Server_HTTPServerError");
}

Language.prototype.serverHTTPServerStarted = function() {
	return this.get("Server_HTTPServerStarted");
}

Language.prototype.serverHeartbeatError = function() {
	return this.get("Server_HeartbeatError");
}

Language.prototype.serverHeartbeatSent = function() {
	return this.get("Server_HeartbeatSent");
}

Language.prototype.serverIPBanned = function() {
	return this.get("Server_IPBanned");
}

Language.prototype.serverInvalidBackupName = function() {
	return this.get("Server_InvalidBackupName");
}

Language.prototype.serverInvalidSpawnCoordinates = function() {
	return this.get("Server_InvalidSpawnCoordinates");
}

Language.prototype.serverLoadedSavegame = function() {
	return this.get("Server_LoadedSavegame");
}

Language.prototype.serverLoadingSavegame = function() {
	return this.get("Server_LoadingSavegame");
}

Language.prototype.serverMonitorBuildingDisabled = function() {
	return this.get("Server_MonitorBuildingDisabled");
}

Language.prototype.serverMonitorChatMuted = function() {
	return this.get("Server_MonitorChatMuted");
}

Language.prototype.serverMonitorChatNotSent = function() {
	return this.get("Server_MonitorChatNotSent");
}

Language.prototype.serverMonitorConfigLoaded = function() {
	return this.get("Server_MonitorConfigLoaded");
}

Language.prototype.serverMonitorConfigNotFound = function() {
	return this.get("Server_MonitorConfigNotFound");
}

Language.prototype.serverNoBuildPermissionHere = function() {
	return this.get("Server_NoBuildPermissionHere");
}

Language.prototype.serverNoBuildPrivilege = function() {
	return this.get("Server_NoBuildPrivilege");
}

Language.prototype.serverNoChatPrivilege = function() {
	return this.get("Server_NoChatPrivilege");
}

Language.prototype.serverNoGuests = function() {
	return this.get("Server_NoGuests");
}

Language.prototype.serverNoSpectatorBuild = function() {
	return this.get("Server_NoSpectatorBuild");
}

Language.prototype.serverNoSpectatorUse = function() {
	return this.get("Server_NoSpectatorUse");
}

Language.prototype.serverNoUsePrivilege = function() {
	return this.get("Server_NoUsePrivilege");
}

Language.prototype.serverPasswordInvalid = function() {
	return this.get("Server_PasswordInvalid");
}

Language.prototype.serverPlayerDisconnect = function() {
	return this.get("Server_PlayerDisconnect");
}

Language.prototype.serverPlayerJoin = function() {
	return this.get("Server_PlayerJoin");
}

Language.prototype.serverProgressDownloadingData = function() {
	return this.get("Server_ProgressDownloadingData");
}

Language.prototype.serverProgressDownloadingMap = function() {
	return this.get("Server_ProgressDownloadingMap");
}

Language.prototype.serverProgressGenerating = function() {
	return this.get("Server_ProgressGenerating");
}

Language.prototype.serverSetupAccept = function() {
	return this.get("Server_SetupAccept");
}

Language.prototype.serverSetupEnableHTTP = function() {
	return this.get("Server_SetupEnableHTTP");
}

Language.prototype.serverSetupFirstStart = function() {
	return this.get("Server_SetupFirstStart");
}

Language.prototype.serverSetupMOTD = function() {
	return this.get("Server_SetupMOTD");
}

Language.prototype.serverSetupMaxClients = function() {
	return this.get("Server_SetupMaxClients");
}

Language.prototype.serverSetupMaxClientsInvalidInput = function() {
	return this.get("Server_SetupMaxClientsInvalidInput");
}

Language.prototype.serverSetupMaxClientsInvalidValue = function() {
	return this.get("Server_SetupMaxClientsInvalidValue");
}

Language.prototype.serverSetupName = function() {
	return this.get("Server_SetupName");
}

Language.prototype.serverSetupPort = function() {
	return this.get("Server_SetupPort");
}

Language.prototype.serverSetupPortInvalidInput = function() {
	return this.get("Server_SetupPortInvalidInput");
}

Language.prototype.serverSetupPortInvalidValue = function() {
	return this.get("Server_SetupPortInvalidValue");
}

Language.prototype.serverSetupPublic = function() {
	return this.get("Server_SetupPublic");
}

Language.prototype.serverSetupQuestion = function() {
	return this.get("Server_SetupQuestion");
}

Language.prototype.serverSetupWelcomeMessage = function() {
	return this.get("Server_SetupWelcomeMessage");
}

Language.prototype.serverTooManyPlayers = function() {
	return this.get("Server_TooManyPlayers");
}

Language.prototype.serverUsernameBanned = function() {
	return this.get("Server_UsernameBanned");
}

Language.prototype.serverUsernameInvalid = function() {
	return this.get("Server_UsernameInvalid");
}

Language.prototype.shadowsOption = function() {
	return this.get("ShadowsOption");
}

Language.prototype.soundOption = function() {
	return this.get("SoundOption");
}

Language.prototype.spawnPositionSet = function() {
	return this.get("SpawnPositionSet");
}

Language.prototype.spawnPositionSetTo = function() {
	return this.get("SpawnPositionSetTo");
}

Language.prototype.useServerTexturesOption = function() {
	return this.get("UseServerTexturesOption");
}

Language.prototype.viewDistanceOption = function() {
	return this.get("ViewDistanceOption");
}

function LanguageCi()
{
	this.loadedLanguages = null;
	this.loadedLanguagesCount = 0;
	this.loadedLanguagesMax = 0;
	this.platform = null;
	this.strings = null;
	this.stringsCount = 0;
	this.stringsMax = 0;
	this.stringsMax = 32768;
	this.stringsCount = 0;
	this.strings = new Array(this.stringsMax);
	this.loadedLanguagesCount = 0;
	this.loadedLanguagesMax = 64;
	this.loadedLanguages = new Array(this.loadedLanguagesMax);
}
LanguageCi.prototype = new Language();

LanguageCi.prototype.add = function(language, id, translated) {
	if (this.isNewLanguage(language)) {
		if (this.loadedLanguagesCount < this.loadedLanguagesMax) {
			this.loadedLanguages[this.loadedLanguagesCount] = language;
			this.loadedLanguagesCount++;
		}
	}
	if (this.stringsCount > this.stringsMax) {
		return;
	}
	if (this.containsTranslation(language, id)) {
		return;
	}
	var s = new TranslatedString();
	s.language = language;
	s.id = id;
	s.translated = translated;
	this.strings[this.stringsCount++] = s;
}

LanguageCi.prototype.allStrings = function() {
	return this.strings;
}

LanguageCi.prototype.containsTranslation = function(language, id) {
	for (var i = 0; i < this.stringsCount; i++) {
		if (this.strings[i] == null) {
			continue;
		}
		if (this.strings[i].language == language) {
			if (this.strings[i].id == id) {
				return true;
			}
		}
	}
	return false;
}

LanguageCi.prototype.get = function(id) {
	var currentLanguage = "en";
	if (this.overrideLanguage != null) {
		currentLanguage = this.overrideLanguage;
	}
	else if (this.platform != null) {
		currentLanguage = this.platform.getLanguageIso6391();
	}
	for (var i = 0; i < this.stringsCount; i++) {
		if (this.strings[i] == null) {
			continue;
		}
		if (this.strings[i].id == id && this.strings[i].language == currentLanguage) {
			return this.strings[i].translated;
		}
	}
	for (var i = 0; i < this.stringsCount; i++) {
		if (this.strings[i] == null) {
			continue;
		}
		if (this.strings[i].id == id && this.strings[i].language == "en") {
			return this.strings[i].translated;
		}
	}
	return id;
}

LanguageCi.prototype.getUsedLanguage = function() {
	var currentLanguage = "en";
	if (this.overrideLanguage != null) {
		currentLanguage = this.overrideLanguage;
	}
	else if (this.platform != null) {
		currentLanguage = this.platform.getLanguageIso6391();
	}
	return currentLanguage;
}

LanguageCi.prototype.isNewLanguage = function(language) {
	for (var i = 0; i < this.loadedLanguagesMax; i++) {
		if (this.loadedLanguages[i] == null) {
			continue;
		}
		if (this.loadedLanguages[i] == language) {
			return false;
		}
	}
	return true;
}

LanguageCi.prototype.loadTranslations = function() {
	var fileCount = IntRef.create(0);
	var fileList = this.platform.directoryGetFiles(this.platform.pathCombine("data", "localization"), fileCount);
	for (var i = 0; i < fileCount.value; i++) {
		var lineCount = IntRef.create(0);
		var lineList = this.platform.fileReadAllLines(fileList[i], lineCount);
		for (var j = 1; j < lineCount.value; j++) {
			if (this.platform.stringEmpty(lineList[j])) {
				continue;
			}
			var splitCount = IntRef.create(0);
			var splitList = this.platform.stringSplit(lineList[j], "=", splitCount);
			if (splitCount.value >= 2) {
				this.add(lineList[0], splitList[0], splitList[1]);
			}
		}
	}
	this.addEnglish();
}

LanguageCi.prototype.nextLanguage = function() {
	if (this.overrideLanguage == null) {
		this.overrideLanguage = "en";
	}
	var languageIndex = -1;
	for (var i = 0; i < this.loadedLanguagesMax; i++) {
		if (this.loadedLanguages[i] == null) {
			continue;
		}
		if (this.loadedLanguages[i] == this.overrideLanguage) {
			languageIndex = i;
		}
	}
	if (languageIndex < 0) {
		languageIndex = 0;
	}
	languageIndex++;
	if (languageIndex >= this.loadedLanguagesMax || languageIndex >= this.loadedLanguagesCount) {
		languageIndex = 0;
	}
	this.overrideLanguage = this.loadedLanguages[languageIndex];
}

LanguageCi.prototype.override = function(language, id, translated) {
	if (this.isNewLanguage(language)) {
		if (this.loadedLanguagesCount < this.loadedLanguagesMax) {
			this.loadedLanguages[this.loadedLanguagesCount] = language;
			this.loadedLanguagesCount++;
		}
	}
	if (!this.containsTranslation(language, id)) {
		this.add(language, id, translated);
	}
	else {
		var replaceIndex = -1;
		for (var i = 0; i < this.stringsCount; i++) {
			if (this.strings[i] == null) {
				continue;
			}
			if (this.strings[i].language == language) {
				if (this.strings[i].id == id) {
					replaceIndex = i;
					break;
				}
			}
		}
		if (replaceIndex != -1) {
			var s = new TranslatedString();
			s.language = language;
			s.id = id;
			s.translated = translated;
			this.strings[replaceIndex] = s;
		}
	}
}

function LightBase()
{
	this.flood = null;
	this.workData = null;
	this.flood = new LightFlood();
	this.workData = new Int32Array(new ArrayBuffer(4096 << 2));
}

LightBase.prototype.calculateChunkBaseLight = function(game, cx, cy, cz, dataLightRadius, transparentForLight) {
	var chunk = game.map.getChunk_(cx, cy, cz);
	if (chunk.data != null) {
		for (var i = 0; i < 4096; i++) {
			this.workData[i] = chunk.data[i];
		}
	}
	if (chunk.dataInt != null) {
		for (var i = 0; i < 4096; i++) {
			this.workData[i] = chunk.dataInt[i];
		}
	}
	var sunlight = game.sunlight_;
	var workLight = chunk.baseLight;
	for (var i = 0; i < 4096; i++) {
		workLight[i] = 0;
	}
	LightBase.sunlight(game, cx, cy, cz, workLight, dataLightRadius, sunlight);
	this.sunlightFlood(this.workData, workLight, dataLightRadius, transparentForLight);
	this.lightEmitting(this.workData, workLight, dataLightRadius, transparentForLight);
}

LightBase.getLightHeight = function(game, cx, cy, xx, yy) {
	var chunk = game.d_Heightmap.chunks[MapUtilCi.index2d(cx, cy, Math.floor(game.map.mapSizeX / 16))];
	if (chunk == null) {
		return 0;
	}
	return chunk[MapUtilCi.index2d(xx % 16, yy % 16, 16)];
}

LightBase.prototype.lightEmitting = function(workportion, worklight, dataLightRadius, dataTransparent) {
	for (var pos = 0; pos < 4096; pos++) {
		if (workportion[pos] >= 10) {
			if (dataLightRadius[workportion[pos]] != 0) {
				if (dataLightRadius[workportion[pos]] > worklight[pos]) {
					var xx = MapUtilCi.posX(pos, 16, 16);
					var yy = MapUtilCi.posY(pos, 16, 16);
					var zz = MapUtilCi.posZ(pos, 16, 16);
					var l = dataLightRadius[workportion[pos]];
					worklight[pos] = Game.intToByte(MathCi.maxInt(l, worklight[pos]));
					this.flood.floodLight(workportion, worklight, xx, yy, zz, dataLightRadius, dataTransparent);
				}
			}
		}
	}
}

LightBase.sunlight = function(game, cx, cy, cz, worklight, dataLightRadius, sunlight) {
	var baseheight = cz * 16;
	for (var xx = 0; xx < 16; xx++) {
		for (var yy = 0; yy < 16; yy++) {
			var height = LightBase.getLightHeight(game, cx, cy, xx, yy);
			var h = height - baseheight;
			if (h < 0) {
				h = 0;
			}
			if (h > 16) {
				continue;
			}
			var pos = (h * 16 + yy) * 16 + xx;
			for (var zz = h; zz < 16; zz++) {
				worklight[pos] = Game.intToByte(sunlight);
				pos += 256;
			}
		}
	}
}

LightBase.prototype.sunlightFlood = function(workportion, worklight, dataLightRadius, dataTransparent) {
	for (var xx = 0; xx < 16; xx++) {
		for (var yy = 0; yy < 16; yy++) {
			for (var zz = 0; zz < 16; zz++) {
				var pos = (zz * 16 + yy) * 16 + xx;
				if (!dataTransparent[workportion[pos]]) {
					continue;
				}
				var curlight = worklight[pos];
				var posXPlus1 = pos + 1;
				var posYPlus1 = pos + 16;
				if (xx + 1 < 16 && worklight[posXPlus1] != curlight && dataTransparent[workportion[posXPlus1]]) {
					this.flood.floodLight(workportion, worklight, xx, yy, zz, dataLightRadius, dataTransparent);
					this.flood.floodLight(workportion, worklight, xx + 1, yy, zz, dataLightRadius, dataTransparent);
				}
				if (yy + 1 < 16 && worklight[posYPlus1] != curlight && dataTransparent[workportion[posYPlus1]]) {
					this.flood.floodLight(workportion, worklight, xx, yy, zz, dataLightRadius, dataTransparent);
					this.flood.floodLight(workportion, worklight, xx, yy + 1, zz, dataLightRadius, dataTransparent);
				}
			}
		}
	}
}

function LightBetweenChunks()
{
	this.chunksData = null;
	this.chunksLight = null;
	this.flood = null;
	this.chunksLight = new Array(27);
	for (var i = 0; i < 27; i++) {
		this.chunksLight[i] = new Uint8Array(new ArrayBuffer(4096));
	}
	this.chunksData = new Array(27);
	for (var i = 0; i < 27; i++) {
		this.chunksData[i] = new Int32Array(new ArrayBuffer(4096 << 2));
	}
	this.flood = new LightFlood();
}

LightBetweenChunks.prototype.arrayFillByte = function(arr, n, value) {
	for (var i = 0; i < n; i++) {
		arr[i] = value;
	}
}

LightBetweenChunks.prototype.arrayFillInt = function(arr, n, value) {
	for (var i = 0; i < n; i++) {
		arr[i] = value;
	}
}

LightBetweenChunks.prototype.calculateLightBetweenChunks = function(game, cx, cy, cz, dataLightRadius, dataTransparent) {
	this.input(game, cx, cy, cz);
	this.floodBetweenChunks_(dataLightRadius, dataTransparent);
	this.output(game, cx, cy, cz);
}

LightBetweenChunks.prototype.floodBetweenChunks = function(chunksLight_, cLight, dcLight, cx, cy, cz, dcx, dcy, dcz, xx, yy, zz, dxx, dyy, dzz, dataLightRadius, dataTransparent) {
	var sourceLight = cLight[(zz * 16 + yy) * 16 + xx];
	var targetLight = dcLight[(dzz * 16 + dyy) * 16 + dxx];
	if (targetLight < sourceLight - 1) {
		dcLight[(dzz * 16 + dyy) * 16 + dxx] = Game.intToByte(sourceLight - 1);
		this.flood.floodLight(this.chunksData[(dcz * 3 + dcy) * 3 + dcx], dcLight, dxx, dyy, dzz, dataLightRadius, dataTransparent);
	}
}

LightBetweenChunks.prototype.floodBetweenChunks_ = function(dataLightRadius, dataTransparent) {
	for (var i = 0; i < 2; i++) {
		for (var x = 0; x < 3; x++) {
			for (var y = 0; y < 3; y++) {
				for (var z = 0; z < 3; z++) {
					var clight = this.chunksLight[(z * 3 + y) * 3 + x];
					if (z < 2) {
						var dclight = this.chunksLight[((z + 1) * 3 + y) * 3 + x];
						for (var xx = 0; xx < 16; xx++) {
							for (var yy = 0; yy < 16; yy++) {
								this.floodBetweenChunks(this.chunksLight, clight, dclight, x, y, z, x, y, z + 1, xx, yy, 15, xx, yy, 0, dataLightRadius, dataTransparent);
							}
						}
					}
					if (z > 0) {
						var dclight = this.chunksLight[((z - 1) * 3 + y) * 3 + x];
						for (var xx = 0; xx < 16; xx++) {
							for (var yy = 0; yy < 16; yy++) {
								this.floodBetweenChunks(this.chunksLight, clight, dclight, x, y, z, x, y, z - 1, xx, yy, 0, xx, yy, 15, dataLightRadius, dataTransparent);
							}
						}
					}
					if (x < 2) {
						var dclight = this.chunksLight[(z * 3 + y) * 3 + x + 1];
						for (var yy = 0; yy < 16; yy++) {
							for (var zz = 0; zz < 16; zz++) {
								this.floodBetweenChunks(this.chunksLight, clight, dclight, x, y, z, x + 1, y, z, 15, yy, zz, 0, yy, zz, dataLightRadius, dataTransparent);
							}
						}
					}
					if (x > 0) {
						var dclight = this.chunksLight[(z * 3 + y) * 3 + x - 1];
						for (var yy = 0; yy < 16; yy++) {
							for (var zz = 0; zz < 16; zz++) {
								this.floodBetweenChunks(this.chunksLight, clight, dclight, x, y, z, x - 1, y, z, 0, yy, zz, 15, yy, zz, dataLightRadius, dataTransparent);
							}
						}
					}
					if (y < 2) {
						var dclight = this.chunksLight[(z * 3 + y + 1) * 3 + x];
						for (var xx = 0; xx < 16; xx++) {
							for (var zz = 0; zz < 16; zz++) {
								this.floodBetweenChunks(this.chunksLight, clight, dclight, x, y, z, x, y + 1, z, xx, 15, zz, xx, 0, zz, dataLightRadius, dataTransparent);
							}
						}
					}
					if (y > 0) {
						var dclight = this.chunksLight[(z * 3 + y - 1) * 3 + x];
						for (var xx = 0; xx < 16; xx++) {
							for (var zz = 0; zz < 16; zz++) {
								this.floodBetweenChunks(this.chunksLight, clight, dclight, x, y, z, x, y - 1, z, xx, 0, zz, xx, 15, zz, dataLightRadius, dataTransparent);
							}
						}
					}
				}
			}
		}
	}
}

LightBetweenChunks.prototype.input = function(game, cx, cy, cz) {
	for (var x = 0; x < 3; x++) {
		for (var y = 0; y < 3; y++) {
			for (var z = 0; z < 3; z++) {
				var pcx = cx + x - 1;
				var pcy = cy + y - 1;
				var pcz = cz + z - 1;
				if (!game.map.isValidChunkPos(pcx, pcy, pcz)) {
					this.arrayFillInt(this.chunksData[(z * 3 + y) * 3 + x], 4096, 0);
					this.arrayFillByte(this.chunksLight[(z * 3 + y) * 3 + x], 4096, 0);
					continue;
				}
				var p = game.map.getChunk_(pcx, pcy, pcz);
				var data = this.chunksData[(z * 3 + y) * 3 + x];
				if (p.data != null) {
					for (var i = 0; i < 4096; i++) {
						data[i] = p.data[i];
					}
				}
				if (p.dataInt != null) {
					for (var i = 0; i < 4096; i++) {
						data[i] = p.dataInt[i];
					}
				}
				var light = this.chunksLight[(z * 3 + y) * 3 + x];
				for (var i = 0; i < 4096; i++) {
					light[i] = p.baseLight[i];
				}
			}
		}
	}
}

LightBetweenChunks.prototype.output = function(game, cx, cy, cz) {
	var chunk = game.map.getChunk_(cx, cy, cz);
	for (var x = 0; x < 18; x++) {
		for (var y = 0; y < 18; y++) {
			for (var z = 0; z < 18; z++) {
				var baseglobalx = 15 + x;
				var baseglobaly = 15 + y;
				var baseglobalz = 15 + z;
				var light = 15;
				var basecx = Math.floor(baseglobalx / 16);
				var basecy = Math.floor(baseglobaly / 16);
				var basecz = Math.floor(baseglobalz / 16);
				{
					var basexx = baseglobalx % 16;
					var baseyy = baseglobaly % 16;
					var basezz = baseglobalz % 16;
					light = this.chunksLight[(basecz * 3 + basecy) * 3 + basecx][(basezz * 16 + baseyy) * 16 + basexx];
				}
				chunk.rendered.light[(z * 18 + y) * 18 + x] = light;
			}
		}
	}
}

function LightFlood()
{
	this.q = null;
	this.q = new FastQueueInt();
	this.q.initialize(1024);
}

LightFlood.prototype.floodLight = function(chunk, light, startx, starty, startz, dataLightRadius, dataTransparent) {
	var start = (startz * 16 + starty) * 16 + startx;
	if (light[start] == 0) {
		return;
	}
	this.q.clear();
	this.q.push(start);
	for (;;) {
		if (this.q.count == 0) {
			break;
		}
		var vPos = this.q.pop();
		var vLight = light[vPos];
		if (vLight == 0) {
			continue;
		}
		var vBlock = chunk[vPos];
		if (!dataTransparent[vBlock] && dataLightRadius[vBlock] == 0) {
			continue;
		}
		var x = MapUtilCi.posX(vPos, 16, 16);
		var y = MapUtilCi.posY(vPos, 16, 16);
		var z = MapUtilCi.posZ(vPos, 16, 16);
		if (x < 15) {
			LightFlood.push(this.q, light, vLight, vPos + 1);
		}
		if (x > 0) {
			LightFlood.push(this.q, light, vLight, vPos + -1);
		}
		if (y < 15) {
			LightFlood.push(this.q, light, vLight, vPos + 16);
		}
		if (y > 0) {
			LightFlood.push(this.q, light, vLight, vPos + -16);
		}
		if (z < 15) {
			LightFlood.push(this.q, light, vLight, vPos + 256);
		}
		if (z > 0) {
			LightFlood.push(this.q, light, vLight, vPos + -256);
		}
	}
}

LightFlood.push = function(q_, light, vLight, newPos) {
	if (light[newPos] < vLight - 1) {
		light[newPos] = Game.intToByte(vLight - 1);
		q_.push(newPos);
	}
}
LightFlood.X_MINUS = -1;
LightFlood.X_PLUS = 1;
LightFlood.Y_MINUS = -16;
LightFlood.Y_PLUS = 16;
LightFlood.Z_MINUS = -256;
LightFlood.Z_PLUS = 256;

function Line3D()
{
	this.end = null;
	this.start = null;
}

function ListAction()
{
	this.count = 0;
	this.items = null;
	this.max = 0;
}

ListAction.prototype.add = function(action) {
	this.items[this.count++] = action;
}

ListAction.prototype.clear = function() {
	for (var i = 0; i < this.count; i++) {
		this.items[i] = null;
	}
	this.count = 0;
}

ListAction.prototype.count = function() {
	return this.count;
}

ListAction.create = function(max_) {
	var l = new ListAction();
	l.start(max_);
	return l;
}

ListAction.prototype.removeAt = function(index) {
	for (var i = index; i < this.count - 1; i++) {
		this.items[i] = this.items[i + 1];
	}
	this.count--;
}

ListAction.prototype.start = function(max_) {
	this.max = max_;
	this.items = new Array(max_);
	this.count = 0;
}

function ListBox3d()
{
	this.arr = null;
	this.count = 0;
}

function ListConnectedPlayer()
{
	this.count = 0;
	this.items = null;
	this.items = new Array(1024);
	this.count = 0;
}

ListConnectedPlayer.prototype.add = function(connectedPlayer) {
	this.items[this.count++] = connectedPlayer;
}

ListConnectedPlayer.prototype.removeAt = function(at) {
	for (var i = at; i < this.count - 1; i++) {
		this.items[i] = this.items[i + 1];
	}
	this.count--;
}

function ListInfo()
{
	this.centerX = null;
	this.centerY = null;
	this.centerZ = null;
	this.empty = false;
	this.indicescount = 0;
	this.model = null;
	this.radius = null;
	this.render = false;
	this.texture = 0;
	this.transparent = false;
	this.render = true;
}

function LoginClientCi()
{
	this.loginPassword = null;
	this.loginPublicServerKey = null;
	this.loginToken = null;
	this.loginUser = null;
	this.loginResponse = null;
	this.loginResult = null;
	this.loginUrl = null;
	this.loginUrlResponse = null;
	this.resultLoginData = null;
	this.shouldLogin = false;
}

LoginClientCi.prototype.login = function(platform, user, password, publicServerKey, token, result, resultLoginData_) {
	this.loginResult = result;
	this.resultLoginData = resultLoginData_;
	result.value = LoginResult.CONNECTING;
	this.loginUser = user;
	this.loginPassword = password;
	this.loginToken = token;
	this.loginPublicServerKey = publicServerKey;
	this.shouldLogin = true;
}

LoginClientCi.prototype.update = function(platform) {
	if (this.loginResult == null) {
		return;
	}
	if (this.loginUrlResponse == null && this.loginUrl == null) {
		this.loginUrlResponse = new HttpResponseCi();
		platform.webClientDownloadDataAsync("http://manicdigger.sourceforge.net/login.php", this.loginUrlResponse);
	}
	if (this.loginUrlResponse != null && this.loginUrlResponse.done) {
		this.loginUrl = platform.stringFromUtf8ByteArray(this.loginUrlResponse.value, this.loginUrlResponse.valueLength);
		this.loginUrlResponse = null;
	}
	if (this.loginUrl != null) {
		if (this.shouldLogin) {
			this.shouldLogin = false;
			var requestString = platform.stringFormat4("username={0}&password={1}&server={2}&token={3}", this.loginUser, this.loginPassword, this.loginPublicServerKey, this.loginToken);
			var byteArrayLength = new IntRef();
			var byteArray = platform.stringToUtf8ByteArray(requestString, byteArrayLength);
			this.loginResponse = new HttpResponseCi();
			platform.webClientUploadDataAsync(this.loginUrl, byteArray, byteArrayLength.value, this.loginResponse);
		}
		if (this.loginResponse != null && this.loginResponse.done) {
			var responseString = platform.stringFromUtf8ByteArray(this.loginResponse.value, this.loginResponse.valueLength);
			this.resultLoginData.passwordCorrect = !(platform.stringContains(responseString, "Wrong username") || platform.stringContains(responseString, "Incorrect username"));
			this.resultLoginData.serverCorrect = !platform.stringContains(responseString, "server");
			if (this.resultLoginData.passwordCorrect) {
				this.loginResult.value = LoginResult.OK;
			}
			else {
				this.loginResult.value = LoginResult.FAILED;
			}
			var linesCount = new IntRef();
			var lines = platform.readAllLines(responseString, linesCount);
			if (linesCount.value >= 3) {
				this.resultLoginData.authCode = lines[0];
				this.resultLoginData.serverAddress = lines[1];
				this.resultLoginData.port = platform.intParse(lines[2]);
				this.resultLoginData.token = lines[3];
			}
			this.loginResponse = null;
		}
	}
}

function LoginData()
{
	this.authCode = null;
	this.passwordCorrect = false;
	this.port = 0;
	this.serverAddress = null;
	this.serverCorrect = false;
	this.token = null;
}

var LoginResult = {
	NONE : 0,
	CONNECTING : 1,
	FAILED : 2,
	OK : 3
}

function LoginResultRef()
{
	this.value = LoginResult.NONE;
}

function MainMenu()
{
	this.assets = null;
	this.assetsLoadProgress = null;
	this.backgroundH = 0;
	this.backgroundW = 0;
	this.cubeModel = null;
	this.currentlyPressedKeys = null;
	this.filter = 0;
	this.fontMenuHeading = null;
	this.initialized = false;
	this.lang = null;
	this.loginClient = null;
	this.minspeed = 0;
	this.mousePressed = false;
	this.mvMatrix = null;
	this.one = null;
	this.overlap = 0;
	this.p = null;
	this.pMatrix = null;
	this.previousMouseX = 0;
	this.previousMouseY = 0;
	this.previousTouchX = 0;
	this.previousTouchY = 0;
	this.rnd = null;
	this.screen = null;
	this.textColorRenderer = null;
	this.textTextures = null;
	this.textTexturesCount = 0;
	this.textures = null;
	this.touchId = 0;
	this.viewportHeight = 0;
	this.viewportWidth = 0;
	this.windowX = null;
	this.windowY = null;
	this.xInv = false;
	this.xRot = null;
	this.xSpeed = null;
	this.yInv = false;
	this.yRot = null;
	this.ySpeed = null;
	this.z = null;
	this.one = 1;
	this.textures = new DictionaryStringInt1024();
	this.textTextures = new Array(256);
	this.textTexturesCount = 0;
	this.screen = new ScreenMain();
	this.screen.menu = this;
	this.loginClient = new LoginClientCi();
	this.assets = new AssetList();
	this.assetsLoadProgress = new FloatRef();
	this.fontMenuHeading = new FontCi();
	this.fontMenuHeading.size = 20;
}

MainMenu.prototype.animate = function(dt) {
	var maxDt = 1;
	if (dt > maxDt) {
		dt = maxDt;
	}
	if (this.xInv) {
		if (this.xRot <= -this.overlap) {
			this.xInv = false;
			this.xSpeed = this.minspeed + this.rnd.maxNext(5);
		}
		this.xRot -= this.xSpeed * dt;
	}
	else {
		if (this.xRot >= this.overlap) {
			this.xInv = true;
			this.xSpeed = this.minspeed + this.rnd.maxNext(5);
		}
		this.xRot += this.xSpeed * dt;
	}
	if (this.yInv) {
		if (this.yRot <= -this.overlap) {
			this.yInv = false;
			this.ySpeed = this.minspeed + this.rnd.maxNext(5);
		}
		this.yRot -= this.ySpeed * dt;
	}
	else {
		if (this.yRot >= this.overlap) {
			this.yInv = true;
			this.ySpeed = this.minspeed + this.rnd.maxNext(5);
		}
		this.yRot += this.ySpeed * dt;
	}
}

MainMenu.prototype.charRepeat = function(c, length) {
	var charArray = new Int32Array(new ArrayBuffer(length << 2));
	for (var i = 0; i < length; i++) {
		charArray[i] = c;
	}
	return this.p.charArrayToString(charArray, length);
}

MainMenu.prototype.charToString = function(a) {
	var arr = new Int32Array(new ArrayBuffer(1 << 2));
	arr[0] = a;
	return this.p.charArrayToString(arr, 1);
}

MainMenu.prototype.connectToGame = function(loginResultData, username) {
	var connectData = new ConnectData();
	connectData.ip = loginResultData.serverAddress;
	connectData.port = loginResultData.port;
	connectData.auth = loginResultData.authCode;
	connectData.username = username;
	this.startGame(false, null, connectData);
}

MainMenu.prototype.connectToSingleplayer = function(filename) {
	this.startGame(true, filename, null);
}

MainMenu.prototype.createAccount = function(user, password, loginResult) {
	if (user == "" || password == "") {
		loginResult.value = LoginResult.FAILED;
	}
	else {
		loginResult.value = LoginResult.OK;
	}
}

MainMenu.prototype.draw2dQuad = function(textureid, dx, dy, dw, dh) {
	Mat4.identity_(this.mvMatrix);
	Mat4.translate(this.mvMatrix, this.mvMatrix, Vec3.fromValues(dx, dy, 0));
	Mat4.scale(this.mvMatrix, this.mvMatrix, Vec3.fromValues(dw, dh, 0));
	Mat4.scale(this.mvMatrix, this.mvMatrix, Vec3.fromValues(this.one / (2), this.one / (2), 0));
	Mat4.translate(this.mvMatrix, this.mvMatrix, Vec3.fromValues(this.one, this.one, 0));
	this.setMatrixUniforms();
	if (this.cubeModel == null) {
		this.cubeModel = this.p.createModel(QuadModelData.getQuadModelData());
	}
	this.p.bindTexture2d(textureid);
	this.p.gLDisableAlphaTest();
	this.p.drawModel(this.cubeModel);
	this.p.gLEnableAlphaTest();
}

MainMenu.prototype.drawBackground = function() {
	this.backgroundW = 512;
	this.backgroundH = 512;
	this.windowX = this.p.getCanvasWidth();
	this.windowY = this.p.getCanvasHeight();
	var countX = this.p.floatToInt((this.windowX + 2 * this.overlap) / (this.backgroundW)) + 1;
	var countY = this.p.floatToInt((this.windowY + 2 * this.overlap) / (this.backgroundH)) + 1;
	for (var x = 0; x < countX; x++) {
		for (var y = 0; y < countY; y++) {
			this.draw2dQuad(this.getTexture("background.png"), x * this.backgroundW + this.xRot - this.overlap, y * this.backgroundH + this.yRot - this.overlap, this.backgroundW, this.backgroundH);
		}
	}
}

MainMenu.prototype.drawButton = function(text, font, dx, dy, dw, dh, pressed) {
	this.draw2dQuad(pressed ? this.getTexture("button_sel.png") : this.getTexture("button.png"), dx, dy, dw, dh);
	if (text != null && text != "") {
		this.drawText(text, font, dx + dw / (2), dy + dh / (2), TextAlign.CENTER, TextBaseline.MIDDLE);
	}
}

MainMenu.prototype.drawScene = function(dt) {
	this.p.glViewport(0, 0, this.viewportWidth, this.viewportHeight);
	this.p.glClearColorBufferAndDepthBuffer();
	this.p.glDisableDepthTest();
	this.p.glDisableCullFace();
	{
	}
	{
		Mat4.identity_(this.pMatrix);
		Mat4.ortho(this.pMatrix, 0, this.p.getCanvasWidth(), this.p.getCanvasHeight(), 0, 0, 10);
	}
	this.screen.render(dt);
}

MainMenu.prototype.drawText = function(text, font, x, y, align, baseline) {
	var t = this.getTextTexture(text, font);
	var dx = 0;
	var dy = 0;
	if (align == TextAlign.CENTER) {
		dx -= Math.floor(t.textwidth / 2);
	}
	if (align == TextAlign.RIGHT) {
		dx -= t.textwidth;
	}
	if (baseline == TextBaseline.MIDDLE) {
		dy -= Math.floor(t.textheight / 2);
	}
	if (baseline == TextBaseline.BOTTOM) {
		dy -= t.textheight;
	}
	this.draw2dQuad(t.texture, x + dx, y + dy, t.texturewidth, t.textureheight);
}

MainMenu.prototype.exit = function() {
	this.p.exit();
}

MainMenu.prototype.getFile = function(name) {
	var pLowercase = this.p.stringToLower(name);
	for (var i = 0; i < this.assets.count; i++) {
		if (this.assets.items[i].name == pLowercase) {
			return this.assets.items[i].data;
		}
	}
	return null;
}

MainMenu.prototype.getFileLength = function(name) {
	var pLowercase = this.p.stringToLower(name);
	for (var i = 0; i < this.assets.count; i++) {
		if (this.assets.items[i].name == pLowercase) {
			return this.assets.items[i].dataLength;
		}
	}
	return 0;
}

MainMenu.prototype.getSavegames = function(length) {
	var files = this.p.directoryGetFiles(this.p.pathSavegames(), length);
	var savegames = new Array(length.value);
	var count = 0;
	for (var i = 0; i < length.value; i++) {
		if (this.stringEndsWith(files[i], ".mddbs")) {
			savegames[count++] = files[i];
		}
	}
	length.value = count;
	return savegames;
}

MainMenu.prototype.getScale = function() {
	var scale;
	if (this.p.isSmallScreen()) {
		scale = (this.one * this.p.getCanvasWidth()) / (1280);
	}
	else {
		scale = this.one;
	}
	return scale;
}

MainMenu.prototype.getTextTexture = function(text, font) {
	for (var i = 0; i < this.textTexturesCount; i++) {
		var t = this.textTextures[i];
		if (t == null) {
			continue;
		}
		if (t.text == text && t.font.size == font.size && t.font.family == font.family && t.font.style == font.style) {
			return t;
		}
	}
	var textTexture = new TextTexture();
	var text_ = new Text_();
	text_.text = text;
	text_.font = font;
	text_.color = Game.colorFromArgb(255, 255, 255, 255);
	var textBitmap = this.textColorRenderer.createTextTexture(text_);
	var texture = this.p.loadTextureFromBitmap(textBitmap);
	var textWidth = new IntRef();
	var textHeight = new IntRef();
	this.p.textSize(text, font, textWidth, textHeight);
	textTexture.texture = texture;
	textTexture.texturewidth = this.p.floatToInt(this.p.bitmapGetWidth(textBitmap));
	textTexture.textureheight = this.p.floatToInt(this.p.bitmapGetHeight(textBitmap));
	textTexture.text = text;
	textTexture.font = font;
	textTexture.textwidth = textWidth.value;
	textTexture.textheight = textHeight.value;
	this.p.bitmapDelete(textBitmap);
	this.textTextures[this.textTexturesCount++] = textTexture;
	return textTexture;
}

MainMenu.prototype.getTexture = function(name) {
	if (!this.textures.contains(name)) {
		var found = new BoolRef();
		var bmp = this.p.bitmapCreateFromPng(this.getFile(name), this.getFileLength(name));
		var texture = this.p.loadTextureFromBitmap(bmp);
		this.textures.set(name, texture);
		this.p.bitmapDelete(bmp);
	}
	return this.textures.get(name);
}

MainMenu.prototype.handleKeyDown = function(e) {
	this.currentlyPressedKeys[e.getKeyCode()] = true;
	this.screen.onKeyDown(e);
}

MainMenu.prototype.handleKeyPress = function(e) {
	if (e.getKeyChar() == 70 || e.getKeyChar() == 102) {
		this.filter += 1;
		if (this.filter == 3) {
			this.filter = 0;
		}
	}
	if (e.getKeyChar() == 96) {
		this.screen.onBackPressed();
	}
	this.screen.onKeyPress(e);
}

MainMenu.prototype.handleKeyUp = function(e) {
	this.currentlyPressedKeys[e.getKeyCode()] = false;
	this.screen.onKeyUp(e);
}

MainMenu.prototype.handleMouseDown = function(e) {
	this.mousePressed = true;
	this.previousMouseX = e.getX();
	this.previousMouseY = e.getY();
	this.screen.onMouseDown(e);
}

MainMenu.prototype.handleMouseMove = function(e) {
	var dx = e.getMovementX();
	var dy = e.getMovementY();
	this.previousMouseX = e.getX();
	this.previousMouseY = e.getY();
	if (this.mousePressed) {
	}
	this.screen.onMouseMove(e);
}

MainMenu.prototype.handleMouseUp = function(e) {
	this.mousePressed = false;
	this.screen.onMouseUp(e);
}

MainMenu.prototype.handleMouseWheel = function(e) {
	this.z += e.getDeltaPrecise() / (5);
	this.screen.onMouseWheel(e);
}

MainMenu.prototype.handleTouchEnd = function(e) {
	this.screen.onTouchEnd(e);
}

MainMenu.prototype.handleTouchMove = function(e) {
	this.screen.onTouchMove(e);
	if (e.getId() != this.touchId) {
		return;
	}
	var dx = e.getX() - this.previousTouchX;
	var dy = e.getY() - this.previousTouchY;
	this.previousTouchX = e.getX();
	this.previousTouchY = e.getY();
	this.ySpeed += dx / (10);
	this.xSpeed += dy / (10);
}

MainMenu.prototype.handleTouchStart = function(e) {
	this.touchId = e.getId();
	this.previousTouchX = e.getX();
	this.previousTouchY = e.getY();
	this.screen.onTouchStart(e);
}

MainMenu.prototype.login = function(user, password, serverHash, token, loginResult, loginResultData) {
	if (user == "" || password == "" && token == "") {
		loginResult.value = LoginResult.FAILED;
	}
	else {
		this.loginClient.login(this.p, user, password, serverHash, token, loginResult, loginResultData);
	}
}

MainMenu.prototype.onNewFrame = function(args) {
	if (!this.initialized) {
		this.initialized = true;
		this.p.initShaders();
		this.p.glClearColorRgbaf(0, 0, 0, 1);
		this.p.glEnableDepthTest();
	}
	this.viewportWidth = this.p.getCanvasWidth();
	this.viewportHeight = this.p.getCanvasHeight();
	this.drawScene(args.getDt());
	this.animate(args.getDt());
	this.loginClient.update(this.p);
}

MainMenu.prototype.setMatrixUniforms = function() {
	this.p.setMatrixUniformProjection(this.pMatrix);
	this.p.setMatrixUniformModelView(this.mvMatrix);
}

MainMenu.prototype.start = function(p_) {
	this.p = p_;
	this.lang = new LanguageCi();
	this.lang.platform = this.p;
	this.lang.loadTranslations();
	this.p.setTitle(this.lang.gameName());
	this.textColorRenderer = new TextColorRenderer();
	this.textColorRenderer.platform = p_;
	p_.loadAssetsAsyc(this.assets, this.assetsLoadProgress);
	this.overlap = 200;
	this.minspeed = 20;
	this.rnd = this.p.randomCreate();
	this.xRot = 0;
	this.xInv = false;
	this.xSpeed = this.minspeed + this.rnd.maxNext(5);
	this.yRot = 0;
	this.yInv = false;
	this.ySpeed = this.minspeed + this.rnd.maxNext(5);
	this.z = -5;
	this.filter = 0;
	this.mvMatrix = Mat4.create();
	this.pMatrix = Mat4.create();
	this.currentlyPressedKeys = new Array(256);
	this.p.addOnNewFrame(MainMenuNewFrameHandler.create(this));
	this.p.addOnKeyEvent(MainMenuKeyEventHandler.create(this));
	this.p.addOnMouseEvent(MainMenuMouseEventHandler.create(this));
	this.p.addOnTouchEvent(MainMenuTouchEventHandler.create(this));
}

MainMenu.prototype.startConnectToIp = function() {
	var screenConnectToIp = new ScreenConnectToIp();
	this.screen = screenConnectToIp;
	this.screen.menu = this;
	this.screen.loadTranslations();
}

MainMenu.prototype.startGame = function(singleplayer, singleplayerSavePath, connectData) {
	var screenGame = new ScreenGame();
	screenGame.menu = this;
	screenGame.start(this.p, singleplayer, singleplayerSavePath, connectData);
	this.screen = screenGame;
}

MainMenu.prototype.startLogin = function(serverHash, ip, port) {
	var screenLogin = new ScreenLogin();
	screenLogin.serverHash = serverHash;
	screenLogin.serverIp = ip;
	screenLogin.serverPort = port;
	this.screen = screenLogin;
	this.screen.menu = this;
	this.screen.loadTranslations();
}

MainMenu.prototype.startMainMenu = function() {
	this.screen = new ScreenMain();
	this.screen.menu = this;
	this.p.exitMousePointerLock();
}

MainMenu.prototype.startModifyWorld = function() {
}

MainMenu.prototype.startMultiplayer = function() {
	this.screen = new ScreenMultiplayer();
	this.screen.menu = this;
	this.screen.loadTranslations();
}

MainMenu.prototype.startNewWorld = function() {
}

MainMenu.prototype.startSingleplayer = function() {
	this.screen = new ScreenSingleplayer();
	this.screen.menu = this;
	this.screen.loadTranslations();
}

MainMenu.prototype.stringEndsWith = function(s, value) {
	return StringTools.stringSubstring(this.p, s, this.stringLength(s) - this.stringLength(value), this.stringLength(value)) == value;
}

MainMenu.prototype.stringLength = function(a) {
	var length = new IntRef();
	this.p.stringToCharArray(a, length);
	return length.value;
}

MainMenu.prototype.degToRad = function(degrees) {
	return (degrees * GlMatrixMath.pI()) / (180);
}

function MainMenuKeyEventHandler()
{
	this.l = null;
}
MainMenuKeyEventHandler.prototype = new KeyEventHandler();

MainMenuKeyEventHandler.create = function(l) {
	var h = new MainMenuKeyEventHandler();
	h.l = l;
	return h;
}

MainMenuKeyEventHandler.prototype.onKeyDown = function(e) {
	this.l.handleKeyDown(e);
}

MainMenuKeyEventHandler.prototype.onKeyPress = function(e) {
	this.l.handleKeyPress(e);
}

MainMenuKeyEventHandler.prototype.onKeyUp = function(e) {
	this.l.handleKeyUp(e);
}

function MouseEventHandler()
{
}

function MainMenuMouseEventHandler()
{
	this.l = null;
}
MainMenuMouseEventHandler.prototype = new MouseEventHandler();

MainMenuMouseEventHandler.create = function(l) {
	var h = new MainMenuMouseEventHandler();
	h.l = l;
	return h;
}

MainMenuMouseEventHandler.prototype.onMouseDown = function(e) {
	this.l.handleMouseDown(e);
}

MainMenuMouseEventHandler.prototype.onMouseMove = function(e) {
	this.l.handleMouseMove(e);
}

MainMenuMouseEventHandler.prototype.onMouseUp = function(e) {
	this.l.handleMouseUp(e);
}

MainMenuMouseEventHandler.prototype.onMouseWheel = function(e) {
	this.l.handleMouseWheel(e);
}

function NewFrameHandler()
{
}

function MainMenuNewFrameHandler()
{
	this.l = null;
}
MainMenuNewFrameHandler.prototype = new NewFrameHandler();

MainMenuNewFrameHandler.create = function(l) {
	var h = new MainMenuNewFrameHandler();
	h.l = l;
	return h;
}

MainMenuNewFrameHandler.prototype.onNewFrame = function(args) {
	this.l.onNewFrame(args);
}

function TouchEventHandler()
{
}

function MainMenuTouchEventHandler()
{
	this.l = null;
}
MainMenuTouchEventHandler.prototype = new TouchEventHandler();

MainMenuTouchEventHandler.create = function(l) {
	var h = new MainMenuTouchEventHandler();
	h.l = l;
	return h;
}

MainMenuTouchEventHandler.prototype.onTouchEnd = function(e) {
	this.l.handleTouchEnd(e);
}

MainMenuTouchEventHandler.prototype.onTouchMove = function(e) {
	this.l.handleTouchMove(e);
}

MainMenuTouchEventHandler.prototype.onTouchStart = function(e) {
	this.l.handleTouchStart(e);
}

function Map()
{
	this.mapSizeX = 0;
	this.mapSizeY = 0;
	this.mapSizeZ = 0;
	this.chunks = null;
}

Map.prototype.copyChunk = function(chunk, output) {
	var n = 4096;
	if (chunk.dataInt != null) {
		for (var i = 0; i < n; i++) {
			output[i] = chunk.dataInt[i];
		}
	}
	else {
		for (var i = 0; i < n; i++) {
			output[i] = chunk.data[i];
		}
	}
}

Map.prototype.fillChunk = function(destination, destinationchunksize, sourcex, sourcey, sourcez, source, sourcechunksizeX, sourcechunksizeY, sourcechunksizeZ) {
	for (var x = 0; x < destinationchunksize; x++) {
		for (var y = 0; y < destinationchunksize; y++) {
			for (var z = 0; z < destinationchunksize; z++) {
				{
					destination.setBlockInChunk((z * destinationchunksize + y) * destinationchunksize + x, source[((z + sourcez) * sourcechunksizeY + y + sourcey) * sourcechunksizeX + x + sourcex]);
				}
			}
		}
	}
}

Map.prototype.getBlock = function(x, y, z) {
	if (!this.isValidPos(x, y, z)) {
		return 0;
	}
	return this.getBlockValid(x, y, z);
}

Map.prototype.getBlockValid = function(x, y, z) {
	var cx = x >> 4;
	var cy = y >> 4;
	var cz = z >> 4;
	var chunkpos = (cz * (this.mapSizeY >> 4) + cy) * (this.mapSizeX >> 4) + cx;
	if (this.chunks[chunkpos] == null) {
		return 0;
	}
	else {
		var pos = ((z & 15) * 16 + (y & 15)) * 16 + (x & 15);
		return this.chunks[chunkpos].getBlockInChunk(pos);
	}
}

Map.prototype.getChunk = function(x, y, z) {
	x = Math.floor(x / 16);
	y = Math.floor(y / 16);
	z = Math.floor(z / 16);
	return this.getChunk_(x, y, z);
}

Map.prototype.getChunk_ = function(cx, cy, cz) {
	var mapsizexchunks = Math.floor(this.mapSizeX / 16);
	var mapsizeychunks = Math.floor(this.mapSizeY / 16);
	var chunk = this.chunks[(cz * mapsizeychunks + cy) * mapsizexchunks + cx];
	if (chunk == null) {
		var c = new Chunk();
		c.data = new Uint8Array(new ArrayBuffer(4096));
		c.baseLight = new Uint8Array(new ArrayBuffer(4096));
		this.chunks[(cz * mapsizeychunks + cy) * mapsizexchunks + cx] = c;
		return this.chunks[(cz * mapsizeychunks + cy) * mapsizexchunks + cx];
	}
	return chunk;
}

Map.prototype.getMapPortion = function(outPortion, x, y, z, portionsizex, portionsizey, portionsizez) {
	var outPortionCount = portionsizex * portionsizey * portionsizez;
	for (var i = 0; i < outPortionCount; i++) {
		outPortion[i] = 0;
	}
	var mapchunksx = Math.floor(this.mapSizeX / 16);
	var mapchunksy = Math.floor(this.mapSizeY / 16);
	var mapchunksz = Math.floor(this.mapSizeZ / 16);
	var mapsizechunks = mapchunksx * mapchunksy * mapchunksz;
	for (var xx = 0; xx < portionsizex; xx++) {
		for (var yy = 0; yy < portionsizey; yy++) {
			for (var zz = 0; zz < portionsizez; zz++) {
				var cx = x + xx >> 4;
				var cy = y + yy >> 4;
				var cz = z + zz >> 4;
				var cpos = (cz * mapchunksy + cy) * mapchunksx + cx;
				if (cpos < 0 || cpos >= mapsizechunks) {
					continue;
				}
				var chunk = this.chunks[cpos];
				if (chunk == null || !chunk.chunkHasData()) {
					continue;
				}
				var chunkGlobalX = cx << 4;
				var chunkGlobalY = cy << 4;
				var chunkGlobalZ = cz << 4;
				var inChunkX = x + xx - chunkGlobalX;
				var inChunkY = y + yy - chunkGlobalY;
				var inChunkZ = z + zz - chunkGlobalZ;
				var pos = ((inChunkZ << 4) + inChunkY << 4) + inChunkX;
				var block = chunk.getBlockInChunk(pos);
				outPortion[(zz * portionsizey + yy) * portionsizex + xx] = block;
			}
		}
	}
}

Map.prototype.isChunkRendered = function(cx, cy, cz) {
	var c = this.chunks[MapUtilCi.index3d(cx, cy, cz, this.mapsizexchunks(), this.mapsizeychunks())];
	if (c == null) {
		return false;
	}
	return c.rendered != null && c.rendered.ids != null;
}

Map.prototype.isValidChunkPos = function(cx, cy, cz) {
	return cx >= 0 && cy >= 0 && cz >= 0 && cx < Math.floor(this.mapSizeX / 16) && cy < Math.floor(this.mapSizeY / 16) && cz < Math.floor(this.mapSizeZ / 16);
}

Map.prototype.isValidPos = function(x, y, z) {
	if (x < 0 || y < 0 || z < 0) {
		return false;
	}
	if (x >= this.mapSizeX || y >= this.mapSizeY || z >= this.mapSizeZ) {
		return false;
	}
	return true;
}

Map.prototype.maybeGetLight = function(x, y, z) {
	var light = -1;
	var cx = Math.floor(x / 16);
	var cy = Math.floor(y / 16);
	var cz = Math.floor(z / 16);
	if (this.isValidPos(x, y, z) && this.isValidChunkPos(cx, cy, cz)) {
		var c = this.chunks[MapUtilCi.index3d(cx, cy, cz, this.mapsizexchunks(), this.mapsizeychunks())];
		if (c == null || c.rendered == null || c.rendered.light == null) {
			light = -1;
		}
		else {
			light = c.rendered.light[MapUtilCi.index3d(x % 16 + 1, y % 16 + 1, z % 16 + 1, 18, 18)];
		}
	}
	return light;
}

Map.prototype.reset = function(sizex, sizey, sizez) {
	this.mapSizeX = sizex;
	this.mapSizeY = sizey;
	this.mapSizeZ = sizez;
	this.chunks = new Array(Math.floor(sizex / 16) * Math.floor(sizey / 16) * Math.floor(sizez / 16));
}

Map.prototype.setBlockDirty = function(x, y, z) {
	var around = ModDrawTerrain.blocksAround7(Vector3IntRef.create(x, y, z));
	for (var i = 0; i < 7; i++) {
		var a = around[i];
		var xx = a.x;
		var yy = a.y;
		var zz = a.z;
		if (xx < 0 || yy < 0 || zz < 0 || xx >= this.mapSizeX || yy >= this.mapSizeY || zz >= this.mapSizeZ) {
			return;
		}
		this.setChunkDirty(Math.floor(xx / 16), Math.floor(yy / 16), Math.floor(zz / 16), true, true);
	}
}

Map.prototype.setBlockRaw = function(x, y, z, tileType) {
	var chunk = this.getChunk(x, y, z);
	var pos = (z % 16 * 16 + y % 16) * 16 + x % 16;
	chunk.setBlockInChunk(pos, tileType);
}

Map.prototype.setChunkDirty = function(cx, cy, cz, dirty, blockschanged) {
	if (!this.isValidChunkPos(cx, cy, cz)) {
		return;
	}
	var c = this.chunks[MapUtilCi.index3d(cx, cy, cz, this.mapsizexchunks(), this.mapsizeychunks())];
	if (c == null) {
		return;
	}
	if (c.rendered == null) {
		c.rendered = new RenderedChunk();
	}
	c.rendered.dirty = dirty;
	if (blockschanged) {
		c.baseLightDirty = true;
	}
}

Map.prototype.setChunksAroundDirty = function(cx, cy, cz) {
	if (this.isValidChunkPos(cx, cy, cz)) {
		this.setChunkDirty(cx - 1, cy, cz, true, false);
	}
	if (this.isValidChunkPos(cx - 1, cy, cz)) {
		this.setChunkDirty(cx - 1, cy, cz, true, false);
	}
	if (this.isValidChunkPos(cx + 1, cy, cz)) {
		this.setChunkDirty(cx + 1, cy, cz, true, false);
	}
	if (this.isValidChunkPos(cx, cy - 1, cz)) {
		this.setChunkDirty(cx, cy - 1, cz, true, false);
	}
	if (this.isValidChunkPos(cx, cy + 1, cz)) {
		this.setChunkDirty(cx, cy + 1, cz, true, false);
	}
	if (this.isValidChunkPos(cx, cy, cz - 1)) {
		this.setChunkDirty(cx, cy, cz - 1, true, false);
	}
	if (this.isValidChunkPos(cx, cy, cz + 1)) {
		this.setChunkDirty(cx, cy, cz + 1, true, false);
	}
}

Map.prototype.setMapPortion = function(x, y, z, chunk, sizeX, sizeY, sizeZ) {
	var chunksizex = sizeX;
	var chunksizey = sizeY;
	var chunksizez = sizeZ;
	var chunksize = 16;
	var localchunks = new Array(Math.floor(chunksizex / chunksize) * Math.floor(chunksizey / chunksize) * Math.floor(chunksizez / chunksize));
	for (var cx = 0; cx < Math.floor(chunksizex / chunksize); cx++) {
		for (var cy = 0; cy < Math.floor(chunksizey / chunksize); cy++) {
			for (var cz = 0; cz < Math.floor(chunksizex / chunksize); cz++) {
				localchunks[(cz * Math.floor(chunksizey / chunksize) + cy) * Math.floor(chunksizex / chunksize) + cx] = this.getChunk(x + cx * chunksize, y + cy * chunksize, z + cz * chunksize);
				this.fillChunk(localchunks[(cz * Math.floor(chunksizey / chunksize) + cy) * Math.floor(chunksizex / chunksize) + cx], chunksize, cx * chunksize, cy * chunksize, cz * chunksize, chunk, sizeX, sizeY, sizeZ);
			}
		}
	}
	for (var xxx = 0; xxx < chunksizex; xxx += chunksize) {
		for (var yyy = 0; yyy < chunksizex; yyy += chunksize) {
			for (var zzz = 0; zzz < chunksizex; zzz += chunksize) {
				this.setChunkDirty(Math.floor((x + xxx) / chunksize), Math.floor((y + yyy) / chunksize), Math.floor((z + zzz) / chunksize), true, true);
				this.setChunksAroundDirty(Math.floor((x + xxx) / chunksize), Math.floor((y + yyy) / chunksize), Math.floor((z + zzz) / chunksize));
			}
		}
	}
}

Map.prototype.mapsizexchunks = function() {
	return this.mapSizeX >> 4;
}

Map.prototype.mapsizeychunks = function() {
	return this.mapSizeY >> 4;
}

Map.prototype.mapsizezchunks = function() {
	return this.mapSizeZ >> 4;
}

function MapLoadingProgressEventArgs()
{
	this.progressBytes = 0;
	this.progressPercent = 0;
	this.progressStatus = null;
}

function MapStorage2()
{
	this.game = null;
}
MapStorage2.prototype = new IMapStorage2();

MapStorage2.create = function(game) {
	var s = new MapStorage2();
	s.game = game;
	return s;
}

MapStorage2.prototype.getBlock = function(x, y, z) {
	return this.game.map.getBlock(x, y, z);
}

MapStorage2.prototype.getMapSizeX = function() {
	return this.game.map.mapSizeX;
}

MapStorage2.prototype.getMapSizeY = function() {
	return this.game.map.mapSizeY;
}

MapStorage2.prototype.getMapSizeZ = function() {
	return this.game.map.mapSizeZ;
}

MapStorage2.prototype.setBlock = function(x, y, z, tileType) {
	this.game.setBlock(x, y, z, tileType);
}

function MapUtilCi()
{
}

MapUtilCi.index2d = function(x, y, sizex) {
	return x + y * sizex;
}

MapUtilCi.index3d = function(x, y, h, sizex, sizey) {
	return (h * sizey + y) * sizex + x;
}

MapUtilCi.pos = function(index, sizex, sizey, ret) {
	var x = index % sizex;
	var y = Math.floor(index / sizex) % sizey;
	var h = Math.floor(index / (sizex * sizey));
	ret.x = x;
	ret.y = y;
	ret.z = h;
}

MapUtilCi.posInt = function(index, sizex, sizey, ret) {
	var x = index % sizex;
	var y = Math.floor(index / sizex) % sizey;
	var h = Math.floor(index / (sizex * sizey));
	ret.x = x;
	ret.y = y;
	ret.z = h;
}

MapUtilCi.posX = function(index, sizex, sizey) {
	return index % sizex;
}

MapUtilCi.posY = function(index, sizex, sizey) {
	return Math.floor(index / sizex) % sizey;
}

MapUtilCi.posZ = function(index, sizex, sizey) {
	return Math.floor(index / (sizex * sizey));
}

function Mat2()
{
}

Mat2.adjoint = function(output, a) {
	var a0 = a[0];
	output[0] = a[3];
	output[1] = -a[1];
	output[2] = -a[2];
	output[3] = a0;
	return output;
}

Mat2.cloneIt = function(a) {
	var output = new Float32Array(new ArrayBuffer(4 << 2));
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[3];
	return output;
}

Mat2.copy = function(output, a) {
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[3];
	return output;
}

Mat2.create = function() {
	var output = new Float32Array(new ArrayBuffer(4 << 2));
	output[0] = 1;
	output[1] = 0;
	output[2] = 0;
	output[3] = 1;
	return output;
}

Mat2.determinant = function(a) {
	return a[0] * a[3] - a[2] * a[1];
}

Mat2.identity_ = function(output) {
	output[0] = 1;
	output[1] = 0;
	output[2] = 0;
	output[3] = 1;
	return output;
}

Mat2.invert = function(output, a) {
	var a0 = a[0];
	var a1 = a[1];
	var a2 = a[2];
	var a3 = a[3];
	var det = a0 * a3 - a2 * a1;
	if (det == 0) {
		return null;
	}
	var one = 1;
	det = one / (det);
	output[0] = a3 * det;
	output[1] = -a1 * det;
	output[2] = -a2 * det;
	output[3] = a0 * det;
	return output;
}

Mat2.mul = function(output, a, b) {
	return Mat2.multiply(output, a, b);
}

Mat2.multiply = function(output, a, b) {
	var a0 = a[0];
	var a1 = a[1];
	var a2 = a[2];
	var a3 = a[3];
	var b0 = b[0];
	var b1 = b[1];
	var b2 = b[2];
	var b3 = b[3];
	output[0] = a0 * b0 + a1 * b2;
	output[1] = a0 * b1 + a1 * b3;
	output[2] = a2 * b0 + a3 * b2;
	output[3] = a2 * b1 + a3 * b3;
	return output;
}

Mat2.rotate = function(output, a, rad) {
	var a0 = a[0];
	var a1 = a[1];
	var a2 = a[2];
	var a3 = a[3];
	var s = Platform.sin(rad);
	var c = Platform.cos(rad);
	output[0] = a0 * c + a1 * s;
	output[1] = a0 * -s + a1 * c;
	output[2] = a2 * c + a3 * s;
	output[3] = a2 * -s + a3 * c;
	return output;
}

Mat2.scale = function(output, a, v) {
	var a0 = a[0];
	var a1 = a[1];
	var a2 = a[2];
	var a3 = a[3];
	var v0 = v[0];
	var v1 = v[1];
	output[0] = a0 * v0;
	output[1] = a1 * v1;
	output[2] = a2 * v0;
	output[3] = a3 * v1;
	return output;
}

Mat2.transpose = function(output, a) {
	output[0] = a[0];
	output[1] = a[2];
	output[2] = a[1];
	output[3] = a[3];
	return output;
}

Mat2.prototype.f = function() {
}

function Mat2d()
{
}

Mat2d.cloneIt = function(a) {
	var output = new Float32Array(new ArrayBuffer(6 << 2));
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[3];
	output[4] = a[4];
	output[5] = a[5];
	return output;
}

Mat2d.copy = function(output, a) {
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[3];
	output[4] = a[4];
	output[5] = a[5];
	return output;
}

Mat2d.create = function() {
	var output = new Float32Array(new ArrayBuffer(6 << 2));
	output[0] = 1;
	output[1] = 0;
	output[2] = 0;
	output[3] = 1;
	output[4] = 0;
	output[5] = 0;
	return output;
}

Mat2d.determinant = function(a) {
	return a[0] * a[3] - a[1] * a[2];
}

Mat2d.identity_ = function(output) {
	output[0] = 1;
	output[1] = 0;
	output[2] = 0;
	output[3] = 1;
	output[4] = 0;
	output[5] = 0;
	return output;
}

Mat2d.invert = function(output, a) {
	var aa = a[0];
	var ab = a[1];
	var ac = a[2];
	var ad = a[3];
	var atx = a[4];
	var aty = a[5];
	var det = aa * ad - ab * ac;
	if (det == 0) {
		return null;
	}
	var one = 1;
	det = one / (det);
	output[0] = ad * det;
	output[1] = -ab * det;
	output[2] = -ac * det;
	output[3] = aa * det;
	output[4] = (ac * aty - ad * atx) * det;
	output[5] = (ab * atx - aa * aty) * det;
	return output;
}

Mat2d.mul = function(output, a, b) {
	return Mat2d.multiply(output, a, b);
}

Mat2d.multiply = function(output, a, b) {
	var aa = a[0];
	var ab = a[1];
	var ac = a[2];
	var ad = a[3];
	var atx = a[4];
	var aty = a[5];
	var ba = b[0];
	var bb = b[1];
	var bc = b[2];
	var bd = b[3];
	var btx = b[4];
	var bty = b[5];
	output[0] = aa * ba + ab * bc;
	output[1] = aa * bb + ab * bd;
	output[2] = ac * ba + ad * bc;
	output[3] = ac * bb + ad * bd;
	output[4] = ba * atx + bc * aty + btx;
	output[5] = bb * atx + bd * aty + bty;
	return output;
}

Mat2d.rotate = function(output, a, rad) {
	var aa = a[0];
	var ab = a[1];
	var ac = a[2];
	var ad = a[3];
	var atx = a[4];
	var aty = a[5];
	var st = Platform.sin(rad);
	var ct = Platform.cos(rad);
	output[0] = aa * ct + ab * st;
	output[1] = -aa * st + ab * ct;
	output[2] = ac * ct + ad * st;
	output[3] = -ac * st + ct * ad;
	output[4] = ct * atx + st * aty;
	output[5] = ct * aty - st * atx;
	return output;
}

Mat2d.scale = function(output, a, v) {
	var vx = v[0];
	var vy = v[1];
	output[0] = a[0] * vx;
	output[1] = a[1] * vy;
	output[2] = a[2] * vx;
	output[3] = a[3] * vy;
	output[4] = a[4] * vx;
	output[5] = a[5] * vy;
	return output;
}

Mat2d.translate = function(output, a, v) {
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[3];
	output[4] = a[4] + v[0];
	output[5] = a[5] + v[1];
	return output;
}

Mat2d.prototype.f = function() {
}

function Mat3()
{
}

Mat3.adjoint = function(output, a) {
	var a00 = a[0];
	var a01 = a[1];
	var a02 = a[2];
	var a10 = a[3];
	var a11 = a[4];
	var a12 = a[5];
	var a20 = a[6];
	var a21 = a[7];
	var a22 = a[8];
	output[0] = a11 * a22 - a12 * a21;
	output[1] = a02 * a21 - a01 * a22;
	output[2] = a01 * a12 - a02 * a11;
	output[3] = a12 * a20 - a10 * a22;
	output[4] = a00 * a22 - a02 * a20;
	output[5] = a02 * a10 - a00 * a12;
	output[6] = a10 * a21 - a11 * a20;
	output[7] = a01 * a20 - a00 * a21;
	output[8] = a00 * a11 - a01 * a10;
	return output;
}

Mat3.cloneIt = function(a) {
	var output = new Float32Array(new ArrayBuffer(9 << 2));
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[3];
	output[4] = a[4];
	output[5] = a[5];
	output[6] = a[6];
	output[7] = a[7];
	output[8] = a[8];
	return output;
}

Mat3.copy = function(output, a) {
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[3];
	output[4] = a[4];
	output[5] = a[5];
	output[6] = a[6];
	output[7] = a[7];
	output[8] = a[8];
	return output;
}

Mat3.create = function() {
	var output = new Float32Array(new ArrayBuffer(9 << 2));
	output[0] = 1;
	output[1] = 0;
	output[2] = 0;
	output[3] = 0;
	output[4] = 1;
	output[5] = 0;
	output[6] = 0;
	output[7] = 0;
	output[8] = 1;
	return output;
}

Mat3.determinant = function(a) {
	var a00 = a[0];
	var a01 = a[1];
	var a02 = a[2];
	var a10 = a[3];
	var a11 = a[4];
	var a12 = a[5];
	var a20 = a[6];
	var a21 = a[7];
	var a22 = a[8];
	return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}

Mat3.fromMat2d = function(output, a) {
	output[0] = a[0];
	output[1] = a[1];
	output[2] = 0;
	output[3] = a[2];
	output[4] = a[3];
	output[5] = 0;
	output[6] = a[4];
	output[7] = a[5];
	output[8] = 1;
	return output;
}

Mat3.fromMat4 = function(output, a) {
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[4];
	output[4] = a[5];
	output[5] = a[6];
	output[6] = a[8];
	output[7] = a[9];
	output[8] = a[10];
	return output;
}

Mat3.fromQuat = function(output, q) {
	var x = q[0];
	var y = q[1];
	var z = q[2];
	var w = q[3];
	var x2 = x + x;
	var y2 = y + y;
	var z2 = z + z;
	var xx = x * x2;
	var xy = x * y2;
	var xz = x * z2;
	var yy = y * y2;
	var yz = y * z2;
	var zz = z * z2;
	var wx = w * x2;
	var wy = w * y2;
	var wz = w * z2;
	output[0] = 1 - (yy + zz);
	output[3] = xy + wz;
	output[6] = xz - wy;
	output[1] = xy - wz;
	output[4] = 1 - (xx + zz);
	output[7] = yz + wx;
	output[2] = xz + wy;
	output[5] = yz - wx;
	output[8] = 1 - (xx + yy);
	return output;
}

Mat3.identity_ = function(output) {
	output[0] = 1;
	output[1] = 0;
	output[2] = 0;
	output[3] = 0;
	output[4] = 1;
	output[5] = 0;
	output[6] = 0;
	output[7] = 0;
	output[8] = 1;
	return output;
}

Mat3.invert = function(output, a) {
	var a00 = a[0];
	var a01 = a[1];
	var a02 = a[2];
	var a10 = a[3];
	var a11 = a[4];
	var a12 = a[5];
	var a20 = a[6];
	var a21 = a[7];
	var a22 = a[8];
	var b01 = a22 * a11 - a12 * a21;
	var b11 = -a22 * a10 + a12 * a20;
	var b21 = a21 * a10 - a11 * a20;
	var det = a00 * b01 + a01 * b11 + a02 * b21;
	if (det == 0) {
		return null;
	}
	var one = 1;
	det = one / (det);
	output[0] = b01 * det;
	output[1] = (-a22 * a01 + a02 * a21) * det;
	output[2] = (a12 * a01 - a02 * a11) * det;
	output[3] = b11 * det;
	output[4] = (a22 * a00 - a02 * a20) * det;
	output[5] = (-a12 * a00 + a02 * a10) * det;
	output[6] = b21 * det;
	output[7] = (-a21 * a00 + a01 * a20) * det;
	output[8] = (a11 * a00 - a01 * a10) * det;
	return output;
}

Mat3.mul = function(output, a, b) {
	return Mat3.multiply(output, a, b);
}

Mat3.multiply = function(output, a, b) {
	var a00 = a[0];
	var a01 = a[1];
	var a02 = a[2];
	var a10 = a[3];
	var a11 = a[4];
	var a12 = a[5];
	var a20 = a[6];
	var a21 = a[7];
	var a22 = a[8];
	var b00 = b[0];
	var b01 = b[1];
	var b02 = b[2];
	var b10 = b[3];
	var b11 = b[4];
	var b12 = b[5];
	var b20 = b[6];
	var b21 = b[7];
	var b22 = b[8];
	output[0] = b00 * a00 + b01 * a10 + b02 * a20;
	output[1] = b00 * a01 + b01 * a11 + b02 * a21;
	output[2] = b00 * a02 + b01 * a12 + b02 * a22;
	output[3] = b10 * a00 + b11 * a10 + b12 * a20;
	output[4] = b10 * a01 + b11 * a11 + b12 * a21;
	output[5] = b10 * a02 + b11 * a12 + b12 * a22;
	output[6] = b20 * a00 + b21 * a10 + b22 * a20;
	output[7] = b20 * a01 + b21 * a11 + b22 * a21;
	output[8] = b20 * a02 + b21 * a12 + b22 * a22;
	return output;
}

Mat3.normalFromMat4 = function(output, a) {
	var a00 = a[0];
	var a01 = a[1];
	var a02 = a[2];
	var a03 = a[3];
	var a10 = a[4];
	var a11 = a[5];
	var a12 = a[6];
	var a13 = a[7];
	var a20 = a[8];
	var a21 = a[9];
	var a22 = a[10];
	var a23 = a[11];
	var a30 = a[12];
	var a31 = a[13];
	var a32 = a[14];
	var a33 = a[15];
	var b00 = a00 * a11 - a01 * a10;
	var b01 = a00 * a12 - a02 * a10;
	var b02 = a00 * a13 - a03 * a10;
	var b03 = a01 * a12 - a02 * a11;
	var b04 = a01 * a13 - a03 * a11;
	var b05 = a02 * a13 - a03 * a12;
	var b06 = a20 * a31 - a21 * a30;
	var b07 = a20 * a32 - a22 * a30;
	var b08 = a20 * a33 - a23 * a30;
	var b09 = a21 * a32 - a22 * a31;
	var b10 = a21 * a33 - a23 * a31;
	var b11 = a22 * a33 - a23 * a32;
	var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	if (det == 0) {
		return null;
	}
	var one = 1;
	det = one / (det);
	output[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	output[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	output[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
	output[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	output[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	output[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
	output[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	output[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	output[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
	return output;
}

Mat3.rotate = function(output, a, rad) {
	var a00 = a[0];
	var a01 = a[1];
	var a02 = a[2];
	var a10 = a[3];
	var a11 = a[4];
	var a12 = a[5];
	var a20 = a[6];
	var a21 = a[7];
	var a22 = a[8];
	var s = Platform.sin(rad);
	var c = Platform.cos(rad);
	output[0] = c * a00 + s * a10;
	output[1] = c * a01 + s * a11;
	output[2] = c * a02 + s * a12;
	output[3] = c * a10 - s * a00;
	output[4] = c * a11 - s * a01;
	output[5] = c * a12 - s * a02;
	output[6] = a20;
	output[7] = a21;
	output[8] = a22;
	return output;
}

Mat3.scale = function(output, a, v) {
	var x = v[0];
	var y = v[1];
	output[0] = x * a[0];
	output[1] = x * a[1];
	output[2] = x * a[2];
	output[3] = y * a[3];
	output[4] = y * a[4];
	output[5] = y * a[5];
	output[6] = a[6];
	output[7] = a[7];
	output[8] = a[8];
	return output;
}

Mat3.translate = function(output, a, v) {
	var a00 = a[0];
	var a01 = a[1];
	var a02 = a[2];
	var a10 = a[3];
	var a11 = a[4];
	var a12 = a[5];
	var a20 = a[6];
	var a21 = a[7];
	var a22 = a[8];
	var x = v[0];
	var y = v[1];
	output[0] = a00;
	output[1] = a01;
	output[2] = a02;
	output[3] = a10;
	output[4] = a11;
	output[5] = a12;
	output[6] = x * a00 + y * a10 + a20;
	output[7] = x * a01 + y * a11 + a21;
	output[8] = x * a02 + y * a12 + a22;
	return output;
}

Mat3.transpose = function(output, a) {
	if (output == a) {
		var a01 = a[1];
		var a02 = a[2];
		var a12 = a[5];
		output[1] = a[3];
		output[2] = a[6];
		output[3] = a01;
		output[5] = a[7];
		output[6] = a02;
		output[7] = a12;
	}
	else {
		output[0] = a[0];
		output[1] = a[3];
		output[2] = a[6];
		output[3] = a[1];
		output[4] = a[4];
		output[5] = a[7];
		output[6] = a[2];
		output[7] = a[5];
		output[8] = a[8];
	}
	return output;
}

Mat3.prototype.f = function() {
}

function Mat4()
{
}

Mat4.adjoint = function(output, a) {
	var a00 = a[0];
	var a01 = a[1];
	var a02 = a[2];
	var a03 = a[3];
	var a10 = a[4];
	var a11 = a[5];
	var a12 = a[6];
	var a13 = a[7];
	var a20 = a[8];
	var a21 = a[9];
	var a22 = a[10];
	var a23 = a[11];
	var a30 = a[12];
	var a31 = a[13];
	var a32 = a[14];
	var a33 = a[15];
	output[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
	output[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
	output[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
	output[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
	output[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
	output[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
	output[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
	output[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
	output[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
	output[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
	output[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
	output[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
	output[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
	output[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
	output[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
	output[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
	return output;
}

Mat4.cloneIt = function(a) {
	var output = new Float32Array(new ArrayBuffer(16 << 2));
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[3];
	output[4] = a[4];
	output[5] = a[5];
	output[6] = a[6];
	output[7] = a[7];
	output[8] = a[8];
	output[9] = a[9];
	output[10] = a[10];
	output[11] = a[11];
	output[12] = a[12];
	output[13] = a[13];
	output[14] = a[14];
	output[15] = a[15];
	return output;
}

Mat4.copy = function(output, a) {
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[3];
	output[4] = a[4];
	output[5] = a[5];
	output[6] = a[6];
	output[7] = a[7];
	output[8] = a[8];
	output[9] = a[9];
	output[10] = a[10];
	output[11] = a[11];
	output[12] = a[12];
	output[13] = a[13];
	output[14] = a[14];
	output[15] = a[15];
	return output;
}

Mat4.create = function() {
	var output = new Float32Array(new ArrayBuffer(16 << 2));
	output[0] = 1;
	output[1] = 0;
	output[2] = 0;
	output[3] = 0;
	output[4] = 0;
	output[5] = 1;
	output[6] = 0;
	output[7] = 0;
	output[8] = 0;
	output[9] = 0;
	output[10] = 1;
	output[11] = 0;
	output[12] = 0;
	output[13] = 0;
	output[14] = 0;
	output[15] = 1;
	return output;
}

Mat4.determinant = function(a) {
	var a00 = a[0];
	var a01 = a[1];
	var a02 = a[2];
	var a03 = a[3];
	var a10 = a[4];
	var a11 = a[5];
	var a12 = a[6];
	var a13 = a[7];
	var a20 = a[8];
	var a21 = a[9];
	var a22 = a[10];
	var a23 = a[11];
	var a30 = a[12];
	var a31 = a[13];
	var a32 = a[14];
	var a33 = a[15];
	var b00 = a00 * a11 - a01 * a10;
	var b01 = a00 * a12 - a02 * a10;
	var b02 = a00 * a13 - a03 * a10;
	var b03 = a01 * a12 - a02 * a11;
	var b04 = a01 * a13 - a03 * a11;
	var b05 = a02 * a13 - a03 * a12;
	var b06 = a20 * a31 - a21 * a30;
	var b07 = a20 * a32 - a22 * a30;
	var b08 = a20 * a33 - a23 * a30;
	var b09 = a21 * a32 - a22 * a31;
	var b10 = a21 * a33 - a23 * a31;
	var b11 = a22 * a33 - a23 * a32;
	return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}

Mat4.fromQuat = function(output, q) {
	var x = q[0];
	var y = q[1];
	var z = q[2];
	var w = q[3];
	var x2 = x + x;
	var y2 = y + y;
	var z2 = z + z;
	var xx = x * x2;
	var xy = x * y2;
	var xz = x * z2;
	var yy = y * y2;
	var yz = y * z2;
	var zz = z * z2;
	var wx = w * x2;
	var wy = w * y2;
	var wz = w * z2;
	output[0] = 1 - (yy + zz);
	output[1] = xy + wz;
	output[2] = xz - wy;
	output[3] = 0;
	output[4] = xy - wz;
	output[5] = 1 - (xx + zz);
	output[6] = yz + wx;
	output[7] = 0;
	output[8] = xz + wy;
	output[9] = yz - wx;
	output[10] = 1 - (xx + yy);
	output[11] = 0;
	output[12] = 0;
	output[13] = 0;
	output[14] = 0;
	output[15] = 1;
	return output;
}

Mat4.fromRotationTranslation = function(output, q, v) {
	var x = q[0];
	var y = q[1];
	var z = q[2];
	var w = q[3];
	var x2 = x + x;
	var y2 = y + y;
	var z2 = z + z;
	var xx = x * x2;
	var xy = x * y2;
	var xz = x * z2;
	var yy = y * y2;
	var yz = y * z2;
	var zz = z * z2;
	var wx = w * x2;
	var wy = w * y2;
	var wz = w * z2;
	output[0] = 1 - (yy + zz);
	output[1] = xy + wz;
	output[2] = xz - wy;
	output[3] = 0;
	output[4] = xy - wz;
	output[5] = 1 - (xx + zz);
	output[6] = yz + wx;
	output[7] = 0;
	output[8] = xz + wy;
	output[9] = yz - wx;
	output[10] = 1 - (xx + yy);
	output[11] = 0;
	output[12] = v[0];
	output[13] = v[1];
	output[14] = v[2];
	output[15] = 1;
	return output;
}

Mat4.frustum = function(output, left, right, bottom, top, near, far) {
	var rl = 1 / (right - left);
	var tb = 1 / (top - bottom);
	var nf = 1 / (near - far);
	output[0] = near * 2 * rl;
	output[1] = 0;
	output[2] = 0;
	output[3] = 0;
	output[4] = 0;
	output[5] = near * 2 * tb;
	output[6] = 0;
	output[7] = 0;
	output[8] = (right + left) * rl;
	output[9] = (top + bottom) * tb;
	output[10] = (far + near) * nf;
	output[11] = -1;
	output[12] = 0;
	output[13] = 0;
	output[14] = far * near * 2 * nf;
	output[15] = 0;
	return output;
}

Mat4.identity_ = function(output) {
	output[0] = 1;
	output[1] = 0;
	output[2] = 0;
	output[3] = 0;
	output[4] = 0;
	output[5] = 1;
	output[6] = 0;
	output[7] = 0;
	output[8] = 0;
	output[9] = 0;
	output[10] = 1;
	output[11] = 0;
	output[12] = 0;
	output[13] = 0;
	output[14] = 0;
	output[15] = 1;
	return output;
}

Mat4.invert = function(output, a) {
	var a00 = a[0];
	var a01 = a[1];
	var a02 = a[2];
	var a03 = a[3];
	var a10 = a[4];
	var a11 = a[5];
	var a12 = a[6];
	var a13 = a[7];
	var a20 = a[8];
	var a21 = a[9];
	var a22 = a[10];
	var a23 = a[11];
	var a30 = a[12];
	var a31 = a[13];
	var a32 = a[14];
	var a33 = a[15];
	var b00 = a00 * a11 - a01 * a10;
	var b01 = a00 * a12 - a02 * a10;
	var b02 = a00 * a13 - a03 * a10;
	var b03 = a01 * a12 - a02 * a11;
	var b04 = a01 * a13 - a03 * a11;
	var b05 = a02 * a13 - a03 * a12;
	var b06 = a20 * a31 - a21 * a30;
	var b07 = a20 * a32 - a22 * a30;
	var b08 = a20 * a33 - a23 * a30;
	var b09 = a21 * a32 - a22 * a31;
	var b10 = a21 * a33 - a23 * a31;
	var b11 = a22 * a33 - a23 * a32;
	var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	if (det == 0) {
		return null;
	}
	var one = 1;
	det = one / (det);
	output[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	output[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	output[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	output[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
	output[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	output[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	output[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	output[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
	output[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
	output[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
	output[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
	output[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
	output[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
	output[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
	output[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
	output[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
	return output;
}

Mat4.lookAt = function(output, eye, center, up) {
	var x0;
	var x1;
	var x2;
	var y0;
	var y1;
	var y2;
	var z0;
	var z1;
	var z2;
	var len;
	var eyex = eye[0];
	var eyey = eye[1];
	var eyez = eye[2];
	var upx = up[0];
	var upy = up[1];
	var upz = up[2];
	var centerx = center[0];
	var centery = center[1];
	var centerz = center[2];
	if (GlMatrixMath.abs(eyex - centerx) < GlMatrixMath.gLMAT_EPSILON() && GlMatrixMath.abs(eyey - centery) < GlMatrixMath.gLMAT_EPSILON() && GlMatrixMath.abs(eyez - centerz) < GlMatrixMath.gLMAT_EPSILON()) {
		return Mat4.identity_(output);
	}
	z0 = eyex - centerx;
	z1 = eyey - centery;
	z2 = eyez - centerz;
	len = 1 / (Platform.sqrt(z0 * z0 + z1 * z1 + z2 * z2));
	z0 *= len;
	z1 *= len;
	z2 *= len;
	x0 = upy * z2 - upz * z1;
	x1 = upz * z0 - upx * z2;
	x2 = upx * z1 - upy * z0;
	len = Platform.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
	if (len == 0) {
		x0 = 0;
		x1 = 0;
		x2 = 0;
	}
	else {
		len = 1 / (len);
		x0 *= len;
		x1 *= len;
		x2 *= len;
	}
	y0 = z1 * x2 - z2 * x1;
	y1 = z2 * x0 - z0 * x2;
	y2 = z0 * x1 - z1 * x0;
	len = Platform.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
	if (len == 0) {
		y0 = 0;
		y1 = 0;
		y2 = 0;
	}
	else {
		len = 1 / (len);
		y0 *= len;
		y1 *= len;
		y2 *= len;
	}
	output[0] = x0;
	output[1] = y0;
	output[2] = z0;
	output[3] = 0;
	output[4] = x1;
	output[5] = y1;
	output[6] = z1;
	output[7] = 0;
	output[8] = x2;
	output[9] = y2;
	output[10] = z2;
	output[11] = 0;
	output[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
	output[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
	output[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
	output[15] = 1;
	return output;
}

Mat4.mul = function(output, a, b) {
	return Mat4.multiply(output, a, b);
}

Mat4.multiply = function(output, a, b) {
	var a00 = a[0];
	var a01 = a[1];
	var a02 = a[2];
	var a03 = a[3];
	var a10 = a[4];
	var a11 = a[5];
	var a12 = a[6];
	var a13 = a[7];
	var a20 = a[8];
	var a21 = a[9];
	var a22 = a[10];
	var a23 = a[11];
	var a30 = a[12];
	var a31 = a[13];
	var a32 = a[14];
	var a33 = a[15];
	var b0 = b[0];
	var b1 = b[1];
	var b2 = b[2];
	var b3 = b[3];
	output[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	output[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	output[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	output[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	b0 = b[4];
	b1 = b[5];
	b2 = b[6];
	b3 = b[7];
	output[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	output[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	output[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	output[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	b0 = b[8];
	b1 = b[9];
	b2 = b[10];
	b3 = b[11];
	output[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	output[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	output[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	output[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	b0 = b[12];
	b1 = b[13];
	b2 = b[14];
	b3 = b[15];
	output[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	output[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	output[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	output[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	return output;
}

Mat4.ortho = function(output, left, right, bottom, top, near, far) {
	var lr = 1 / (left - right);
	var bt = 1 / (bottom - top);
	var nf = 1 / (near - far);
	output[0] = -2 * lr;
	output[1] = 0;
	output[2] = 0;
	output[3] = 0;
	output[4] = 0;
	output[5] = -2 * bt;
	output[6] = 0;
	output[7] = 0;
	output[8] = 0;
	output[9] = 0;
	output[10] = 2 * nf;
	output[11] = 0;
	output[12] = (left + right) * lr;
	output[13] = (top + bottom) * bt;
	output[14] = (far + near) * nf;
	output[15] = 1;
	return output;
}

Mat4.perspective = function(output, fovy, aspect, near, far) {
	var one = 1;
	var f = one / (Platform.tan(fovy / (2)));
	var nf = 1 / (near - far);
	output[0] = f / (aspect);
	output[1] = 0;
	output[2] = 0;
	output[3] = 0;
	output[4] = 0;
	output[5] = f;
	output[6] = 0;
	output[7] = 0;
	output[8] = 0;
	output[9] = 0;
	output[10] = (far + near) * nf;
	output[11] = -1;
	output[12] = 0;
	output[13] = 0;
	output[14] = 2 * far * near * nf;
	output[15] = 0;
	return output;
}

Mat4.rotate = function(output, a, rad, axis) {
	var x = axis[0];
	var y = axis[1];
	var z = axis[2];
	var len = Platform.sqrt(x * x + y * y + z * z);
	var s;
	var c;
	var t;
	var a00;
	var a01;
	var a02;
	var a03;
	var a10;
	var a11;
	var a12;
	var a13;
	var a20;
	var a21;
	var a22;
	var a23;
	var b00;
	var b01;
	var b02;
	var b10;
	var b11;
	var b12;
	var b20;
	var b21;
	var b22;
	if (GlMatrixMath.abs(len) < GlMatrixMath.gLMAT_EPSILON()) {
		return null;
	}
	len = 1 / (len);
	x *= len;
	y *= len;
	z *= len;
	s = Platform.sin(rad);
	c = Platform.cos(rad);
	t = 1 - c;
	a00 = a[0];
	a01 = a[1];
	a02 = a[2];
	a03 = a[3];
	a10 = a[4];
	a11 = a[5];
	a12 = a[6];
	a13 = a[7];
	a20 = a[8];
	a21 = a[9];
	a22 = a[10];
	a23 = a[11];
	b00 = x * x * t + c;
	b01 = y * x * t + z * s;
	b02 = z * x * t - y * s;
	b10 = x * y * t - z * s;
	b11 = y * y * t + c;
	b12 = z * y * t + x * s;
	b20 = x * z * t + y * s;
	b21 = y * z * t - x * s;
	b22 = z * z * t + c;
	output[0] = a00 * b00 + a10 * b01 + a20 * b02;
	output[1] = a01 * b00 + a11 * b01 + a21 * b02;
	output[2] = a02 * b00 + a12 * b01 + a22 * b02;
	output[3] = a03 * b00 + a13 * b01 + a23 * b02;
	output[4] = a00 * b10 + a10 * b11 + a20 * b12;
	output[5] = a01 * b10 + a11 * b11 + a21 * b12;
	output[6] = a02 * b10 + a12 * b11 + a22 * b12;
	output[7] = a03 * b10 + a13 * b11 + a23 * b12;
	output[8] = a00 * b20 + a10 * b21 + a20 * b22;
	output[9] = a01 * b20 + a11 * b21 + a21 * b22;
	output[10] = a02 * b20 + a12 * b21 + a22 * b22;
	output[11] = a03 * b20 + a13 * b21 + a23 * b22;
	if (a != output) {
		output[12] = a[12];
		output[13] = a[13];
		output[14] = a[14];
		output[15] = a[15];
	}
	return output;
}

Mat4.rotateX = function(output, a, rad) {
	var s = Platform.sin(rad);
	var c = Platform.cos(rad);
	var a10 = a[4];
	var a11 = a[5];
	var a12 = a[6];
	var a13 = a[7];
	var a20 = a[8];
	var a21 = a[9];
	var a22 = a[10];
	var a23 = a[11];
	if (a != output) {
		output[0] = a[0];
		output[1] = a[1];
		output[2] = a[2];
		output[3] = a[3];
		output[12] = a[12];
		output[13] = a[13];
		output[14] = a[14];
		output[15] = a[15];
	}
	output[4] = a10 * c + a20 * s;
	output[5] = a11 * c + a21 * s;
	output[6] = a12 * c + a22 * s;
	output[7] = a13 * c + a23 * s;
	output[8] = a20 * c - a10 * s;
	output[9] = a21 * c - a11 * s;
	output[10] = a22 * c - a12 * s;
	output[11] = a23 * c - a13 * s;
	return output;
}

Mat4.rotateY = function(output, a, rad) {
	var s = Platform.sin(rad);
	var c = Platform.cos(rad);
	var a00 = a[0];
	var a01 = a[1];
	var a02 = a[2];
	var a03 = a[3];
	var a20 = a[8];
	var a21 = a[9];
	var a22 = a[10];
	var a23 = a[11];
	if (a != output) {
		output[4] = a[4];
		output[5] = a[5];
		output[6] = a[6];
		output[7] = a[7];
		output[12] = a[12];
		output[13] = a[13];
		output[14] = a[14];
		output[15] = a[15];
	}
	output[0] = a00 * c - a20 * s;
	output[1] = a01 * c - a21 * s;
	output[2] = a02 * c - a22 * s;
	output[3] = a03 * c - a23 * s;
	output[8] = a00 * s + a20 * c;
	output[9] = a01 * s + a21 * c;
	output[10] = a02 * s + a22 * c;
	output[11] = a03 * s + a23 * c;
	return output;
}

Mat4.rotateZ = function(output, a, rad) {
	var s = Platform.sin(rad);
	var c = Platform.cos(rad);
	var a00 = a[0];
	var a01 = a[1];
	var a02 = a[2];
	var a03 = a[3];
	var a10 = a[4];
	var a11 = a[5];
	var a12 = a[6];
	var a13 = a[7];
	if (a != output) {
		output[8] = a[8];
		output[9] = a[9];
		output[10] = a[10];
		output[11] = a[11];
		output[12] = a[12];
		output[13] = a[13];
		output[14] = a[14];
		output[15] = a[15];
	}
	output[0] = a00 * c + a10 * s;
	output[1] = a01 * c + a11 * s;
	output[2] = a02 * c + a12 * s;
	output[3] = a03 * c + a13 * s;
	output[4] = a10 * c - a00 * s;
	output[5] = a11 * c - a01 * s;
	output[6] = a12 * c - a02 * s;
	output[7] = a13 * c - a03 * s;
	return output;
}

Mat4.scale = function(output, a, v) {
	var x = v[0];
	var y = v[1];
	var z = v[2];
	output[0] = a[0] * x;
	output[1] = a[1] * x;
	output[2] = a[2] * x;
	output[3] = a[3] * x;
	output[4] = a[4] * y;
	output[5] = a[5] * y;
	output[6] = a[6] * y;
	output[7] = a[7] * y;
	output[8] = a[8] * z;
	output[9] = a[9] * z;
	output[10] = a[10] * z;
	output[11] = a[11] * z;
	output[12] = a[12];
	output[13] = a[13];
	output[14] = a[14];
	output[15] = a[15];
	return output;
}

Mat4.translate = function(output, a, v) {
	var x = v[0];
	var y = v[1];
	var z = v[2];
	var a00;
	var a01;
	var a02;
	var a03;
	var a10;
	var a11;
	var a12;
	var a13;
	var a20;
	var a21;
	var a22;
	var a23;
	if (a == output) {
		output[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
		output[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
		output[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
		output[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
	}
	else {
		a00 = a[0];
		a01 = a[1];
		a02 = a[2];
		a03 = a[3];
		a10 = a[4];
		a11 = a[5];
		a12 = a[6];
		a13 = a[7];
		a20 = a[8];
		a21 = a[9];
		a22 = a[10];
		a23 = a[11];
		output[0] = a00;
		output[1] = a01;
		output[2] = a02;
		output[3] = a03;
		output[4] = a10;
		output[5] = a11;
		output[6] = a12;
		output[7] = a13;
		output[8] = a20;
		output[9] = a21;
		output[10] = a22;
		output[11] = a23;
		output[12] = a00 * x + a10 * y + a20 * z + a[12];
		output[13] = a01 * x + a11 * y + a21 * z + a[13];
		output[14] = a02 * x + a12 * y + a22 * z + a[14];
		output[15] = a03 * x + a13 * y + a23 * z + a[15];
	}
	return output;
}

Mat4.transpose = function(output, a) {
	if (output == a) {
		var a01 = a[1];
		var a02 = a[2];
		var a03 = a[3];
		var a12 = a[6];
		var a13 = a[7];
		var a23 = a[11];
		output[1] = a[4];
		output[2] = a[8];
		output[3] = a[12];
		output[4] = a01;
		output[6] = a[9];
		output[7] = a[13];
		output[8] = a02;
		output[9] = a12;
		output[11] = a[14];
		output[12] = a03;
		output[13] = a13;
		output[14] = a23;
	}
	else {
		output[0] = a[0];
		output[1] = a[4];
		output[2] = a[8];
		output[3] = a[12];
		output[4] = a[1];
		output[5] = a[5];
		output[6] = a[9];
		output[7] = a[13];
		output[8] = a[2];
		output[9] = a[6];
		output[10] = a[10];
		output[11] = a[14];
		output[12] = a[3];
		output[13] = a[7];
		output[14] = a[11];
		output[15] = a[15];
	}
	return output;
}

Mat4.prototype.f = function() {
}

function MathCi()
{
}

MathCi.absFloat = function(b) {
	if (b >= 0) {
		return b;
	}
	else {
		return 0 - b;
	}
}

MathCi.clampFloat = function(value, min, max) {
	var result = value;
	if (value > max) {
		result = max;
	}
	if (value < min) {
		result = min;
	}
	return result;
}

MathCi.clampInt = function(value, min, max) {
	var result = value;
	if (value > max) {
		result = max;
	}
	if (value < min) {
		result = min;
	}
	return result;
}

MathCi.maxFloat = function(a, b) {
	if (a >= b) {
		return a;
	}
	else {
		return b;
	}
}

MathCi.maxInt = function(a, b) {
	if (a >= b) {
		return a;
	}
	else {
		return b;
	}
}

MathCi.minFloat = function(a, b) {
	if (a <= b) {
		return a;
	}
	else {
		return b;
	}
}

MathCi.minInt = function(a, b) {
	if (a <= b) {
		return a;
	}
	else {
		return b;
	}
}

MathCi.sign = function(q) {
	if (q < 0) {
		return -1;
	}
	else if (q == 0) {
		return 0;
	}
	else {
		return 1;
	}
}

function MenuState()
{
	this.selected = 0;
}

function MenuWidget()
{
	this.buttonStyle = ButtonStyle.BUTTON;
	this.color = 0;
	this.description = null;
	this.editing = false;
	this.font = null;
	this.hasKeyboardFocus = false;
	this.hover = false;
	this.id = null;
	this.image = null;
	this.isbutton = false;
	this.nextWidget = 0;
	this.password = false;
	this.pressed = false;
	this.selected = false;
	this.sizex = null;
	this.sizey = null;
	this.text = null;
	this.type = WidgetType.BUTTON;
	this.visible = false;
	this.x = null;
	this.y = null;
	this.visible = true;
	this.font = new FontCi();
	this.font.size = 14;
	this.nextWidget = -1;
	this.hasKeyboardFocus = false;
}

MenuWidget.prototype.getFocus = function() {
	this.hasKeyboardFocus = true;
	if (this.type == WidgetType.TEXTBOX) {
		this.editing = true;
	}
}

MenuWidget.prototype.loseFocus = function() {
	this.hasKeyboardFocus = false;
	if (this.type == WidgetType.TEXTBOX) {
		this.editing = false;
	}
}

function MeshBatcher()
{
	this.bindTexture = false;
	this.d_FrustumCulling = null;
	this.empty = null;
	this.emptyCount = 0;
	this.game = null;
	this.glTextures = null;
	this.glTexturesLength = 0;
	this.models = null;
	this.modelsCount = 0;
	this.tocallSolid = null;
	this.tocallTransparent = null;
	var modelsMax = 16384;
	this.models = new Array(modelsMax);
	for (var i = 0; i < modelsMax; i++) {
		this.models[i] = new ListInfo();
	}
	this.modelsCount = 0;
	this.bindTexture = true;
	this.glTextures = new Int32Array(new ArrayBuffer(10 << 2));
	this.glTexturesLength = 10;
	this.empty = new Int32Array(new ArrayBuffer(modelsMax << 2));
	this.emptyCount = 0;
}

MeshBatcher.prototype.add = function(modelData, transparent, texture, centerX, centerY, centerZ, radius) {
	var id;
	if (this.emptyCount > 0) {
		id = this.empty[this.emptyCount - 1];
		this.emptyCount--;
	}
	else {
		id = this.modelsCount;
		this.modelsCount++;
	}
	var model = this.game.platform.createModel(modelData);
	var li = this.models[id];
	li.indicescount = modelData.getIndicesCount();
	li.centerX = centerX;
	li.centerY = centerY;
	li.centerZ = centerZ;
	li.radius = radius;
	li.transparent = transparent;
	li.empty = false;
	li.texture = this.getTextureId(texture);
	li.model = model;
	return id;
}

MeshBatcher.prototype.arrayIndexOf = function(glTextures, length, glTexture) {
	for (var i = 0; i < length; i++) {
		if (glTextures[i] == glTexture) {
			return i;
		}
	}
	return -1;
}

MeshBatcher.prototype.clear = function() {
	var count = this.modelsCount;
	for (var i = 0; i < count; i++) {
		if (!this.models[i].empty) {
			this.remove(i);
		}
	}
}

MeshBatcher.prototype.draw = function(playerPositionX, playerPositionY, playerPositionZ) {
	this.updateCulling();
	this.sortListsByTexture();
	for (var i = 0; i < 10; i++) {
		if (this.tocallSolid[i].count == 0) {
			continue;
		}
		if (this.bindTexture) {
			this.game.platform.bindTexture2d(this.glTextures[i]);
		}
		this.game.drawModels(this.tocallSolid[i].lists, this.tocallSolid[i].count);
	}
	this.game.platform.glDisableCullFace();
	for (var i = 0; i < 10; i++) {
		if (this.tocallTransparent[i].count == 0) {
			continue;
		}
		if (this.bindTexture) {
			this.game.platform.bindTexture2d(this.glTextures[i]);
		}
		this.game.drawModels(this.tocallTransparent[i].lists, this.tocallTransparent[i].count);
	}
	this.game.platform.glEnableCullFace();
}

MeshBatcher.prototype.getTextureId = function(glTexture) {
	var id = this.arrayIndexOf(this.glTextures, this.glTexturesLength, glTexture);
	if (id != -1) {
		return id;
	}
	id = this.arrayIndexOf(this.glTextures, this.glTexturesLength, 0);
	if (id != -1) {
		this.glTextures[id] = glTexture;
		return id;
	}
	var increase = 10;
	var glTextures2 = new Int32Array(new ArrayBuffer(this.glTexturesLength + increase << 2));
	for (var i = 0; i < this.glTexturesLength; i++) {
		glTextures2[i] = this.glTextures[i];
	}
	this.glTextures = glTextures2;
	this.glTexturesLength = this.glTexturesLength + increase;
	this.glTextures[this.glTexturesLength - increase] = glTexture;
	return this.glTexturesLength - increase;
}

MeshBatcher.prototype.remove = function(id) {
	this.game.platform.deleteModel(this.models[id].model);
	this.models[id].empty = true;
	this.empty[this.emptyCount++] = id;
}

MeshBatcher.prototype.sortListsByTexture = function() {
	if (this.tocallSolid == null) {
		this.tocallSolid = new Array(10);
		this.tocallTransparent = new Array(10);
		for (var i = 0; i < 10; i++) {
			this.tocallSolid[i] = new ToCall();
			this.tocallTransparent[i] = new ToCall();
		}
		for (var i = 0; i < 10; i++) {
			var max = 256;
			this.tocallSolid[i].lists = new Array(max);
			this.tocallSolid[i].max = max;
			this.tocallTransparent[i].lists = new Array(max);
			this.tocallTransparent[i].max = max;
		}
	}
	for (var i = 0; i < 10; i++) {
		this.tocallSolid[i].count = 0;
		this.tocallTransparent[i].count = 0;
	}
	for (var i = 0; i < this.modelsCount; i++) {
		var li = this.models[i];
		if (!li.render) {
			continue;
		}
		if (li.empty) {
			continue;
		}
		var tocall;
		if (!li.transparent) {
			tocall = this.tocallSolid[li.texture];
		}
		else {
			tocall = this.tocallTransparent[li.texture];
		}
		if (tocall.count >= tocall.max) {
			var old = tocall.lists;
			var new_ = new Array(tocall.max * 2);
			for (var k = 0; k < tocall.max; k++) {
				new_[k] = old[k];
			}
			tocall.lists = new_;
			tocall.max = tocall.max * 2;
		}
		tocall.lists[tocall.count++] = this.models[i].model;
	}
}

MeshBatcher.prototype.totalTriangleCount = function() {
	var sum = 0;
	var count = this.modelsCount;
	for (var i = 0; i < count; i++) {
		if (!this.models[i].empty) {
			var li = this.models[i];
			if (li.render) {
				sum += li.indicescount;
			}
		}
	}
	return Math.floor(sum / 3);
}

MeshBatcher.prototype.updateCulling = function() {
	var licount = this.modelsCount;
	for (var i = 0; i < licount; i++) {
		var li = this.models[i];
		var centerX = li.centerX;
		var centerY = li.centerY;
		var centerZ = li.centerZ;
		li.render = this.d_FrustumCulling.sphereInFrustum(centerX, centerY, centerZ, li.radius);
	}
}
MeshBatcher.TEXTURES_COUNT = 10;

function Minecart()
{
	this.direction = VehicleDirection12.HORIZONTAL_LEFT;
	this.enabled = false;
	this.lastdirection = VehicleDirection12.HORIZONTAL_LEFT;
	this.positionX = null;
	this.positionY = null;
	this.positionZ = null;
	this.progress = null;
}

function MiscCi()
{
}

MiscCi.readBool = function(str) {
	if (str == null) {
		return false;
	}
	else {
		return str != "0" && str != "false" && str != "False" && str != "FALSE";
	}
}

MiscCi.ushortArrayToByteArray = function(input, inputLength) {
	var outputLength = inputLength * 2;
	var output = new Uint8Array(new ArrayBuffer(outputLength));
	for (var i = 0; i < inputLength; i++) {
		output[i * 2] = Game.intToByte(input[i] & 255);
		output[i * 2 + 1] = Game.intToByte(input[i] >> 8 & 255);
	}
	return output;
}

MiscCi.vec3Length = function(x, y, z) {
	return Platform.sqrt(x * x + y * y + z * z);
}

function ModAudio()
{
	this.audioData = null;
	this.wasLoaded = false;
	this.audioData = new DictionaryStringAudioData();
	this.wasLoaded = false;
}
ModAudio.prototype = new ClientMod();

ModAudio.prototype.getAudioData = function(game, sound) {
	if (!this.audioData.contains(sound)) {
		var a = game.platform.audioDataCreate(game.getFile(sound), game.getFileLength(sound));
		this.audioData.set(sound, a);
	}
	return this.audioData.getById(this.audioData.getId(sound));
}

ModAudio.prototype.onNewFrame = function(game, args) {
	if (game.assetsLoadProgress.value != 1) {
		return;
	}
	if (!this.wasLoaded) {
		this.wasLoaded = true;
		this.preload(game);
	}
	for (var i = 0; i < game.audio.soundsCount; i++) {
		var sound = game.audio.sounds[i];
		if (sound == null) {
			continue;
		}
		if (sound.audio != null) {
			continue;
		}
		var data = this.getAudioData(game, sound.name);
		if (game.platform.audioDataLoaded(data)) {
			sound.audio = game.platform.audioCreate(data);
			game.platform.audioPlay(sound.audio);
		}
	}
	for (var i = 0; i < game.audio.soundsCount; i++) {
		var sound = game.audio.sounds[i];
		if (sound == null) {
			continue;
		}
		if (sound.audio == null) {
			continue;
		}
		game.platform.audioSetPosition(sound.audio, sound.x, sound.y, sound.z);
	}
	for (var i = 0; i < game.audio.soundsCount; i++) {
		var sound = game.audio.sounds[i];
		if (sound == null) {
			continue;
		}
		if (sound.audio == null) {
			continue;
		}
		if (sound.stop) {
			game.platform.audioDelete(sound.audio);
			game.audio.sounds[i] = null;
		}
	}
	for (var i = 0; i < game.audio.soundsCount; i++) {
		var sound = game.audio.sounds[i];
		if (sound == null) {
			continue;
		}
		if (sound.audio == null) {
			continue;
		}
		if (sound.loop) {
			if (game.platform.audioFinished(sound.audio) && sound.loop) {
				var data = this.getAudioData(game, sound.name);
				if (game.platform.audioDataLoaded(data)) {
					sound.audio = game.platform.audioCreate(data);
					game.platform.audioPlay(sound.audio);
				}
			}
		}
		else {
			if (game.platform.audioFinished(sound.audio)) {
				game.audio.sounds[i] = null;
			}
		}
	}
}

ModAudio.prototype.preload = function(game) {
	for (var k = 0; k < game.assets.count; k++) {
		var s = game.assets.items[k].name;
		var sound = game.platform.stringReplace(s, ".ogg", "");
		if (s == sound) {
			continue;
		}
		this.getAudioData(game, s);
	}
}

function ModAutoCamera()
{
	this.avi = null;
	this.cameraPoints = null;
	this.cameraPointsCount = 0;
	this.firstFrameDone = false;
	this.m = null;
	this.one = null;
	this.orientation = null;
	this.p = null;
	this.playingSpeed = null;
	this.playingTime = null;
	this.position = null;
	this.previousFreemove = 0;
	this.previousOrientationX = null;
	this.previousOrientationY = null;
	this.previousOrientationZ = null;
	this.previousPositionX = null;
	this.previousPositionY = null;
	this.previousPositionZ = null;
	this.recspeed = null;
	this.writeAccum = null;
}
ModAutoCamera.prototype = new ClientMod();

ModAutoCamera.prototype.distance = function(a, b) {
	var dx = a.positionGlX - b.positionGlX;
	var dy = a.positionGlY - b.positionGlY;
	var dz = a.positionGlZ - b.positionGlZ;
	return this.p.mathSqrt(dx * dx + dy * dy + dz * dz);
}

ModAutoCamera.prototype.onClientCommand = function(game, args) {
	if (args.command == "cam") {
		var argumentsLength = new IntRef();
		var arguments = this.p.stringSplit(args.arguments, " ", argumentsLength);
		if (this.p.stringTrim(args.arguments) == "") {
			this.m.displayNotification("&6AutoCamera help.");
			this.m.displayNotification("&6.cam p&f - add a point to path");
			this.m.displayNotification("&6.cam start [real seconds]&f - play the path");
			this.m.displayNotification("&6.cam rec [real seconds] [video seconds]&f - play and record to .avi file");
			this.m.displayNotification("&6.cam stop&f - stop playing and recording");
			this.m.displayNotification("&6.cam clear&f - remove all points from path");
			this.m.displayNotification("&6.cam save&f - copy path points to clipboard");
			this.m.displayNotification("&6.cam load [points]&f - load path points");
			return true;
		}
		if (arguments[0] == "p") {
			this.m.displayNotification("Point defined.");
			var point = new CameraPoint();
			point.positionGlX = this.m.getLocalPositionX();
			point.positionGlY = this.m.getLocalPositionY();
			point.positionGlZ = this.m.getLocalPositionZ();
			point.orientationGlX = this.m.getLocalOrientationX();
			point.orientationGlY = this.m.getLocalOrientationY();
			point.orientationGlZ = this.m.getLocalOrientationZ();
			this.cameraPoints[this.cameraPointsCount++] = point;
		}
		if (arguments[0] == "start" || arguments[0] == "play" || arguments[0] == "rec") {
			if (!this.m.isFreemoveAllowed()) {
				this.m.displayNotification("Free move not allowed.");
				return true;
			}
			if (this.cameraPointsCount == 0) {
				this.m.displayNotification("No points defined. Enter points with \".cam p\" command.");
				return true;
			}
			this.playingSpeed = 1;
			var totalRecTime = -1;
			if (arguments[0] == "rec") {
				if (argumentsLength.value >= 3) {
					totalRecTime = this.p.floatParse(arguments[2]);
				}
				this.avi = this.m.aviWriterCreate();
				this.avi.open(this.p.stringFormat("{0}.avi", this.p.timestamp()), 60, this.m.getWindowWidth(), this.m.getWindowHeight());
			}
			if (argumentsLength.value >= 2) {
				var totalTime = this.p.floatParse(arguments[1]);
				this.playingSpeed = this.totalDistance() / (totalTime);
				if (totalRecTime == -1) {
					this.recspeed = 10;
				}
				else {
					this.recspeed = totalTime / (totalRecTime);
				}
			}
			this.playingTime = 0;
			this.firstFrameDone = false;
			this.previousPositionX = this.m.getLocalPositionX();
			this.previousPositionY = this.m.getLocalPositionY();
			this.previousPositionZ = this.m.getLocalPositionZ();
			this.previousOrientationX = this.m.getLocalOrientationX();
			this.previousOrientationY = this.m.getLocalOrientationY();
			this.previousOrientationZ = this.m.getLocalOrientationZ();
			this.m.showGui(0);
			this.previousFreemove = this.m.getFreemove();
			this.m.setFreemove(2);
			this.m.enableCameraControl(false);
		}
		if (arguments[0] == "stop") {
			this.m.displayNotification("Camera stopped.");
			this.stop();
		}
		if (arguments[0] == "clear") {
			this.m.displayNotification("Camera points cleared.");
			this.cameraPointsCount = 0;
			this.stop();
		}
		if (arguments[0] == "save") {
			var s = "1,";
			for (var i = 0; i < this.cameraPointsCount; i++) {
				var point = this.cameraPoints[i];
				s = this.p.stringFormat2("{0}{1},", s, this.p.intToString(this.p.floatToInt(point.positionGlX * 100)));
				s = this.p.stringFormat2("{0}{1},", s, this.p.intToString(this.p.floatToInt(point.positionGlY * 100)));
				s = this.p.stringFormat2("{0}{1},", s, this.p.intToString(this.p.floatToInt(point.positionGlZ * 100)));
				s = this.p.stringFormat2("{0}{1},", s, this.p.intToString(this.p.floatToInt(point.orientationGlX * 1000)));
				s = this.p.stringFormat2("{0}{1},", s, this.p.intToString(this.p.floatToInt(point.orientationGlY * 1000)));
				s = this.p.stringFormat2("{0}{1}", s, this.p.intToString(this.p.floatToInt(point.orientationGlZ * 1000)));
				if (i != this.cameraPointsCount - 1) {
					s = this.p.stringFormat("{0},", s);
				}
			}
			this.p.clipboardSetText(s);
			this.m.displayNotification("Camera points copied to clipboard.");
		}
		if (arguments[0] == "load") {
			var pointsLength = new IntRef();
			var points = this.p.stringSplit(arguments[1], ",", pointsLength);
			var n = Math.floor((pointsLength.value - 1) / 6);
			this.cameraPointsCount = 0;
			for (var i = 0; i < n; i++) {
				var point = new CameraPoint();
				point.positionGlX = (this.one * this.p.intParse(points[1 + i * 6 + 0])) / (100);
				point.positionGlY = (this.one * this.p.intParse(points[1 + i * 6 + 1])) / (100);
				point.positionGlZ = (this.one * this.p.intParse(points[1 + i * 6 + 2])) / (100);
				point.orientationGlX = (this.one * this.p.intParse(points[1 + i * 6 + 3])) / (1000);
				point.orientationGlY = (this.one * this.p.intParse(points[1 + i * 6 + 4])) / (1000);
				point.orientationGlZ = (this.one * this.p.intParse(points[1 + i * 6 + 5])) / (1000);
				this.cameraPoints[this.cameraPointsCount++] = point;
			}
			this.m.displayNotification(this.p.stringFormat("Camera points loaded: {0}", this.p.intToString(n)));
		}
		return true;
	}
	return false;
}

ModAutoCamera.prototype.onNewFrame = function(game, args) {
	var dt = args.getDt();
	if (this.playingTime == -1) {
		return;
	}
	this.playingTime += dt;
	var playingDist = this.playingTime * this.playingSpeed;
	this.updateAvi(dt);
	var distA = 0;
	var foundPoint = -1;
	for (var i = 0; i < this.cameraPointsCount - 1; i++) {
		var a = this.cameraPoints[i];
		var b = this.cameraPoints[i + 1];
		var dist = this.distance(a, b);
		if (playingDist >= distA && playingDist < distA + dist) {
			foundPoint = i;
			break;
		}
		distA += dist;
	}
	if (foundPoint == -1) {
		this.stop();
		return;
	}
	{
		var a = this.cameraPoints[foundPoint];
		var b = this.cameraPoints[foundPoint + 1];
		var aminus = a;
		var bplus = b;
		if (foundPoint - 1 >= 0) {
			aminus = this.cameraPoints[foundPoint - 1];
		}
		if (foundPoint + 2 < this.cameraPointsCount) {
			bplus = this.cameraPoints[foundPoint + 2];
		}
		var t = (playingDist - distA) / (this.distance(a, b));
		var x = ModAutoCamera.q(t, aminus.positionGlX, a.positionGlX, b.positionGlX, bplus.positionGlX);
		var y = ModAutoCamera.q(t, aminus.positionGlY, a.positionGlY, b.positionGlY, bplus.positionGlY);
		var z = ModAutoCamera.q(t, aminus.positionGlZ, a.positionGlZ, b.positionGlZ, bplus.positionGlZ);
		this.m.setLocalPosition(x, y, z);
		var orientx = ModAutoCamera.q(t, aminus.orientationGlX, a.orientationGlX, b.orientationGlX, bplus.orientationGlX);
		var orienty = ModAutoCamera.q(t, aminus.orientationGlY, a.orientationGlY, b.orientationGlY, bplus.orientationGlY);
		var orientz = ModAutoCamera.q(t, aminus.orientationGlZ, a.orientationGlZ, b.orientationGlZ, bplus.orientationGlZ);
		this.m.setLocalOrientation(orientx, orienty, orientz);
	}
}

ModAutoCamera.prototype.start = function(modmanager) {
	this.m = modmanager;
	this.p = modmanager.getPlatform();
	this.one = 1;
	this.cameraPoints = new Array(256);
	this.cameraPointsCount = 0;
	this.playingTime = -1;
	this.position = new Float32Array(new ArrayBuffer(3 << 2));
	this.orientation = new Float32Array(new ArrayBuffer(3 << 2));
}

ModAutoCamera.prototype.stop = function() {
	this.m.showGui(1);
	this.m.enableCameraControl(true);
	if (this.playingTime != -1) {
		this.m.setFreemove(this.previousFreemove);
		this.m.setLocalPosition(this.previousPositionX, this.previousPositionY, this.previousPositionZ);
		this.m.setLocalOrientation(this.previousOrientationX, this.previousOrientationY, this.previousOrientationZ);
	}
	this.playingTime = -1;
	if (this.avi != null) {
		this.avi.close();
		this.avi = null;
	}
}

ModAutoCamera.prototype.totalDistance = function() {
	var totalDistance = 0;
	for (var i = 0; i < this.cameraPointsCount - 1; i++) {
		var a = this.cameraPoints[i];
		var b = this.cameraPoints[i + 1];
		var dist = this.distance(a, b);
		totalDistance += dist;
	}
	return totalDistance;
}

ModAutoCamera.prototype.updateAvi = function(dt) {
	if (this.avi == null) {
		return;
	}
	if (!this.firstFrameDone) {
		this.firstFrameDone = true;
		return;
	}
	this.writeAccum += dt;
	var totalTime = this.playingSpeed * this.totalDistance();
	if (this.writeAccum >= this.one / (60) * this.recspeed) {
		this.writeAccum -= this.one / (60) * this.recspeed;
		var bmp = this.m.grabScreenshot();
		this.avi.addFrame(bmp);
		bmp.dispose();
	}
}

ModAutoCamera.q = function(t, p0, p1, p2, p3) {
	var one_ = 1;
	return one_ / (2) * (2 * p1 + (-p0 + p2) * t + (2 * p0 - 5 * p1 + 4 * p2 - p3) * t * t + (-p0 + 3 * p1 - 3 * p2 + p3) * t * t * t);
}

function ModBlockDamageToPlayer()
{
	this.blockDamageToPlayerTimer = null;
	this.one = null;
	this.one = 1;
	this.blockDamageToPlayerTimer = TimerCi.create(1, 2);
}
ModBlockDamageToPlayer.prototype = new ClientMod();
ModBlockDamageToPlayer.BLOCK_DAMAGE_TO_PLAYER_EVERY = 1;

ModBlockDamageToPlayer.prototype.onNewFrameFixed = function(game, args) {
	if (game.guistate == GuiState.MAP_LOADING) {
		return;
	}
	if (game.followId() == null) {
		this.updateBlockDamageToPlayer(game, args.getDt());
	}
}

ModBlockDamageToPlayer.prototype.updateBlockDamageToPlayer = function(game, dt) {
	var pX = game.player.position.x;
	var pY = game.player.position.y;
	var pZ = game.player.position.z;
	pY += game.entities[game.localPlayerId].drawModel.eyeHeight;
	var block1 = 0;
	var block2 = 0;
	if (game.map.isValidPos(game.mathFloor(pX), game.mathFloor(pZ), game.mathFloor(pY))) {
		block1 = game.map.getBlock(game.platform.floatToInt(pX), game.platform.floatToInt(pZ), game.platform.floatToInt(pY));
	}
	if (game.map.isValidPos(game.mathFloor(pX), game.mathFloor(pZ), game.mathFloor(pY) - 1)) {
		block2 = game.map.getBlock(game.platform.floatToInt(pX), game.platform.floatToInt(pZ), game.platform.floatToInt(pY) - 1);
	}
	var damage = game.d_Data.damageToPlayer()[block1] + game.d_Data.damageToPlayer()[block2];
	if (damage > 0) {
		var hurtingBlock = block1;
		if (hurtingBlock == 0 || game.d_Data.damageToPlayer()[hurtingBlock] == 0) {
			hurtingBlock = block2;
		}
		var times = this.blockDamageToPlayerTimer.update(dt);
		for (var i = 0; i < times; i++) {
			game.applyDamageToPlayer(damage, 1, hurtingBlock);
		}
	}
	var deltaTime = game.platform.floatToInt(this.one * (game.platform.timeMillisecondsFromStart() - game.lastOxygenTickMilliseconds));
	if (deltaTime >= 1000) {
		if (game.waterSwimmingEyes()) {
			game.playerStats.currentOxygen -= 1;
			if (game.playerStats.currentOxygen <= 0) {
				game.playerStats.currentOxygen = 0;
				var dmg = game.platform.floatToInt((this.one * game.playerStats.maxHealth) / (10));
				if (dmg < 1) {
					dmg = 1;
				}
				game.applyDamageToPlayer(dmg, 2, block1);
			}
		}
		else {
			game.playerStats.currentOxygen = game.playerStats.maxOxygen;
		}
		if (GameVersionHelper.serverVersionAtLeast(game.platform, game.serverGameVersion, 2014, 3, 31)) {
			game.sendPacketClient(ClientPackets.oxygen(game.playerStats.currentOxygen));
		}
		game.lastOxygenTickMilliseconds = game.platform.timeMillisecondsFromStart();
	}
}

function ModBullet()
{
}
ModBullet.prototype = new ClientMod();

ModBullet.prototype.onNewFrameDraw3d = function(game, dt) {
	for (var i = 0; i < game.entitiesCount; i++) {
		var entity = game.entities[i];
		if (entity == null) {
			continue;
		}
		if (entity.bullet == null) {
			continue;
		}
		var b = entity.bullet;
		if (b.progress < 1) {
			b.progress = 1;
		}
		var dirX = b.toX - b.fromX;
		var dirY = b.toY - b.fromY;
		var dirZ = b.toZ - b.fromZ;
		var length = game.dist(0, 0, 0, dirX, dirY, dirZ);
		dirX /= length;
		dirY /= length;
		dirZ /= length;
		var posX = b.fromX;
		var posY = b.fromY;
		var posZ = b.fromZ;
		posX += dirX * (b.progress + b.speed * dt);
		posY += dirY * (b.progress + b.speed * dt);
		posZ += dirZ * (b.progress + b.speed * dt);
		b.progress += b.speed * dt;
		entity.sprite.positionX = posX;
		entity.sprite.positionY = posY;
		entity.sprite.positionZ = posZ;
		if (b.progress > length) {
			game.entities[i] = null;
		}
	}
}

function ModCamera()
{
	this.overheadCamera_cameraEye = null;
	this.upVec3 = null;
	this.overheadCamera_cameraEye = new Vector3Ref();
	this.upVec3 = Vec3.fromValues(0, 1, 0);
}
ModCamera.prototype = new ClientMod();

ModCamera.prototype.fppCamera = function(game) {
	var forward = new Vector3Ref();
	VectorTool.toVectorInFixedSystem(0, 0, 1, game.player.position.rotx, game.player.position.roty, forward);
	var cameraEye = new Vector3Ref();
	var cameraTarget = new Vector3Ref();
	var playerEyeX = game.player.position.x;
	var playerEyeY = game.player.position.y + game.getCharacterEyesHeight();
	var playerEyeZ = game.player.position.z;
	if (!game.eNABLE_TPP_VIEW) {
		cameraEye.x = playerEyeX;
		cameraEye.y = playerEyeY;
		cameraEye.z = playerEyeZ;
		cameraTarget.x = playerEyeX + forward.x;
		cameraTarget.y = playerEyeY + forward.y;
		cameraTarget.z = playerEyeZ + forward.z;
	}
	else {
		cameraEye.x = playerEyeX + forward.x * -game.tppcameradistance;
		cameraEye.y = playerEyeY + forward.y * -game.tppcameradistance;
		cameraEye.z = playerEyeZ + forward.z * -game.tppcameradistance;
		cameraTarget.x = playerEyeX;
		cameraTarget.y = playerEyeY;
		cameraTarget.z = playerEyeZ;
		var currentTppcameradistance = FloatRef.create(game.tppcameradistance);
		this.limitThirdPersonCameraToWalls(game, cameraEye, cameraTarget, currentTppcameradistance);
	}
	var ret = new Float32Array(new ArrayBuffer(16 << 2));
	Mat4.lookAt(ret, Vec3.fromValues(cameraEye.x, cameraEye.y, cameraEye.z), Vec3.fromValues(cameraTarget.x, cameraTarget.y, cameraTarget.z), this.upVec3);
	game.cameraEyeX = cameraEye.x;
	game.cameraEyeY = cameraEye.y;
	game.cameraEyeZ = cameraEye.z;
	return ret;
}

ModCamera.prototype.limitThirdPersonCameraToWalls = function(game, eye, target, curtppcameradistance) {
	var one = 1;
	var ray_start_point = target;
	var raytarget = eye;
	var pick = new Line3D();
	var raydirX = raytarget.x - ray_start_point.x;
	var raydirY = raytarget.y - ray_start_point.y;
	var raydirZ = raytarget.z - ray_start_point.z;
	var raydirLength1 = game.length(raydirX, raydirY, raydirZ);
	raydirX /= raydirLength1;
	raydirY /= raydirLength1;
	raydirZ /= raydirLength1;
	raydirX = raydirX * (game.tppcameradistance + 1);
	raydirY = raydirY * (game.tppcameradistance + 1);
	raydirZ = raydirZ * (game.tppcameradistance + 1);
	pick.start = Vec3.fromValues(ray_start_point.x, ray_start_point.y, ray_start_point.z);
	pick.end = new Float32Array(new ArrayBuffer(3 << 2));
	pick.end[0] = ray_start_point.x + raydirX;
	pick.end[1] = ray_start_point.y + raydirY;
	pick.end[2] = ray_start_point.z + raydirZ;
	var pick2Count = new IntRef();
	var pick2 = game.pick(game.s, pick, pick2Count);
	if (pick2Count.value > 0) {
		var pick2nearest = game.nearest(pick2, pick2Count.value, ray_start_point.x, ray_start_point.y, ray_start_point.z);
		var pickX = pick2nearest.blockPos[0] - target.x;
		var pickY = pick2nearest.blockPos[1] - target.y;
		var pickZ = pick2nearest.blockPos[2] - target.z;
		var pickdistance = game.length(pickX, pickY, pickZ);
		curtppcameradistance.value = MathCi.minFloat(pickdistance - 1, curtppcameradistance.value);
		if (curtppcameradistance.value < (one * 3) / (10)) {
			curtppcameradistance.value = (one * 3) / (10);
		}
	}
	var cameraDirectionX = target.x - eye.x;
	var cameraDirectionY = target.y - eye.y;
	var cameraDirectionZ = target.z - eye.z;
	var raydirLength = game.length(raydirX, raydirY, raydirZ);
	raydirX /= raydirLength;
	raydirY /= raydirLength;
	raydirZ /= raydirLength;
	eye.x = target.x + raydirX * curtppcameradistance.value;
	eye.y = target.y + raydirY * curtppcameradistance.value;
	eye.z = target.z + raydirZ * curtppcameradistance.value;
}

ModCamera.prototype.onBeforeNewFrameDraw3d = function(game, deltaTime) {
	if (game.overheadcamera) {
		game.camera = this.overheadCamera(game);
	}
	else {
		game.camera = this.fppCamera(game);
	}
}

ModCamera.prototype.overheadCamera = function(game) {
	game.overheadcameraK.getPosition(game.platform, this.overheadCamera_cameraEye);
	var cameraEye = this.overheadCamera_cameraEye;
	var cameraTarget = Vector3Ref.create(game.overheadcameraK.center.x, game.overheadcameraK.center.y + game.getCharacterEyesHeight(), game.overheadcameraK.center.z);
	var currentOverheadcameradistance = FloatRef.create(game.overheadcameradistance);
	this.limitThirdPersonCameraToWalls(game, cameraEye, cameraTarget, currentOverheadcameradistance);
	var ret = new Float32Array(new ArrayBuffer(16 << 2));
	Mat4.lookAt(ret, Vec3.fromValues(cameraEye.x, cameraEye.y, cameraEye.z), Vec3.fromValues(cameraTarget.x, cameraTarget.y, cameraTarget.z), this.upVec3);
	game.cameraEyeX = cameraEye.x;
	game.cameraEyeY = cameraEye.y;
	game.cameraEyeZ = cameraEye.z;
	return ret;
}

function ModCameraKeys()
{
}
ModCameraKeys.prototype = new ClientMod();

ModCameraKeys.prototype.onNewFrameFixed = function(game, args) {
	var one = 1;
	var dt = args.getDt();
	if (game.guistate == GuiState.MAP_LOADING) {
		return;
	}
	var angleup = false;
	var angledown = false;
	var overheadcameraanglemovearea = (one * 5) / (100);
	var overheadcameraspeed = 3;
	game.controls.wantsjump = game.guistate == GuiState.NORMAL && game.guiTyping == TypingState.NONE && game.keyboardState[game.getKey(51)];
	game.controls.wantsjumphalf = false;
	game.controls.shiftkeydown = game.guistate == GuiState.NORMAL && game.guiTyping == TypingState.NONE && game.keyboardState[game.getKey(1)];
	game.controls.movedx = 0;
	game.controls.movedy = 0;
	game.controls.moveup = false;
	game.controls.movedown = false;
	if (game.guistate == GuiState.NORMAL) {
		if (game.guiTyping == TypingState.NONE) {
			if (game.reachedwall_1blockhigh && (game.autoJumpEnabled || !game.platform.isMousePointerLocked())) {
				game.controls.wantsjump = true;
			}
			if (game.reachedHalfBlock) {
				game.controls.wantsjumphalf = true;
			}
			if (game.overheadcamera) {
				var m = new CameraMove();
				if (game.keyboardState[game.getKey(83)]) {
					game.overheadcameraK.turnRight(dt * overheadcameraspeed);
				}
				if (game.keyboardState[game.getKey(86)]) {
					game.overheadcameraK.turnLeft(dt * overheadcameraspeed);
				}
				if (game.keyboardState[game.getKey(105)]) {
					angleup = true;
				}
				if (game.keyboardState[game.getKey(101)]) {
					angledown = true;
				}
				game.overheadcameraK.center.x = game.player.position.x;
				game.overheadcameraK.center.y = game.player.position.y;
				game.overheadcameraK.center.z = game.player.position.z;
				m.distance = game.overheadcameradistance;
				m.angleUp = angleup;
				m.angleDown = angledown;
				game.overheadcameraK.move(m, dt);
				var toDest = game.dist(game.player.position.x, game.player.position.y, game.player.position.z, game.playerdestination.x + one / (2), game.playerdestination.y - one / (2), game.playerdestination.z + one / (2));
				if (toDest >= 1) {
					game.controls.movedy += 1;
					if (game.reachedwall) {
						game.controls.wantsjump = true;
					}
					var qX = game.playerdestination.x - game.player.position.x;
					var qY = game.playerdestination.y - game.player.position.y;
					var qZ = game.playerdestination.z - game.player.position.z;
					var angle = game.vectorAngleGet(qX, qY, qZ);
					game.player.position.roty = Game.getPi() / (2) + angle;
					game.player.position.rotx = Game.getPi();
				}
			}
			else if (game.enable_move) {
				if (game.keyboardState[game.getKey(105)]) {
					game.controls.movedy += 1;
				}
				if (game.keyboardState[game.getKey(101)]) {
					game.controls.movedy += -1;
				}
				if (game.keyboardState[game.getKey(83)]) {
					game.controls.movedx += -1;
					game.localplayeranimationhint.leanleft = true;
					game.localstance = 1;
				}
				else {
					game.localplayeranimationhint.leanleft = false;
				}
				if (game.keyboardState[game.getKey(86)]) {
					game.controls.movedx += 1;
					game.localplayeranimationhint.leanright = true;
					game.localstance = 2;
				}
				else {
					game.localplayeranimationhint.leanright = false;
				}
				if (!game.localplayeranimationhint.leanleft && !game.localplayeranimationhint.leanright) {
					game.localstance = 0;
				}
				game.controls.movedx += game.touchMoveDx;
				game.controls.movedy += game.touchMoveDy;
			}
		}
		if (game.controls.getFreemove() != 0 || game.swimmingEyes()) {
			if (game.guiTyping == TypingState.NONE && game.keyboardState[game.getKey(51)]) {
				game.controls.moveup = true;
			}
			if (game.guiTyping == TypingState.NONE && game.keyboardState[game.getKey(3)]) {
				game.controls.movedown = true;
			}
		}
	}
}

function ModClearInactivePlayersDrawInfo()
{
}
ModClearInactivePlayersDrawInfo.prototype = new ClientMod();

ModClearInactivePlayersDrawInfo.prototype.onNewFrameFixed = function(game, args) {
	var one = 1;
	var now = game.platform.timeMillisecondsFromStart();
	for (var i = 0; i < 64; i++) {
		if (game.entities[i] == null) {
			continue;
		}
		if (game.entities[i].playerDrawInfo == null) {
			continue;
		}
		if (game.entities[i].networkPosition == null) {
			continue;
		}
		var kKey = i;
		var p = game.entities[i];
		if ((one * (now - p.networkPosition.lastUpdateMilliseconds)) / (1000) > 2) {
			p.playerDrawInfo = null;
			p.networkPosition.positionLoaded = false;
		}
	}
}

function ModCompass()
{
	this.compassangle = null;
	this.compassid = 0;
	this.compassvertex = null;
	this.needleid = 0;
	this.one = null;
	this.one = 1;
	this.compassid = -1;
	this.needleid = -1;
	this.compassangle = 0;
	this.compassvertex = 1;
}
ModCompass.prototype = new ClientMod();

ModCompass.prototype.compassInActiveMaterials = function(game) {
	for (var i = 0; i < 10; i++) {
		if (game.materialSlots_(i) == game.d_Data.blockIdCompass()) {
			return true;
		}
	}
	return false;
}

ModCompass.prototype.drawCompass = function(game) {
	if (!this.compassInActiveMaterials(game))
		return;
	if (this.compassid == -1) {
		this.compassid = game.getTexture("compass.png");
		this.needleid = game.getTexture("compassneedle.png");
	}
	var size = 175;
	var posX = game.width() - 100;
	var posY = 100;
	var playerorientation = -(game.player.position.roty / (2 * Game.getPi()) * 360);
	this.compassvertex += (playerorientation - this.compassangle) / (50);
	this.compassvertex *= (this.one * 9) / (10);
	this.compassangle += this.compassvertex;
	game.draw2dTexture(this.compassid, posX - size / (2), posY - size / (2), size, size, null, 0, Game.colorFromArgb(255, 255, 255, 255), false);
	game.gLPushMatrix();
	game.gLTranslate(posX, posY, 0);
	game.gLRotate(this.compassangle, 0, 0, 90);
	game.gLTranslate(Math.floor(-size / 2), Math.floor(-size / 2), 0);
	game.draw2dTexture(this.needleid, 0, 0, size, size, null, 0, Game.colorFromArgb(255, 255, 255, 255), false);
	game.gLPopMatrix();
}

ModCompass.prototype.onNewFrameDraw2d = function(game, dt) {
	if (game.guistate == GuiState.MAP_LOADING) {
		return;
	}
	this.drawCompass(game);
}

function ModDebugChunk()
{
	this.draw = false;
	this.lines = null;
	this.draw = false;
	this.lines = new DrawWireframeCube();
}
ModDebugChunk.prototype = new ClientMod();

ModDebugChunk.prototype.onClientCommand = function(game, args) {
	if (args.command == "chunk") {
		this.draw = !this.draw;
		return true;
	}
	return false;
}

ModDebugChunk.prototype.onNewFrameDraw3d = function(game, deltaTime) {
	if (this.draw) {
		this.lines.drawWireframeCube_(game, game.platform.floatToInt(game.player.position.x / (16)) * 16 + 8, game.platform.floatToInt(game.player.position.y / (16)) * 16 + 8, game.platform.floatToInt(game.player.position.z / (16)) * 16 + 8, 16, 16, 16);
	}
}

function ModDialog()
{
	this.packetHandler = null;
	this.packetHandler = new ClientPacketHandlerDialog();
}
ModDialog.prototype = new ClientMod();

ModDialog.prototype.drawDialogs = function(game) {
	for (var i = 0; i < game.dialogsCount; i++) {
		if (game.dialogs[i] == null) {
			continue;
		}
		var d = game.dialogs[i];
		var x = Math.floor(game.width() / 2) - Math.floor(d.value.width / 2);
		var y = Math.floor(game.height() / 2) - Math.floor(d.value.height_ / 2);
		d.screen.screenx = x;
		d.screen.screeny = y;
		d.screen.drawWidgets();
	}
}

ModDialog.prototype.onKeyDown = function(game, args) {
	for (var i = 0; i < game.dialogsCount; i++) {
		if (game.dialogs[i] == null) {
			continue;
		}
		game.dialogs[i].screen.onKeyDown(game, args);
	}
	if (game.guistate == GuiState.NORMAL) {
		if (args.getKeyCode() == game.getKey(50)) {
			for (var i = 0; i < game.dialogsCount; i++) {
				if (game.dialogs[i] == null) {
					continue;
				}
				var d = game.dialogs[i];
				if (d.value.isModal != 0) {
					game.dialogs[i] = null;
					return;
				}
			}
			game.showEscapeMenu();
			args.setHandled(true);
			return;
		}
	}
	if (game.guistate == GuiState.MODAL_DIALOG) {
		if (args.getKeyCode() == game.getKey(50)) {
			for (var i = 0; i < game.dialogsCount; i++) {
				if (game.dialogs[i] == null) {
					continue;
				}
				if (game.dialogs[i].value.isModal != 0) {
					game.dialogs[i] = null;
				}
			}
			game.sendPacketClient(ClientPackets.dialogClick("Esc", new Array(0), 0));
			game.guiStateBackToGame();
			args.setHandled(true);
		}
		if (args.getKeyCode() == game.getKey(52)) {
			game.sendPacketClient(ClientPackets.dialogClick("Tab", new Array(0), 0));
			args.setHandled(true);
		}
		return;
	}
}

ModDialog.prototype.onKeyPress = function(game, args) {
	if (game.guistate != GuiState.MODAL_DIALOG && game.guistate != GuiState.NORMAL) {
		return;
	}
	if (game.isTyping) {
		return;
	}
	for (var i = 0; i < game.dialogsCount; i++) {
		if (game.dialogs[i] == null) {
			continue;
		}
		game.dialogs[i].screen.onKeyPress(game, args);
	}
	for (var k = 0; k < game.dialogsCount; k++) {
		if (game.dialogs[k] == null) {
			continue;
		}
		var d = game.dialogs[k];
		for (var i = 0; i < d.value.widgetsCount; i++) {
			var w = d.value.widgets[i];
			if (w == null) {
				continue;
			}
			var valid = "abcdefghijklmnopqrstuvwxyz1234567890\t ";
			if (game.platform.stringContains(valid, game.charToString(w.clickKey))) {
				if (args.getKeyChar() == w.clickKey) {
					game.sendPacketClient(ClientPackets.dialogClick(w.id, new Array(0), 0));
					return;
				}
			}
		}
	}
}

ModDialog.prototype.onKeyUp = function(game, args) {
	for (var i = 0; i < game.dialogsCount; i++) {
		if (game.dialogs[i] == null) {
			continue;
		}
		game.dialogs[i].screen.onKeyUp(game, args);
	}
}

ModDialog.prototype.onMouseDown = function(game, args) {
	for (var i = 0; i < game.dialogsCount; i++) {
		if (game.dialogs[i] == null) {
			continue;
		}
		game.dialogs[i].screen.onMouseDown(game, args);
	}
}

ModDialog.prototype.onMouseUp = function(game, args) {
	for (var i = 0; i < game.dialogsCount; i++) {
		if (game.dialogs[i] == null) {
			continue;
		}
		game.dialogs[i].screen.onMouseUp(game, args);
	}
}

ModDialog.prototype.onNewFrameDraw2d = function(game, deltaTime) {
	game.packetHandlers[52] = this.packetHandler;
	this.drawDialogs(game);
}

function ModDraw2dMisc()
{
}
ModDraw2dMisc.prototype = new ClientMod();

ModDraw2dMisc.prototype.drawAim = function(game) {
	if (game.cameratype == CameraType.OVERHEAD) {
		return;
	}
	var aimwidth = 32;
	var aimheight = 32;
	game.platform.bindTexture2d(0);
	if (game.currentAimRadius() > 1) {
		var fov_ = game.currentfov();
		game.circle3i(Math.floor(game.width() / 2), Math.floor(game.height() / 2), (game.currentAimRadius() * game.fov) / (fov_));
	}
	game.draw2dBitmapFile("target.png", Math.floor(game.width() / 2) - Math.floor(aimwidth / 2), Math.floor(game.height() / 2) - Math.floor(aimheight / 2), aimwidth, aimheight);
}

ModDraw2dMisc.prototype.drawAmmo = function(game) {
	var item = game.d_Inventory.rightHand[game.activeMaterial];
	if (item != null && item.itemClass == 0) {
		if (game.blocktypes[item.blockId].isPistol) {
			var loaded = game.loadedAmmo[item.blockId];
			var total = game.totalAmmo[item.blockId];
			var s = game.platform.stringFormat2("{0}/{1}", game.platform.intToString(loaded), game.platform.intToString(total - loaded));
			var font = new FontCi();
			font.size = 18;
			game.draw2dText(s, font, game.width() - game.textSizeWidth(s, font) - 50, game.height() - game.textSizeHeight(s, font) - 50, loaded == 0 ? IntRef.create(Game.colorFromArgb(255, 255, 0, 0)) : IntRef.create(Game.colorFromArgb(255, 255, 255, 255)), false);
			if (loaded == 0) {
				font.size = 14;
				var pressR = "Press R to reload";
				game.draw2dText(pressR, font, game.width() - game.textSizeWidth(pressR, font) - 50, game.height() - game.textSizeHeight(s, font) - 80, IntRef.create(Game.colorFromArgb(255, 255, 0, 0)), false);
			}
		}
	}
}

ModDraw2dMisc.prototype.drawBlockInfo = function(game) {
	if (!game.drawblockinfo) {
		return;
	}
	var x = game.selectedBlockPositionX;
	var y = game.selectedBlockPositionZ;
	var z = game.selectedBlockPositionY;
	if (!game.map.isValidPos(x, y, z)) {
		return;
	}
	var blocktype = game.map.getBlock(x, y, z);
	if (!game.isValid(blocktype)) {
		return;
	}
	game.currentAttackedBlock = Vector3IntRef.create(x, y, z);
	this.drawEnemyHealthBlock(game);
}

ModDraw2dMisc.prototype.drawDisconnected = function(game) {
	var one = 1;
	var lagSeconds = (one * (game.platform.timeMillisecondsFromStart() - game.lastReceivedMilliseconds)) / (1000);
	if (lagSeconds >= 10 && lagSeconds < 86400 && game.invalidVersionDrawMessage == null && !(game.issingleplayer && !game.platform.singlePlayerServerLoaded())) {
		game.draw2dBitmapFile("disconnected.png", game.width() - 100, 50, 50, 50);
		var font = new FontCi();
		font.size = 12;
		game.draw2dText(game.platform.intToString(game.platform.floatToInt(lagSeconds)), font, game.width() - 100, 110, null, false);
		game.draw2dText("Press F6 to reconnect", font, Math.floor(game.width() / 2) - 100, 50, null, false);
	}
}

ModDraw2dMisc.prototype.drawEnemyHealthBlock = function(game) {
	if (game.currentAttackedBlock != null) {
		var x = game.currentAttackedBlock.x;
		var y = game.currentAttackedBlock.y;
		var z = game.currentAttackedBlock.z;
		var blocktype = game.map.getBlock(x, y, z);
		var health = game.getCurrentBlockHealth(x, y, z);
		var progress = health / (game.d_Data.strength()[blocktype]);
		if (game.isUsableBlock(blocktype)) {
			this.drawEnemyHealthUseInfo(game, game.language.get(StringTools.stringAppend(game.platform, "Block_", game.blocktypes[blocktype].name)), progress, true);
		}
		this.drawEnemyHealthCommon(game, game.language.get(StringTools.stringAppend(game.platform, "Block_", game.blocktypes[blocktype].name)), progress);
	}
	if (game.currentlyAttackedEntity != -1) {
		var e = game.entities[game.currentlyAttackedEntity];
		if (e == null) {
			return;
		}
		var health;
		if (e.playerStats != null) {
			health = (game.one * e.playerStats.currentHealth) / (e.playerStats.maxHealth);
		}
		else {
			health = 1;
		}
		var name = "Unknown";
		if (e.drawName != null) {
			name = e.drawName.name;
		}
		if (e.usable) {
			this.drawEnemyHealthUseInfo(game, game.language.get(name), health, true);
		}
		this.drawEnemyHealthCommon(game, game.language.get(name), health);
	}
}

ModDraw2dMisc.prototype.drawEnemyHealthCommon = function(game, name, progress) {
	this.drawEnemyHealthUseInfo(game, name, 1, false);
}

ModDraw2dMisc.prototype.drawEnemyHealthUseInfo = function(game, name, progress, useInfo) {
	var y = useInfo ? 55 : 35;
	game.draw2dTexture(game.whiteTexture(), game.xcenter(300), 40, 300, y, null, 0, Game.colorFromArgb(255, 0, 0, 0), false);
	game.draw2dTexture(game.whiteTexture(), game.xcenter(300), 40, 300 * progress, y, null, 0, Game.colorFromArgb(255, 255, 0, 0), false);
	var font = new FontCi();
	font.size = 14;
	var w = new IntRef();
	var h = new IntRef();
	game.platform.textSize(name, font, w, h);
	game.draw2dText(name, font, game.xcenter(w.value), 40, null, false);
	if (useInfo) {
		name = game.platform.stringFormat(game.language.pressToUse(), "E");
		var font2 = new FontCi();
		font2.size = 10;
		game.platform.textSize(name, font2, w, h);
		game.draw2dText(name, font2, game.xcenter(w.value), 70, null, false);
	}
}

ModDraw2dMisc.prototype.drawMouseCursor = function(game) {
	if (!game.getFreeMouse()) {
		return;
	}
	if (!game.platform.mouseCursorIsVisible()) {
		game.draw2dBitmapFile("mousecursor.png", game.mouseCurrentX, game.mouseCurrentY, 32, 32);
	}
}

ModDraw2dMisc.prototype.onNewFrameDraw2d = function(game, deltaTime) {
	if (game.guistate == GuiState.NORMAL) {
		this.drawAim(game);
	}
	if (game.guistate != GuiState.MAP_LOADING) {
		this.drawEnemyHealthBlock(game);
		this.drawAmmo(game);
		this.drawBlockInfo(game);
	}
	this.drawMouseCursor(game);
	this.drawDisconnected(game);
}

function ModDrawArea()
{
	this.lines = null;
}
ModDrawArea.prototype = new ClientMod();

ModDrawArea.prototype.onHitEntity = function(game, e) {
	var entity = game.entities[e.entityId];
	if (entity == null) {
		return;
	}
	if (entity.drawArea == null) {
		return;
	}
	entity.drawArea.visible = !entity.drawArea.visible;
}

ModDrawArea.prototype.onNewFrameDraw3d = function(game, deltaTime) {
	if (game.eNABLE_DRAW2D) {
		for (var i = 0; i < game.entitiesCount; i++) {
			var e = game.entities[i];
			if (e == null) {
				continue;
			}
			if (e.drawArea == null) {
				continue;
			}
			if (!e.drawArea.visible) {
				continue;
			}
			var x = e.drawArea.x + Math.floor(e.drawArea.sizex / 2);
			var y = e.drawArea.y + Math.floor(e.drawArea.sizey / 2);
			var z = e.drawArea.z + Math.floor(e.drawArea.sizez / 2);
			var scalex = e.drawArea.sizex;
			var scaley = e.drawArea.sizey;
			var scalez = e.drawArea.sizez;
			this.lines.drawWireframeCube_(game, x, y, z, scalex, scaley, scalez);
		}
	}
}

ModDrawArea.prototype.onNewFrameFixed = function(game, args) {
	this.lines = new DrawWireframeCube();
}

function ModDrawHand2d()
{
	this.lasthandimage = null;
}
ModDrawHand2d.prototype = new ClientMod();

ModDrawHand2d.handImage2d = function(game) {
	var item = game.d_Inventory.rightHand[game.activeMaterial];
	var img = null;
	if (item != null) {
		img = game.blocktypes[item.blockId].handimage;
		if (game.ironSights) {
			img = game.blocktypes[item.blockId].ironSightsImage;
		}
	}
	return img;
}

ModDrawHand2d.prototype.onNewFrameDraw3d = function(game, deltaTime) {
	if (ModDrawHand2d.shouldDrawHand(game)) {
		var img = ModDrawHand2d.handImage2d(game);
		if (img != null) {
			game.orthoMode(game.width(), game.height());
			if (this.lasthandimage != img) {
				this.lasthandimage = img;
				var file = game.getFile(img);
				var bmp = game.platform.bitmapCreateFromPng(file, game.platform.byteArrayLength(file));
				if (bmp != null) {
					game.handTexture = game.platform.loadTextureFromBitmap(bmp);
					game.platform.bitmapDelete(bmp);
				}
			}
			game.draw2dTexture(game.handTexture, Math.floor(game.width() / 2), game.height() - 512, 512, 512, null, 0, Game.colorFromArgb(255, 255, 255, 255), false);
			game.perspectiveMode();
		}
	}
}

ModDrawHand2d.shouldDrawHand = function(game) {
	return !game.eNABLE_TPP_VIEW && game.eNABLE_DRAW2D;
}

function ModDrawHand3d()
{
	this.animperiod = null;
	this.attack = null;
	this.attackt = null;
	this.build = false;
	this.buildt = null;
	this.d_BlockRendererTorch = null;
	this.game = null;
	this.modelData = null;
	this.oldLight = null;
	this.oldMaterial = 0;
	this.oldplayerposX = null;
	this.oldplayerposY = null;
	this.oldplayerposZ = null;
	this.one = null;
	this.range = null;
	this.slowdownTimer = null;
	this.slowdownTimerSpecial = null;
	this.speed = null;
	this.t_ = null;
	this.zzzposx = null;
	this.zzzposy = null;
	this.zzzposz = null;
	this.zzzx = null;
	this.zzzy = null;
	this.one = 1;
	this.attackt = 0;
	this.buildt = 0;
	this.range = (this.one * 7) / (100);
	this.speed = 5;
	this.animperiod = Game.getPi() / (this.speed / (2));
	this.zzzposz = 0;
	this.t_ = 0;
	this.zzzx = -27;
	this.zzzy = Math.floor(-this.one * 137 / 10);
	this.zzzposx = Math.floor(-this.one * 2 / 10);
	this.zzzposy = Math.floor(-this.one * 4 / 10);
	this.attack = -1;
	this.build = false;
	this.slowdownTimerSpecial = 32000;
	this.d_BlockRendererTorch = new BlockRendererTorch();
}
ModDrawHand3d.prototype = new ClientMod();

ModDrawHand3d.prototype.addVertex = function(model, x, y, z, u, v, color) {
	model.xyz[model.getXyzCount() + 0] = x;
	model.xyz[model.getXyzCount() + 1] = y;
	model.xyz[model.getXyzCount() + 2] = z;
	model.uv[model.getUvCount() + 0] = u;
	model.uv[model.getUvCount() + 1] = v;
	model.rgba[model.getRgbaCount() + 0] = Game.intToByte(Game.colorR(color));
	model.rgba[model.getRgbaCount() + 1] = Game.intToByte(Game.colorG(color));
	model.rgba[model.getRgbaCount() + 2] = Game.intToByte(Game.colorB(color));
	model.rgba[model.getRgbaCount() + 3] = Game.intToByte(Game.colorA(color));
	model.verticesCount++;
}

ModDrawHand3d.prototype.drawCube = function(m, x, y, z, c) {
	{
		var sidetexture = this.getWeaponTextureId(0);
		var texrec = TextureAtlas.textureCoords2d(sidetexture, this.texturesPacked());
		var lastelement = m.getVerticesCount();
		this.addVertex(m, x + 0, z + 1, y + 0, texrec.left(), texrec.top(), c);
		this.addVertex(m, x + 0, z + 1, y + 1, texrec.left(), texrec.bottom(), c);
		this.addVertex(m, x + 1, z + 1, y + 0, texrec.right(), texrec.top(), c);
		this.addVertex(m, x + 1, z + 1, y + 1, texrec.right(), texrec.bottom(), c);
		m.indices[m.indicesCount++] = lastelement + 0;
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 2;
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 3;
		m.indices[m.indicesCount++] = lastelement + 2;
	}
	{
		var sidetexture = this.getWeaponTextureId(1);
		var texrec = TextureAtlas.textureCoords2d(sidetexture, this.texturesPacked());
		var lastelement = m.getVerticesCount();
		this.addVertex(m, x + 0, z, y + 0, texrec.left(), texrec.top(), c);
		this.addVertex(m, x + 0, z, y + 1, texrec.left(), texrec.bottom(), c);
		this.addVertex(m, x + 1, z, y + 0, texrec.right(), texrec.top(), c);
		this.addVertex(m, x + 1, z, y + 1, texrec.right(), texrec.bottom(), c);
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 0;
		m.indices[m.indicesCount++] = lastelement + 2;
		m.indices[m.indicesCount++] = lastelement + 3;
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 2;
	}
	{
		var sidetexture = this.getWeaponTextureId(2);
		var texrec = TextureAtlas.textureCoords2d(sidetexture, this.texturesPacked());
		var lastelement = m.getVerticesCount();
		this.addVertex(m, x + 0, z + 0, y + 0, texrec.left(), texrec.bottom(), c);
		this.addVertex(m, x + 0, z + 0, y + 1, texrec.right(), texrec.bottom(), c);
		this.addVertex(m, x + 0, z + 1, y + 0, texrec.left(), texrec.top(), c);
		this.addVertex(m, x + 0, z + 1, y + 1, texrec.right(), texrec.top(), c);
		m.indices[m.indicesCount++] = lastelement + 0;
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 2;
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 3;
		m.indices[m.indicesCount++] = lastelement + 2;
	}
	{
		var sidetexture = this.getWeaponTextureId(3);
		var texrec = TextureAtlas.textureCoords2d(sidetexture, this.texturesPacked());
		var lastelement = m.getVerticesCount();
		this.addVertex(m, x + 1, z + 0, y + 0, texrec.left(), texrec.bottom(), c);
		this.addVertex(m, x + 1, z + 0, y + 1, texrec.right(), texrec.bottom(), c);
		this.addVertex(m, x + 1, z + 1, y + 0, texrec.left(), texrec.top(), c);
		this.addVertex(m, x + 1, z + 1, y + 1, texrec.right(), texrec.top(), c);
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 0;
		m.indices[m.indicesCount++] = lastelement + 2;
		m.indices[m.indicesCount++] = lastelement + 3;
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 2;
	}
	{
		var sidetexture = this.getWeaponTextureId(4);
		var texrec = TextureAtlas.textureCoords2d(sidetexture, this.texturesPacked());
		var lastelement = m.getVerticesCount();
		this.addVertex(m, x + 0, z + 0, y + 0, texrec.left(), texrec.bottom(), c);
		this.addVertex(m, x + 0, z + 1, y + 0, texrec.left(), texrec.top(), c);
		this.addVertex(m, x + 1, z + 0, y + 0, texrec.right(), texrec.bottom(), c);
		this.addVertex(m, x + 1, z + 1, y + 0, texrec.right(), texrec.top(), c);
		m.indices[m.indicesCount++] = lastelement + 0;
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 2;
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 3;
		m.indices[m.indicesCount++] = lastelement + 2;
	}
	{
		var sidetexture = this.getWeaponTextureId(5);
		var texrec = TextureAtlas.textureCoords2d(sidetexture, this.texturesPacked());
		var lastelement = m.getVerticesCount();
		this.addVertex(m, x + 0, z + 0, y + 1, texrec.left(), texrec.bottom(), c);
		this.addVertex(m, x + 0, z + 1, y + 1, texrec.left(), texrec.top(), c);
		this.addVertex(m, x + 1, z + 0, y + 1, texrec.right(), texrec.bottom(), c);
		this.addVertex(m, x + 1, z + 1, y + 1, texrec.right(), texrec.top(), c);
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 0;
		m.indices[m.indicesCount++] = lastelement + 2;
		m.indices[m.indicesCount++] = lastelement + 3;
		m.indices[m.indicesCount++] = lastelement + 1;
		m.indices[m.indicesCount++] = lastelement + 2;
	}
}

ModDrawHand3d.prototype.drawWeapon = function(dt) {
	var light;
	if (this.isTorch()) {
		light = 255;
	}
	else {
		light = this.game.platform.floatToInt(this.light() * 256);
		if (light > 255) {
			light = 255;
		}
		if (light < 0) {
			light = 0;
		}
	}
	this.game.platform.bindTexture2d(this.terrainTexture());
	var item = this.game.d_Inventory.rightHand[this.game.activeMaterial];
	var curmaterial;
	if (item == null) {
		curmaterial = 0;
	}
	else {
		curmaterial = item.blockId == 151 ? 128 : item.blockId;
	}
	var curlight = this.light();
	if (curmaterial != this.oldMaterial || curlight != this.oldLight || this.modelData == null || this.game.handRedraw) {
		this.game.handRedraw = false;
		this.modelData = new ModelData();
		this.modelData.indices = new Int32Array(new ArrayBuffer(128 << 2));
		this.modelData.xyz = new Float32Array(new ArrayBuffer(128 << 2));
		this.modelData.uv = new Float32Array(new ArrayBuffer(128 << 2));
		this.modelData.rgba = new Uint8Array(new ArrayBuffer(128));
		var x = 0;
		var y = 0;
		var z = 0;
		if (this.isEmptyHand() || this.isCompass()) {
			this.d_BlockRendererTorch.topTexture = this.getWeaponTextureId(0);
			this.d_BlockRendererTorch.sideTexture = this.getWeaponTextureId(2);
			this.d_BlockRendererTorch.addTorch(this.game.d_Data, this.game, this.modelData, x, y, z, TorchType.NORMAL);
		}
		else if (this.isTorch()) {
			this.d_BlockRendererTorch.topTexture = this.getWeaponTextureId(0);
			this.d_BlockRendererTorch.sideTexture = this.getWeaponTextureId(2);
			this.d_BlockRendererTorch.addTorch(this.game.d_Data, this.game, this.modelData, x, y, z, TorchType.NORMAL);
		}
		else {
			this.drawCube(this.modelData, x, y, z, Game.colorFromArgb(255, light, light, light));
		}
	}
	this.oldMaterial = curmaterial;
	this.oldLight = curlight;
	this.game.platform.glClearDepthBuffer();
	this.game.gLMatrixModeModelView();
	this.game.gLPushMatrix();
	this.game.gLLoadIdentity();
	this.game.gLTranslate((this.one * 3) / (10) + this.zzzposz - this.attackt * 5, -(this.one * 15) / (10) + this.zzzposx - this.buildt * 10, -(this.one * 15) / (10) + this.zzzposy);
	this.game.gLRotate(30 + this.zzzx - this.attackt * 300, 1, 0, 0);
	this.game.gLRotate(60 + this.zzzy, 0, 1, 0);
	this.game.gLScale((this.one * 8) / (10), (this.one * 8) / (10), (this.one * 8) / (10));
	var move = !(this.oldplayerposX == this.game.player.position.x && this.oldplayerposY == this.game.player.position.y && this.oldplayerposZ == this.game.player.position.z);
	this.oldplayerposX = this.game.player.position.x;
	this.oldplayerposY = this.game.player.position.y;
	this.oldplayerposZ = this.game.player.position.z;
	if (move) {
		this.t_ += dt;
		this.slowdownTimer = this.slowdownTimerSpecial;
	}
	else {
		if (this.slowdownTimer == this.slowdownTimerSpecial) {
			this.slowdownTimer = this.animperiod / (2) - this.t_ % this.animperiod / (2);
		}
		this.slowdownTimer -= dt;
		if (this.slowdownTimer < 0) {
			this.t_ = 0;
		}
		else {
			this.t_ += dt;
		}
	}
	this.zzzposx = this.rot(this.t_);
	this.zzzposz = this.rot2(this.t_);
	if (this.attack != -1) {
		this.attack += dt * 7;
		if (this.attack > Game.getPi() / (2)) {
			this.attack = -1;
			if (this.build) {
				this.buildt = 0;
			}
			else {
				this.attackt = 0;
			}
		}
		else {
			if (this.build) {
				this.buildt = this.rot(this.attack / (5));
				this.attackt = 0;
			}
			else {
				this.attackt = this.rot(this.attack / (5));
				this.buildt = 0;
			}
		}
	}
	this.game.platform.glEnableTexture2d();
	this.game.platform.bindTexture2d(this.terrainTexture());
	this.game.drawModelData(this.modelData);
	this.game.gLPopMatrix();
}

ModDrawHand3d.prototype.getWeaponTextureId = function(side) {
	var item = this.game.d_Inventory.rightHand[this.game.activeMaterial];
	if (item == null || this.isCompass() || item != null && item.blockId == 0) {
		if (side == 0) {
			return this.game.textureId[this.game.d_Data.blockIdEmptyHand()][0];
		}
		return this.game.textureId[this.game.d_Data.blockIdEmptyHand()][2];
	}
	if (item.itemClass == 0) {
		return this.game.textureId[item.blockId][side];
	}
	else {
		return 0;
	}
}

ModDrawHand3d.prototype.isCompass = function() {
	var item = this.game.d_Inventory.rightHand[this.game.activeMaterial];
	return item != null && item.itemClass == 0 && item.blockId == this.game.d_Data.blockIdCompass();
}

ModDrawHand3d.prototype.isEmptyHand = function() {
	var item = this.game.d_Inventory.rightHand[this.game.activeMaterial];
	return item == null || item.blockId == 0;
}

ModDrawHand3d.prototype.isTorch = function() {
	var item = this.game.d_Inventory.rightHand[this.game.activeMaterial];
	return item != null && item.itemClass == 0 && this.game.blocktypes[item.blockId].drawType == 4;
}

ModDrawHand3d.prototype.light = function() {
	var posx = this.game.player.position.x;
	var posy = this.game.player.position.y;
	var posz = this.game.player.position.z;
	var light = this.game.getLight(this.game.platform.floatToInt(posx), this.game.platform.floatToInt(posz), this.game.platform.floatToInt(posy));
	return (this.one * light) / (15);
}

ModDrawHand3d.prototype.onNewFrameDraw3d = function(game_, deltaTime) {
	if (ModDrawHand2d.shouldDrawHand(game_)) {
		var img = ModDrawHand2d.handImage2d(game_);
		if (img == null) {
			this.game = game_;
			if (this.game.handSetAttackBuild) {
				this.setAttack(true, true);
				this.game.handSetAttackBuild = false;
			}
			if (this.game.handSetAttackDestroy) {
				this.setAttack(true, false);
				this.game.handSetAttackDestroy = false;
			}
			this.drawWeapon(deltaTime);
		}
	}
}

ModDrawHand3d.prototype.setAttack = function(isattack, build) {
	this.build = build;
	if (isattack) {
		if (this.attack == -1) {
			this.attack = 0;
		}
	}
	else {
		this.attack = -1;
	}
}

ModDrawHand3d.prototype.rot = function(t) {
	return this.game.platform.mathSin(t * 2 * this.speed) * this.range;
}

ModDrawHand3d.prototype.rot2 = function(t) {
	return this.game.platform.mathSin((t + Game.getPi()) * this.speed) * this.range;
}

ModDrawHand3d.prototype.terrainTexture = function() {
	return this.game.terrainTexture;
}

ModDrawHand3d.prototype.texturesPacked = function() {
	return this.game.texturesPacked();
}

function ModDrawLinesAroundSelectedBlock()
{
	this.lines = null;
	this.one = null;
	this.one = 1;
	this.lines = new DrawWireframeCube();
}
ModDrawLinesAroundSelectedBlock.prototype = new ClientMod();

ModDrawLinesAroundSelectedBlock.prototype.onNewFrameDraw3d = function(game, deltaTime) {
	if (game.eNABLE_DRAW2D) {
		var size = (this.one * 102) / (100);
		if (game.selectedEntityId != -1) {
			var e = game.entities[game.selectedEntityId];
			if (e != null) {
				this.lines.drawWireframeCube_(game, e.position.x, e.position.y + e.drawModel.modelHeight / (2), e.position.z, size, size * e.drawModel.modelHeight, size);
			}
		}
		else {
			if (game.selectedBlockPositionX != -1) {
				var x = game.selectedBlockPositionX;
				var y = game.selectedBlockPositionY;
				var z = game.selectedBlockPositionZ;
				var pickcubeheight = game.getblockheight(game.platform.floatToInt(x), game.platform.floatToInt(z), game.platform.floatToInt(y));
				var posx = x + this.one / (2);
				var posy = y + (pickcubeheight * this.one) / (2);
				var posz = z + this.one / (2);
				var scalex = size;
				var scaley = size * pickcubeheight;
				var scalez = size;
				this.lines.drawWireframeCube_(game, posx, posy, posz, scalex, scaley, scalez);
			}
		}
	}
}

function ModDrawMain()
{
}
ModDrawMain.prototype = new ClientMod();

ModDrawMain.prototype.onReadOnlyMainThread = function(game, dt) {
	game.mainThreadOnRenderFrame(dt);
}

function ModDrawMinecarts()
{
	this.minecarttexture = 0;
	this.minecarttexture = -1;
}
ModDrawMinecarts.prototype = new ClientMod();

ModDrawMinecarts.prototype.draw = function(game, positionX, positionY, positionZ, dir, lastdir, progress) {
	var one = 1;
	if (this.minecarttexture == -1) {
		this.minecarttexture = game.getTexture("minecart.png");
	}
	game.gLPushMatrix();
	var pX = positionX;
	var pY = positionY;
	var pZ = positionZ;
	pY += -(one * 7) / (10);
	game.gLTranslate(pX, pY, pZ);
	var currot = this.vehiclerotation(dir);
	var lastrot = this.vehiclerotation(lastdir);
	var rot = AngleInterpolation.interpolateAngle360(game.platform, lastrot, currot, progress);
	game.gLRotate(-rot - 90, 0, 1, 0);
	var cc = CuboidRenderer.cuboidNet(8, 8, 8, 0, 0);
	CuboidRenderer.cuboidNetNormalize(cc, 32, 16);
	game.platform.bindTexture2d(this.minecarttexture);
	CuboidRenderer.drawCuboid(game, -(one * 5) / (10), -(one * 3) / (10), -(one * 5) / (10), 1, 1, 1, cc, 1);
	game.gLPopMatrix();
}

ModDrawMinecarts.prototype.onNewFrameDraw3d = function(game, deltaTime) {
	for (var i = 0; i < game.entitiesCount; i++) {
		if (game.entities[i] == null) {
			continue;
		}
		if (game.entities[i].minecart == null) {
			continue;
		}
		var m = game.entities[i].minecart;
		if (!m.enabled) {
			continue;
		}
		this.draw(game, m.positionX, m.positionY, m.positionZ, m.direction, m.lastdirection, m.progress);
	}
}

ModDrawMinecarts.prototype.vehiclerotation = function(dir) {
	switch (dir) {
	case VehicleDirection12.VERTICAL_UP:
		return 0;
	case VehicleDirection12.DOWN_RIGHT_RIGHT:
	case VehicleDirection12.UP_LEFT_UP:
		return 45;
	case VehicleDirection12.HORIZONTAL_RIGHT:
		return 90;
	case VehicleDirection12.UP_RIGHT_RIGHT:
	case VehicleDirection12.DOWN_LEFT_DOWN:
		return 135;
	case VehicleDirection12.VERTICAL_DOWN:
		return 180;
	case VehicleDirection12.UP_LEFT_LEFT:
	case VehicleDirection12.DOWN_RIGHT_DOWN:
		return 225;
	case VehicleDirection12.HORIZONTAL_LEFT:
		return 270;
	case VehicleDirection12.UP_RIGHT_UP:
	case VehicleDirection12.DOWN_LEFT_LEFT:
		return 315;
	default:
		return 0;
	}
}

function ModDrawParticleEffectBlockBreak()
{
}
ModDrawParticleEffectBlockBreak.prototype = new ClientMod();

ModDrawParticleEffectBlockBreak.prototype.onNewFrameDraw3d = function(game, deltaTime) {
}

ModDrawParticleEffectBlockBreak.prototype.startParticleEffect = function(x, y, z) {
}

function ModDrawPlayerNames()
{
}
ModDrawPlayerNames.prototype = new ClientMod();

ModDrawPlayerNames.prototype.onNewFrameDraw3d = function(game, deltaTime) {
	for (var i = 0; i < game.entitiesCount; i++) {
		var e = game.entities[i];
		if (e == null) {
			continue;
		}
		if (e.drawName == null) {
			continue;
		}
		if (i == game.localPlayerId) {
			continue;
		}
		if (e.networkPosition != null && !e.networkPosition.positionLoaded) {
			continue;
		}
		var kKey = i;
		var p = game.entities[i].drawName;
		if (p.onlyWhenSelected) {
			continue;
		}
		var posX = p.textX + e.position.x;
		var posY = p.textY + e.position.y + e.drawModel.modelHeight + (game.one * 7) / (10);
		var posZ = p.textZ + e.position.z;
		if (game.dist(game.player.position.x, game.player.position.y, game.player.position.z, posX, posY, posZ) < 20 || game.keyboardState[5] || game.keyboardState[6]) {
			var name = p.name;
			{
				var shadow = (game.one * game.getLight(game.platform.floatToInt(posX), game.platform.floatToInt(posZ), game.platform.floatToInt(posY))) / (15);
				game.gLPushMatrix();
				game.gLTranslate(posX, posY, posZ);
				ModDrawSprites.billboard(game);
				var scale = (game.one * 2) / (100);
				game.gLScale(scale, scale, scale);
				if (p.drawHealth) {
					game.draw2dTexture(game.whiteTexture(), -26, -11, 52, 12, null, 0, Game.colorFromArgb(255, 0, 0, 0), false);
					game.draw2dTexture(game.whiteTexture(), -25, -10, 50 * game.one * p.health, 10, null, 0, Game.colorFromArgb(255, 255, 0, 0), false);
				}
				var font = new FontCi();
				font.size = 14;
				game.draw2dText(name, font, Math.floor(-game.textSizeWidth(name, font) / 2), 0, IntRef.create(Game.colorFromArgb(255, 255, 255, 255)), true);
				game.gLPopMatrix();
			}
		}
	}
}

function ModDrawPlayers()
{
	this.one = null;
	this.one = 1;
}
ModDrawPlayers.prototype = new ClientMod();

ModDrawPlayers.prototype.drawPlayers = function(game, dt) {
	game.totaltimeMilliseconds = game.platform.timeMillisecondsFromStart();
	for (var i = 0; i < game.entitiesCount; i++) {
		if (game.entities[i] == null) {
			continue;
		}
		if (game.entities[i].drawModel == null) {
			continue;
		}
		var p_ = game.entities[i];
		if (i == game.localPlayerId && !game.eNABLE_TPP_VIEW) {
			continue;
		}
		if (p_.networkPosition != null && !p_.networkPosition.positionLoaded) {
			continue;
		}
		if (!game.d_FrustumCulling.sphereInFrustum(p_.position.x, p_.position.y, p_.position.z, 3)) {
			continue;
		}
		if (p_.drawModel.currentTexture == -1) {
			continue;
		}
		var cx = Math.floor(game.platform.floatToInt(p_.position.x) / 16);
		var cy = Math.floor(game.platform.floatToInt(p_.position.z) / 16);
		var cz = Math.floor(game.platform.floatToInt(p_.position.y) / 16);
		if (game.map.isValidChunkPos(cx, cy, cz)) {
			if (!game.map.isChunkRendered(cx, cy, cz)) {
				continue;
			}
		}
		var shadow = (this.one * game.getLight(game.platform.floatToInt(p_.position.x), game.platform.floatToInt(p_.position.z), game.platform.floatToInt(p_.position.y))) / (15);
		if (p_.playerDrawInfo == null) {
			p_.playerDrawInfo = new PlayerDrawInfo();
		}
		p_.playerDrawInfo.anim.light = shadow;
		var FeetPosX = p_.position.x;
		var FeetPosY = p_.position.y;
		var FeetPosZ = p_.position.z;
		var animHint = game.entities[i].playerDrawInfo.animationHint_;
		var playerspeed_;
		if (i == game.localPlayerId) {
			if (game.player.playerDrawInfo == null) {
				game.player.playerDrawInfo = new PlayerDrawInfo();
			}
			var playerspeed = Vector3Ref.create(game.playervelocity.x / (60), game.playervelocity.y / (60), game.playervelocity.z / (60));
			var playerspeedf = playerspeed.length() * (this.one * 15) / (10);
			game.player.playerDrawInfo.moves = playerspeedf != 0;
			playerspeed_ = playerspeedf;
		}
		else {
			playerspeed_ = game.length(p_.playerDrawInfo.velocityX, p_.playerDrawInfo.velocityY, p_.playerDrawInfo.velocityZ) / (dt) * (this.one * 4) / (100);
		}
		if (p_.drawModel.renderer == null) {
			p_.drawModel.renderer = new AnimatedModelRenderer();
			var data = game.getFile(p_.drawModel.model_);
			var dataLength = game.getFileLength(p_.drawModel.model_);
			if (data != null) {
				var dataString = game.platform.stringFromUtf8ByteArray(data, dataLength);
				var model = AnimatedModelSerializer.deserialize(game.platform, dataString);
				p_.drawModel.renderer.start(game, model);
			}
		}
		if (p_.playerDrawInfo.moves) {
			p_.drawModel.renderer.setAnimation("walk");
		}
		else {
			p_.drawModel.renderer.setAnimation("idle");
		}
		game.gLPushMatrix();
		game.gLTranslate(FeetPosX, FeetPosY, FeetPosZ);
		game.gLRotate(PlayerInterpolate.radToDeg(-p_.position.roty + Game.getPi()), 0, 1, 0);
		game.platform.bindTexture2d(game.entities[i].drawModel.currentTexture);
		p_.drawModel.renderer.render(dt, PlayerInterpolate.radToDeg(p_.position.rotx + Game.getPi()), shadow);
		game.gLPopMatrix();
	}
}

ModDrawPlayers.prototype.onNewFrameDraw3d = function(game, deltaTime) {
	this.drawPlayers(game, deltaTime);
}

function ModDrawSprites()
{
}
ModDrawSprites.prototype = new ClientMod();

ModDrawSprites.billboard = function(game) {
	var m = game.mvMatrix.peek();
	var d = game.platform.mathSqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);
	m[0] = d;
	m[1] = 0;
	m[2] = 0;
	m[3] = 0;
	m[4] = 0;
	m[5] = d;
	m[6] = 0;
	m[7] = 0;
	m[8] = 0;
	m[9] = 0;
	m[10] = d;
	m[11] = 0;
	m[12] = m[12];
	m[13] = m[13];
	m[14] = m[14];
	m[15] = 1;
	Mat4.rotateX(m, m, Game.getPi());
	game.gLLoadMatrix(m);
}

ModDrawSprites.prototype.onNewFrameDraw3d = function(game, deltaTime) {
	var one = 1;
	for (var i = 0; i < game.entitiesCount; i++) {
		var entity = game.entities[i];
		if (entity == null) {
			continue;
		}
		if (entity.sprite == null) {
			continue;
		}
		var b = entity.sprite;
		game.gLMatrixModeModelView();
		game.gLPushMatrix();
		game.gLTranslate(b.positionX, b.positionY, b.positionZ);
		ModDrawSprites.billboard(game);
		game.gLScale((one * 2) / (100), (one * 2) / (100), (one * 2) / (100));
		game.gLTranslate(0 - Math.floor(b.size / 2), 0 - Math.floor(b.size / 2), 0);
		var n = null;
		if (b.animationcount > 0) {
			var progress = one - entity.expires.timeLeft / (entity.expires.totalTime);
			n = IntRef.create(game.platform.floatToInt(progress * (b.animationcount * b.animationcount - 1)));
		}
		game.draw2dTexture(game.getTexture(b.image), 0, 0, b.size, b.size, n, b.animationcount, Game.colorFromArgb(255, 255, 255, 255), true);
		game.gLPopMatrix();
	}
}

function ModDrawTerrain()
{
	this.calculateShadowsisTransparentForLight = null;
	this.calculateShadowslightRadius = null;
	this.chunksize = 0;
	this.chunkupdates = 0;
	this.currentChunk = null;
	this.currentChunkShadows = null;
	this.game = null;
	this.ids = null;
	this.idsCount = 0;
	this.lastPerformanceInfoupdateMilliseconds = 0;
	this.lastchunkupdates = 0;
	this.lightBase = null;
	this.lightBetweenChunks = null;
	this.redraw = null;
	this.redrawCount = 0;
	this.sqrt3half = null;
	this.started = false;
	this.tempnearestpos = null;
	this.terrainRendererStarted = false;
	this.currentChunk = new Int32Array(new ArrayBuffer(5832 << 2));
	this.currentChunkShadows = new Uint8Array(new ArrayBuffer(5832));
	this.tempnearestpos = new Int32Array(new ArrayBuffer(3 << 2));
	this.ids = new Int32Array(new ArrayBuffer(1024 << 2));
	this.idsCount = 0;
	this.redraw = new Array(128);
	this.redrawCount = 0;
	this.calculateShadowslightRadius = new Int32Array(new ArrayBuffer(1024 << 2));
	this.calculateShadowsisTransparentForLight = new Array(1024);
	this.lightBase = new LightBase();
	this.lightBetweenChunks = new LightBetweenChunks();
	this.lastPerformanceInfoupdateMilliseconds = 0;
	this.lastchunkupdates = 0;
	this.started = false;
}
ModDrawTerrain.prototype = new ClientMod();

ModDrawTerrain.blocksAround7 = function(pos) {
	var arr = new Array(7);
	arr[0] = pos;
	arr[1] = Vector3IntRef.create(pos.x + 1, pos.y + 0, pos.z + 0);
	arr[2] = Vector3IntRef.create(pos.x - 1, pos.y + 0, pos.z + 0);
	arr[3] = Vector3IntRef.create(pos.x + 0, pos.y + 1, pos.z + 0);
	arr[4] = Vector3IntRef.create(pos.x + 0, pos.y - 1, pos.z + 0);
	arr[5] = Vector3IntRef.create(pos.x + 0, pos.y + 0, pos.z + 1);
	arr[6] = Vector3IntRef.create(pos.x + 0, pos.y + 0, pos.z - 1);
	return arr;
}

ModDrawTerrain.prototype.calculateShadows = function(cx, cy, cz) {
	for (var i = 0; i < 1024; i++) {
		if (this.game.blocktypes[i] == null) {
			continue;
		}
		this.calculateShadowslightRadius[i] = this.game.blocktypes[i].lightRadius;
		this.calculateShadowsisTransparentForLight[i] = this.isTransparentForLight(i);
	}
	for (var xx = 0; xx < 3; xx++) {
		for (var yy = 0; yy < 3; yy++) {
			for (var zz = 0; zz < 3; zz++) {
				var cx1 = cx + xx - 1;
				var cy1 = cy + yy - 1;
				var cz1 = cz + zz - 1;
				if (!this.game.map.isValidChunkPos(cx1, cy1, cz1)) {
					continue;
				}
				var c = this.game.map.getChunk(cx1 * this.chunksize, cy1 * this.chunksize, cz1 * this.chunksize);
				if (c.baseLightDirty) {
					this.lightBase.calculateChunkBaseLight(this.game, cx1, cy1, cz1, this.calculateShadowslightRadius, this.calculateShadowsisTransparentForLight);
					c.baseLightDirty = false;
				}
			}
		}
	}
	var chunk = this.game.map.getChunk(cx * this.chunksize, cy * this.chunksize, cz * this.chunksize);
	if (chunk.rendered.light == null) {
		chunk.rendered.light = new Uint8Array(new ArrayBuffer(5832));
		for (var i = 0; i < 5832; i++) {
			chunk.rendered.light[i] = 15;
		}
	}
	this.lightBetweenChunks.calculateLightBetweenChunks(this.game, cx, cy, cz, this.calculateShadowslightRadius, this.calculateShadowsisTransparentForLight);
	for (var i = 0; i < 5832; i++) {
		this.currentChunkShadows[i] = chunk.rendered.light[i];
	}
}

ModDrawTerrain.prototype.chunkUpdates = function() {
	return this.chunkupdates;
}

ModDrawTerrain.prototype.clear = function() {
	this.game.d_Batcher.clear();
}

ModDrawTerrain.prototype.dispose = function(game_) {
	this.clear();
}

ModDrawTerrain.prototype.doRedraw = function(r) {
	this.idsCount = 0;
	var c = r.c;
	if (c.rendered.ids != null) {
		for (var i = 0; i < c.rendered.idsCount; i++) {
			var loadedSubmesh = c.rendered.ids[i];
			this.game.d_Batcher.remove(loadedSubmesh);
		}
	}
	for (var i = 0; i < r.dataCount; i++) {
		var submesh = r.data[i];
		if (submesh.modelData.getIndicesCount() != 0) {
			var centerVecX = submesh.positionX + Math.floor(this.chunksize / 2);
			var centerVecY = submesh.positionZ + Math.floor(this.chunksize / 2);
			var centerVecZ = submesh.positionY + Math.floor(this.chunksize / 2);
			var radius = this.sqrt3half * this.chunksize;
			this.ids[this.idsCount++] = this.game.d_Batcher.add(submesh.modelData, submesh.transparent, submesh.texture, centerVecX, centerVecY, centerVecZ, radius);
		}
	}
	var idsarr = new Int32Array(new ArrayBuffer(this.idsCount << 2));
	for (var i = 0; i < this.idsCount; i++) {
		idsarr[i] = this.ids[i];
	}
	c.rendered.ids = idsarr;
	c.rendered.idsCount = this.idsCount;
}

ModDrawTerrain.prototype.drawTerrain = function() {
	this.game.d_Batcher.draw(this.game.player.position.x, this.game.player.position.y, this.game.player.position.z);
}

ModDrawTerrain.prototype.getExtendedChunk = function(x, y, z) {
	this.game.map.getMapPortion(this.currentChunk, x * this.chunksize - 1, y * this.chunksize - 1, z * this.chunksize - 1, this.chunksize + 2, this.chunksize + 2, this.chunksize + 2);
}

ModDrawTerrain.prototype.isSolidChunk = function(currentChunk, length) {
	var block = currentChunk[0];
	for (var i = 0; i < length; i++) {
		if (currentChunk[i] != currentChunk[0]) {
			return false;
		}
	}
	return true;
}

ModDrawTerrain.prototype.isTransparentForLight = function(block) {
	var b = this.game.blocktypes[block];
	return b.drawType != 1 && b.drawType != 8;
}

ModDrawTerrain.prototype.mainThreadCommit = function() {
	for (var i = 0; i < this.redrawCount; i++) {
		this.doRedraw(this.redraw[i]);
		this.redraw[i] = null;
	}
	this.redrawCount = 0;
}

ModDrawTerrain.prototype.modelDataClone = function(source) {
	var dest = new ModelData();
	dest.xyz = new Float32Array(new ArrayBuffer(source.getXyzCount() << 2));
	for (var i = 0; i < source.getXyzCount(); i++) {
		dest.xyz[i] = source.xyz[i];
	}
	dest.uv = new Float32Array(new ArrayBuffer(source.getUvCount() << 2));
	for (var i = 0; i < source.getUvCount(); i++) {
		dest.uv[i] = source.uv[i];
	}
	dest.rgba = new Uint8Array(new ArrayBuffer(source.getRgbaCount()));
	for (var i = 0; i < source.getRgbaCount(); i++) {
		dest.rgba[i] = source.rgba[i];
	}
	dest.indices = new Int32Array(new ArrayBuffer(source.getIndicesCount() << 2));
	for (var i = 0; i < source.getIndicesCount(); i++) {
		dest.indices[i] = source.indices[i];
	}
	dest.setVerticesCount(source.getVerticesCount());
	dest.setIndicesCount(source.getIndicesCount());
	return dest;
}

ModDrawTerrain.prototype.nearestDirty = function(nearestpos) {
	var nearestdist = 2147483647;
	nearestpos[0] = -1;
	nearestpos[1] = -1;
	nearestpos[2] = -1;
	var px = Math.floor(this.game.platform.floatToInt(this.game.player.position.x) / this.chunksize);
	var py = Math.floor(this.game.platform.floatToInt(this.game.player.position.z) / this.chunksize);
	var pz = Math.floor(this.game.platform.floatToInt(this.game.player.position.y) / this.chunksize);
	var chunksxy = Math.floor(Math.floor(this.mapAreaSize() / this.chunksize) / 2);
	var chunksz = Math.floor(Math.floor(this.mapAreaSizeZ() / this.chunksize) / 2);
	var startx = px - chunksxy;
	var endx = px + chunksxy;
	var starty = py - chunksxy;
	var endy = py + chunksxy;
	var startz = pz - chunksz;
	var endz = pz + chunksz;
	if (startx < 0) {
		startx = 0;
	}
	if (starty < 0) {
		starty = 0;
	}
	if (startz < 0) {
		startz = 0;
	}
	if (endx >= this.mapsizexchunks()) {
		endx = this.mapsizexchunks() - 1;
	}
	if (endy >= this.mapsizeychunks()) {
		endy = this.mapsizeychunks() - 1;
	}
	if (endz >= this.mapsizezchunks()) {
		endz = this.mapsizezchunks() - 1;
	}
	var mapsizexchunks_ = this.mapsizexchunks();
	var mapsizeychunks_ = this.mapsizeychunks();
	for (var x = startx; x <= endx; x++) {
		for (var y = starty; y <= endy; y++) {
			for (var z = startz; z <= endz; z++) {
				var c = this.game.map.chunks[(z * mapsizeychunks_ + y) * mapsizexchunks_ + x];
				if (c == null || c.rendered == null) {
					continue;
				}
				if (c.rendered.dirty) {
					var dx = px - x;
					var dy = py - y;
					var dz = pz - z;
					var dist = dx * dx + dy * dy + dz * dz;
					if (dist < nearestdist) {
						nearestdist = dist;
						nearestpos[0] = x;
						nearestpos[1] = y;
						nearestpos[2] = z;
					}
				}
			}
		}
	}
}

ModDrawTerrain.prototype.onNewFrameDraw3d = function(game_, deltaTime) {
	this.game = game_;
	if (!this.started) {
		this.started = true;
	}
	if (this.game.shouldRedrawAllBlocks) {
		this.game.shouldRedrawAllBlocks = false;
		this.redrawAllBlocks();
	}
	this.drawTerrain();
	this.updatePerformanceInfo(deltaTime);
}

ModDrawTerrain.prototype.onReadOnlyBackgroundThread = function(game_, dt) {
	this.game = game_;
	this.updateTerrain();
	game_.queueActionCommit(TerrainRendererCommit.create(this));
}

ModDrawTerrain.prototype.redrawAllBlocks = function() {
	if (!this.terrainRendererStarted) {
		this.startTerrain();
	}
	var chunksLength = Math.floor(this.game.map.mapSizeX / this.chunksize) * Math.floor(this.game.map.mapSizeY / this.chunksize) * Math.floor(this.game.map.mapSizeZ / this.chunksize);
	for (var i = 0; i < chunksLength; i++) {
		var c = this.game.map.chunks[i];
		if (c == null) {
			continue;
		}
		if (c.rendered == null) {
			c.rendered = new RenderedChunk();
		}
		c.rendered.dirty = true;
		c.baseLightDirty = true;
	}
}

ModDrawTerrain.prototype.redrawChunk = function(x, y, z) {
	var c = this.game.map.chunks[MapUtilCi.index3d(x, y, z, this.mapsizexchunks(), this.mapsizeychunks())];
	if (c == null) {
		return;
	}
	if (c.rendered == null) {
		c.rendered = new RenderedChunk();
	}
	c.rendered.dirty = false;
	this.chunkupdates++;
	this.getExtendedChunk(x, y, z);
	var r = new TerrainRendererRedraw();
	r.c = c;
	var a = null;
	var retCount = new IntRef();
	if (!this.isSolidChunk(this.currentChunk, (this.chunksize + 2) * (this.chunksize + 2) * (this.chunksize + 2))) {
		this.calculateShadows(x, y, z);
		a = this.game.d_TerrainChunkTesselator.makeChunk(x, y, z, this.currentChunk, this.currentChunkShadows, this.game.mLightLevels, retCount);
	}
	r.data = new Array(retCount.value);
	for (var i = 0; i < retCount.value; i++) {
		r.data[i] = this.verticesIndicesToLoadClone(a[i]);
	}
	r.dataCount = retCount.value;
	this.redraw[this.redrawCount++] = r;
}

ModDrawTerrain.prototype.startTerrain = function() {
	this.sqrt3half = this.game.platform.mathSqrt(3) / (2);
	this.game.d_TerrainChunkTesselator.start();
	this.terrainRendererStarted = true;
	this.chunksize = 16;
}

ModDrawTerrain.prototype.trianglesCount = function() {
	return this.game.d_Batcher.totalTriangleCount();
}

ModDrawTerrain.prototype.updatePerformanceInfo = function(dt) {
	var elapsed = (1 * (this.game.platform.timeMillisecondsFromStart() - this.lastPerformanceInfoupdateMilliseconds)) / (1000);
	var triangles = this.trianglesCount();
	if (elapsed >= 1) {
		this.lastPerformanceInfoupdateMilliseconds = this.game.platform.timeMillisecondsFromStart();
		var chunkupdates_ = this.chunkUpdates();
		this.game.performanceinfo.set("Chunk updates", this.game.platform.intToString(chunkupdates_ - this.lastchunkupdates));
		this.lastchunkupdates = this.chunkUpdates();
		this.game.performanceinfo.set("Triangles", this.game.platform.intToString(triangles));
	}
}

ModDrawTerrain.prototype.updateTerrain = function() {
	if (!this.terrainRendererStarted) {
		return;
	}
	if (!(this.game.lastplacedblockX == -1 && this.game.lastplacedblockY == -1 && this.game.lastplacedblockZ == -1)) {
		var ChunksToRedraw = new HashSetVector3IntRef();
		var around = ModDrawTerrain.blocksAround7(Vector3IntRef.create(this.game.lastplacedblockX, this.game.lastplacedblockY, this.game.lastplacedblockZ));
		for (var i = 0; i < 7; i++) {
			var a = around[i];
			ChunksToRedraw.set(Vector3IntRef.create(Math.floor(a.x / this.chunksize), Math.floor(a.y / this.chunksize), Math.floor(a.z / this.chunksize)));
		}
		for (var i = 0; i < ChunksToRedraw.max; i++) {
			if (ChunksToRedraw.values[i] == null) {
				break;
			}
			var c = new Int32Array(new ArrayBuffer(3 << 2));
			var xx = ChunksToRedraw.values[i].x;
			var yy = ChunksToRedraw.values[i].y;
			var zz = ChunksToRedraw.values[i].z;
			if (xx >= 0 && yy >= 0 && zz >= 0 && xx < Math.floor(this.game.map.mapSizeX / this.chunksize) && yy < Math.floor(this.game.map.mapSizeY / this.chunksize) && zz < Math.floor(this.game.map.mapSizeZ / this.chunksize)) {
				var chunk = this.game.map.chunks[(zz * this.mapsizeychunks() + yy) * this.mapsizexchunks() + xx];
				if (chunk == null || chunk.rendered == null) {
					continue;
				}
				if (chunk.rendered.dirty) {
					this.redrawChunk(xx, yy, zz);
				}
			}
		}
		this.game.lastplacedblockX = -1;
		this.game.lastplacedblockY = -1;
		this.game.lastplacedblockZ = -1;
	}
	var updated = 0;
	for (;;) {
		this.nearestDirty(this.tempnearestpos);
		if (this.tempnearestpos[0] == -1 && this.tempnearestpos[1] == -1 && this.tempnearestpos[2] == -1) {
			break;
		}
		this.redrawChunk(this.tempnearestpos[0], this.tempnearestpos[1], this.tempnearestpos[2]);
		{
			break;
		}
	}
}

ModDrawTerrain.prototype.verticesIndicesToLoadClone = function(source) {
	var dest = new VerticesIndicesToLoad();
	dest.modelData = this.modelDataClone(source.modelData);
	dest.positionX = source.positionX;
	dest.positionY = source.positionY;
	dest.positionZ = source.positionZ;
	dest.texture = source.texture;
	dest.transparent = source.transparent;
	return dest;
}

ModDrawTerrain.prototype.centerAreaSize = function() {
	return Math.floor(this.game.platform.floatToInt(this.game.d_Config3d.viewdistance) / 2);
}

ModDrawTerrain.prototype.mapAreaSize = function() {
	return this.game.platform.floatToInt(this.game.d_Config3d.viewdistance) * 2;
}

ModDrawTerrain.prototype.mapAreaSizeZ = function() {
	return this.mapAreaSize();
}

ModDrawTerrain.prototype.mapsizexchunks = function() {
	return this.game.map.mapsizexchunks();
}

ModDrawTerrain.prototype.mapsizeychunks = function() {
	return this.game.map.mapsizeychunks();
}

ModDrawTerrain.prototype.mapsizezchunks = function() {
	return this.game.map.mapsizezchunks();
}

ModDrawTerrain.prototype.maxlight = function() {
	return 15;
}

function ModDrawTestModel()
{
	this.testmodel = null;
}
ModDrawTestModel.prototype = new ClientMod();

ModDrawTestModel.prototype.drawTestModel = function(game, deltaTime) {
	if (!game.eNABLE_DRAW_TEST_CHARACTER) {
		return;
	}
	if (this.testmodel == null) {
		this.testmodel = new AnimatedModelRenderer();
		var data = game.getFile("player.txt");
		var dataLength = game.getFileLength("player.txt");
		var dataString = game.platform.stringFromUtf8ByteArray(data, dataLength);
		var model = AnimatedModelSerializer.deserialize(game.platform, dataString);
		this.testmodel.start(game, model);
	}
	game.gLPushMatrix();
	game.gLTranslate(Math.floor(game.map.mapSizeX / 2), game.blockheight(Math.floor(game.map.mapSizeX / 2), Math.floor(game.map.mapSizeY / 2) - 2, 128), Math.floor(game.map.mapSizeY / 2) - 2);
	game.platform.bindTexture2d(game.getTexture("mineplayer.png"));
	this.testmodel.render(deltaTime, 0, 1);
	game.gLPopMatrix();
}

ModDrawTestModel.prototype.onClientCommand = function(game, args) {
	if (args.command == "testmodel") {
		game.eNABLE_DRAW_TEST_CHARACTER = game.boolCommandArgument(args.arguments);
		return true;
	}
	return false;
}

ModDrawTestModel.prototype.onNewFrameDraw3d = function(game, deltaTime) {
	if (game.guistate == GuiState.MAP_LOADING) {
		return;
	}
	this.drawTestModel(game, deltaTime);
}

function ModDrawText()
{
}
ModDrawText.prototype = new ClientMod();

ModDrawText.prototype.onNewFrameDraw3d = function(game, deltaTime) {
	for (var i = 0; i < game.entitiesCount; i++) {
		var e = game.entities[i];
		if (e == null) {
			continue;
		}
		if (e.drawText == null) {
			continue;
		}
		if (e.networkPosition != null && !e.networkPosition.positionLoaded) {
			continue;
		}
		var kKey = i;
		var p = game.entities[i].drawText;
		var posX = -game.platform.mathSin(e.position.roty) * p.dx + e.position.x;
		var posY = p.dy + e.position.y;
		var posZ = game.platform.mathCos(e.position.roty) * p.dz + e.position.z;
		if (game.dist(game.player.position.x, game.player.position.y, game.player.position.z, posX, posY, posZ) < 20 || game.keyboardState[5] || game.keyboardState[6]) {
			var text = p.text;
			{
				var shadow = (game.one * game.getLight(game.platform.floatToInt(posX), game.platform.floatToInt(posZ), game.platform.floatToInt(posY))) / (15);
				game.gLPushMatrix();
				game.gLTranslate(posX, posY, posZ);
				game.gLRotate(180, 1, 0, 0);
				game.gLRotate((e.position.roty * 360) / (2 * Game.getPi()), 0, 1, 0);
				var scale = (game.one * 5) / (1000);
				game.gLScale(scale, scale, scale);
				var font = new FontCi();
				font.size = 14;
				game.draw2dText(text, font, Math.floor(-game.textSizeWidth(text, font) / 2), 0, IntRef.create(Game.colorFromArgb(255, 255, 255, 255)), true);
				game.gLPopMatrix();
			}
		}
	}
}

function ModExpire()
{
}
ModExpire.prototype = new ClientMod();

ModExpire.prototype.grenadeExplosion = function(game, grenadeEntityId) {
	var LocalPlayerPositionX = game.player.position.x;
	var LocalPlayerPositionY = game.player.position.y;
	var LocalPlayerPositionZ = game.player.position.z;
	var grenadeEntity = game.entities[grenadeEntityId];
	var grenadeSprite = grenadeEntity.sprite;
	var grenade = grenadeEntity.grenade;
	game.audioPlayAt("grenadeexplosion.ogg", grenadeSprite.positionX, grenadeSprite.positionY, grenadeSprite.positionZ);
	{
		var entity = new Entity();
		var spritenew = new Sprite();
		spritenew.image = "ani5.png";
		spritenew.positionX = grenadeSprite.positionX;
		spritenew.positionY = grenadeSprite.positionY + 1;
		spritenew.positionZ = grenadeSprite.positionZ;
		spritenew.size = 200;
		spritenew.animationcount = 4;
		entity.sprite = spritenew;
		entity.expires = Expires.create(1);
		game.entityAddLocal(entity);
	}
	{
		var explosion = new Packet_ServerExplosion();
		explosion.xFloat = game.serializeFloat(grenadeSprite.positionX);
		explosion.yFloat = game.serializeFloat(grenadeSprite.positionZ);
		explosion.zFloat = game.serializeFloat(grenadeSprite.positionY);
		explosion.rangeFloat = game.blocktypes[grenade.block].explosionRangeFloat;
		explosion.isRelativeToPlayerPosition = 0;
		explosion.timeFloat = game.blocktypes[grenade.block].explosionTimeFloat;
		var entity = new Entity();
		entity.push = explosion;
		entity.expires = new Expires();
		entity.expires.timeLeft = game.deserializeFloat(game.blocktypes[grenade.block].explosionTimeFloat);
		game.entityAddLocal(entity);
	}
	var dist = game.dist(LocalPlayerPositionX, LocalPlayerPositionY, LocalPlayerPositionZ, grenadeSprite.positionX, grenadeSprite.positionY, grenadeSprite.positionZ);
	var dmg = (1 - dist / (game.deserializeFloat(game.blocktypes[grenade.block].explosionRangeFloat))) * game.deserializeFloat(game.blocktypes[grenade.block].damageBodyFloat);
	if (dmg > 0) {
		game.applyDamageToPlayer(game.platform.floatToInt(dmg), 3, grenade.sourcePlayer);
	}
}

ModExpire.prototype.onNewFrameFixed = function(game, args) {
	for (var i = 0; i < game.entitiesCount; i++) {
		var entity = game.entities[i];
		if (entity == null) {
			continue;
		}
		if (entity.expires == null) {
			continue;
		}
		entity.expires.timeLeft -= args.getDt();
		if (entity.expires.timeLeft <= 0) {
			if (entity.grenade != null) {
				this.grenadeExplosion(game, i);
			}
			game.entities[i] = null;
		}
	}
}

function ModFallDamageToPlayer()
{
	this.fallSoundPlaying = false;
	this.lastfalldamagetimeMilliseconds = 0;
	this.one = null;
	this.one = 1;
	this.fallSoundPlaying = false;
}
ModFallDamageToPlayer.prototype = new ClientMod();

ModFallDamageToPlayer.prototype.onNewFrameFixed = function(game, args) {
	if (game.guistate == GuiState.MAP_LOADING) {
		return;
	}
	if (game.controls.getFreemove() != 0) {
		if (this.fallSoundPlaying) {
			this.setFallSoundActive(game, false);
		}
		return;
	}
	if (game.followId() == null) {
		this.updateFallDamageToPlayer(game, args.getDt());
	}
}

ModFallDamageToPlayer.prototype.setFallSoundActive = function(game, active) {
	game.audioPlayLoop("fallloop.wav", active, true);
	this.fallSoundPlaying = active;
}

ModFallDamageToPlayer.prototype.updateFallDamageToPlayer = function(game, dt) {
	var movedz = game.movedz;
	var fallspeed = movedz / (-game.basemovespeed);
	var posX = game.getPlayerEyesBlockX();
	var posY = game.getPlayerEyesBlockY();
	var posZ = game.getPlayerEyesBlockZ();
	if (game.blockheight(posX, posY, posZ) < posZ - 8 || fallspeed > 3) {
		this.setFallSoundActive(game, fallspeed > 2);
	}
	else {
		this.setFallSoundActive(game, false);
	}
	if (game.map.isValidPos(posX, posY, posZ - 3)) {
		var blockBelow = game.map.getBlock(posX, posY, posZ - 3);
		if (blockBelow != 0 && !game.isWater(blockBelow)) {
			var severity = 0;
			if (fallspeed < 4) {
				return;
			}
			else if (fallspeed < (this.one * 45) / (10)) {
				severity = (this.one * 3) / (10);
			}
			else if (fallspeed < 5) {
				severity = (this.one * 5) / (10);
			}
			else if (fallspeed < (this.one * 55) / (10)) {
				severity = (this.one * 6) / (10);
			}
			else if (fallspeed < 6) {
				severity = (this.one * 8) / (10);
			}
			else {
				severity = 1;
			}
			if ((this.one * (game.platform.timeMillisecondsFromStart() - this.lastfalldamagetimeMilliseconds)) / (1000) < 1) {
				return;
			}
			this.lastfalldamagetimeMilliseconds = game.platform.timeMillisecondsFromStart();
			game.applyDamageToPlayer(game.platform.floatToInt(severity * game.playerStats.maxHealth), 0, 0);
		}
	}
}

function ModFpsHistoryGraph()
{
	this.dRAW_FPS_GRAPH = false;
	this.dRAW_FPS_TEXT = false;
	this.dRAW_POSITION = false;
	this.eNABLE_STATS = false;
	this.positionLines = null;
	this.statsLineCount = 0;
	this.statsLines = null;
	this.chunkUpdateHistory = null;
	this.displayFont = null;
	this.displayFontHeadings = null;
	this.dtHistory = null;
	this.fpscount = 0;
	this.lasttitleupdateMilliseconds = 0;
	this.longestframedt = null;
	this.m = null;
	this.one = null;
	this.pingHistory = null;
	this.todraw = null;
	this.one = 1;
	this.eNABLE_STATS = false;
	this.dRAW_FPS_TEXT = false;
	this.dRAW_FPS_GRAPH = false;
	this.dRAW_POSITION = false;
	this.dtHistory = new Float32Array(new ArrayBuffer(300 << 2));
	for (var i = 0; i < 300; i++) {
		this.dtHistory[i] = 0;
	}
	this.chunkUpdateHistory = new Float32Array(new ArrayBuffer(300 << 2));
	for (var i = 0; i < 300; i++) {
		this.chunkUpdateHistory[i] = 0;
	}
	this.pingHistory = new Float32Array(new ArrayBuffer(300 << 2));
	for (var i = 0; i < 300; i++) {
		this.pingHistory[i] = 0;
	}
	this.todraw = new Array(300);
	for (var i = 0; i < 300; i++) {
		this.todraw[i] = new Draw2dData();
	}
	this.statsLines = new Array(8);
	this.displayFont = new FontCi();
	this.displayFont.size = 10;
	this.displayFontHeadings = new FontCi();
	this.displayFontHeadings.size = 10;
	this.displayFontHeadings.style = 1;
	this.positionLines = new Array(5);
}
ModFpsHistoryGraph.prototype = new ClientMod();

ModFpsHistoryGraph.prototype.draw = function() {
	if (this.eNABLE_STATS) {
		this.m.orthoMode();
		if (this.dRAW_FPS_GRAPH || this.dRAW_FPS_TEXT) {
			if (this.dRAW_FPS_GRAPH) {
				this.drawFpsGraph(this.m.getWindowWidth() - 300 - 20, 20);
			}
			if (this.dRAW_FPS_TEXT) {
				for (var i = 0; i < this.statsLineCount; i++) {
					this.m.draw2dText(this.statsLines[i], 20 + 200 * Math.floor(i / 4), 20 + 1.5 * i % 4 * this.displayFont.size, this.displayFont);
				}
			}
		}
		this.drawChunkGraph(this.m.getWindowWidth() - 300 - 20, 120);
		this.drawPingGraph(this.m.getWindowWidth() - 300 - 20, 220);
		this.m.perspectiveMode();
	}
}

ModFpsHistoryGraph.prototype.drawChunkGraph = function(posx, posy) {
	var color_graph = Game.colorFromArgb(128, 20, 20, 220);
	var color_outofrange = Game.colorFromArgb(128, 60, 60, 220);
	var color_lines = Game.colorFromArgb(255, 255, 255, 255);
	posy += 80;
	this.drawGraph(posx, posy, 300, 80, this.chunkUpdateHistory, color_graph, color_outofrange);
	this.m.draw2dTexture(this.m.whiteTexture(), posx, posy - 60, 300, 1, null, color_lines);
	this.m.draw2dTexture(this.m.whiteTexture(), posx, posy - 30, 300, 1, null, color_lines);
	this.m.draw2dText("60", posx, posy - 60, this.displayFont);
	this.m.draw2dText("30", posx, posy - 30, this.displayFont);
	this.m.draw2dText("Chunk updates", posx, posy - 80, this.displayFontHeadings);
}

ModFpsHistoryGraph.prototype.drawFpsGraph = function(posx, posy) {
	var color_graph = Game.colorFromArgb(128, 220, 20, 20);
	var color_outofrange = Game.colorFromArgb(128, 255, 255, 0);
	var color_lines = Game.colorFromArgb(255, 255, 255, 255);
	posy += 80;
	this.drawGraph(posx, posy, 300, 80, this.dtHistory, color_graph, color_outofrange);
	this.m.draw2dTexture(this.m.whiteTexture(), posx, posy - 30, 300, 1, null, color_lines);
	this.m.draw2dTexture(this.m.whiteTexture(), posx, posy - 30 * (this.one * 60) / (30), 300, 1, null, color_lines);
	this.m.draw2dText("60", posx, posy - 30 * (this.one * 60) / (60), this.displayFont);
	this.m.draw2dText("30", posx, posy - 30 * (this.one * 60) / (30), this.displayFont);
	this.m.draw2dText("FPS", posx, posy - 80, this.displayFontHeadings);
}

ModFpsHistoryGraph.prototype.drawGraph = function(posX, posY, sizeX, sizeY, data, color_graph, color_outlier) {
	var color_background = Game.colorFromArgb(80, 0, 0, 0);
	this.m.draw2dTexture(this.m.whiteTexture(), posX - 4, posY + 4, sizeX + 8, -sizeY - 8, null, color_background);
	for (var i = 0; i < sizeX; i++) {
		this.todraw[i].x1 = posX + i;
		this.todraw[i].y1 = posY - data[i];
		this.todraw[i].width = 1;
		this.todraw[i].height = data[i];
		this.todraw[i].inAtlasId = null;
		this.todraw[i].color = color_graph;
		if (data[i] > sizeY) {
			this.todraw[i].y1 = posY - sizeY;
			this.todraw[i].height = sizeY;
			this.todraw[i].color = color_outlier;
		}
	}
	this.m.draw2dTextures(this.todraw, sizeX, this.m.whiteTexture());
}

ModFpsHistoryGraph.prototype.drawLocalPosition = function(game) {
	if (this.dRAW_POSITION) {
		var p = this.m.getPlatform();
		var heading = (this.m.getLocalOrientationY() % (2 * Game.getPi())) / (2 * Game.getPi()) * 256;
		var pitch = ((this.m.getLocalOrientationX() + Game.getPi()) % (2 * Game.getPi())) / (2 * Game.getPi()) * 256;
		this.positionLines[0] = p.stringFormat("X: {0}", p.intToString(game.mathFloor(this.m.getLocalPositionX())));
		this.positionLines[1] = p.stringFormat("Y: {0}", p.intToString(game.mathFloor(this.m.getLocalPositionZ())));
		this.positionLines[2] = p.stringFormat("Z: {0}", p.intToString(game.mathFloor(this.m.getLocalPositionY())));
		this.positionLines[3] = p.stringFormat("Heading: {0}", p.intToString(Game.intToByte(p.floatToInt(heading))));
		this.positionLines[4] = p.stringFormat("Pitch: {0}", p.intToString(Game.intToByte(p.floatToInt(pitch))));
		this.m.orthoMode();
		for (var i = 0; i < 5; i++) {
			this.m.draw2dText(this.positionLines[i], 20, this.m.getWindowHeight() - 100 + 1.5 * i * this.displayFont.size, this.displayFont);
		}
		this.m.perspectiveMode();
	}
}

ModFpsHistoryGraph.prototype.drawPingGraph = function(posx, posy) {
	var color_graph = Game.colorFromArgb(128, 20, 220, 20);
	var color_outofrange = Game.colorFromArgb(128, 120, 220, 20);
	var color_lines = Game.colorFromArgb(255, 255, 255, 255);
	posy += 80;
	this.drawGraph(posx, posy, 300, 80, this.pingHistory, color_graph, color_outofrange);
	this.m.draw2dTexture(this.m.whiteTexture(), posx, posy - 40, 300, 1, null, color_lines);
	this.m.draw2dTexture(this.m.whiteTexture(), posx, posy - 20, 300, 1, null, color_lines);
	this.m.draw2dText("40 ms", posx, posy - 40, this.displayFont);
	this.m.draw2dText("20 ms", posx, posy - 20, this.displayFont);
	this.m.draw2dText("Server Ping", posx, posy - 80, this.displayFontHeadings);
}

ModFpsHistoryGraph.prototype.onClientCommand = function(game, args) {
	if (args.command == "fps") {
		var argumentsLength = new IntRef();
		var arguments = this.m.getPlatform().stringSplit(args.arguments, " ", argumentsLength);
		if (this.m.getPlatform().stringTrim(args.arguments) == "") {
			this.dRAW_FPS_TEXT = true;
		}
		else if (arguments[0] == "1") {
			this.dRAW_FPS_TEXT = true;
			this.dRAW_FPS_GRAPH = false;
		}
		else if (arguments[0] == "2") {
			this.dRAW_FPS_TEXT = true;
			this.dRAW_FPS_GRAPH = true;
		}
		else {
			this.dRAW_FPS_TEXT = false;
			this.dRAW_FPS_GRAPH = false;
		}
		return true;
	}
	else if (args.command == "pos") {
		this.dRAW_POSITION = game.boolCommandArgument(args.arguments);
		return true;
	}
	return false;
}

ModFpsHistoryGraph.prototype.onKeyDown = function(game, args) {
	if (args.getKeyCode() == 16) {
		if (!this.eNABLE_STATS) {
			this.eNABLE_STATS = true;
			this.dRAW_FPS_TEXT = true;
			this.dRAW_FPS_GRAPH = true;
			this.dRAW_POSITION = true;
		}
		else {
			this.eNABLE_STATS = false;
			this.dRAW_FPS_TEXT = false;
			this.dRAW_FPS_GRAPH = false;
			this.dRAW_POSITION = false;
		}
	}
}

ModFpsHistoryGraph.prototype.onNewFrame = function(game, args) {
	var dt = args.getDt();
	this.updateFpsHistory(dt);
	this.updateStatisticsText(dt);
	this.drawLocalPosition(game);
	this.draw();
}

ModFpsHistoryGraph.prototype.start = function(modmanager) {
	this.m = modmanager;
}

ModFpsHistoryGraph.prototype.updateChunkHistory = function(updates) {
	for (var i = 0; i < 299; i++) {
		this.chunkUpdateHistory[i] = this.chunkUpdateHistory[i + 1];
	}
	this.chunkUpdateHistory[299] = updates;
}

ModFpsHistoryGraph.prototype.updateFpsHistory = function(dt) {
	for (var i = 0; i < 299; i++) {
		this.dtHistory[i] = this.dtHistory[i + 1];
	}
	this.dtHistory[299] = dt * 60 * 30;
}

ModFpsHistoryGraph.prototype.updatePingHistory = function(ping) {
	for (var i = 0; i < 299; i++) {
		this.pingHistory[i] = this.pingHistory[i + 1];
	}
	this.pingHistory[299] = ping;
}

ModFpsHistoryGraph.prototype.updateStatisticsText = function(dt) {
	var p = this.m.getPlatform();
	this.fpscount++;
	this.longestframedt = MathCi.maxFloat(this.longestframedt, dt);
	var elapsed = (this.one * (p.timeMillisecondsFromStart() - this.lasttitleupdateMilliseconds)) / (1000);
	if (elapsed >= 1) {
		this.lasttitleupdateMilliseconds = p.timeMillisecondsFromStart();
		var fpstext1 = p.intToString(p.floatToInt((this.one * this.fpscount) / (elapsed)));
		fpstext1 = StringTools.stringAppend(p, fpstext1, p.stringFormat(" (min: {0})", p.intToString(p.floatToInt(this.one / (this.longestframedt)))));
		this.longestframedt = 0;
		this.fpscount = 0;
		this.m.getPerformanceInfo().set("FPS", fpstext1);
		this.statsLineCount = 0;
		for (var i = 0; i < this.m.getPerformanceInfo().size; i++) {
			if (this.m.getPerformanceInfo().items[i] == null) {
				continue;
			}
			if (this.m.getPerformanceInfo().items[i].key == "Chunk updates") {
				this.updateChunkHistory(p.intParse(this.m.getPerformanceInfo().items[i].value));
			}
			if (this.m.getPerformanceInfo().items[i].key == "Ping") {
				this.updatePingHistory(p.intParse(this.m.getPerformanceInfo().items[i].value));
			}
			if (this.statsLineCount >= 8) {
				break;
			}
			this.statsLines[this.statsLineCount++] = p.stringFormat2("{0}: {1}", this.m.getPerformanceInfo().items[i].key, this.m.getPerformanceInfo().items[i].value);
		}
	}
}

function ModGrenade()
{
	this.bouncespeedmultiply = null;
	this.one = null;
	this.projectilegravity = null;
	this.walldistance = null;
	this.one = 1;
	this.projectilegravity = 20;
	this.bouncespeedmultiply = (this.one * 5) / (10);
	this.walldistance = (this.one * 3) / (10);
}
ModGrenade.prototype = new ClientMod();

ModGrenade.prototype.grenadeBounce = function(game, oldposition, newposition, velocity, dt) {
	var ismoving = velocity.length() > 100 * dt;
	var modelheight = this.walldistance;
	oldposition.y += this.walldistance;
	newposition.y += this.walldistance;
	var oldpositioni = Vector3IntRef.create(game.mathFloor(oldposition.x), game.mathFloor(oldposition.z), game.mathFloor(oldposition.y));
	var playerpositionX = newposition.x;
	var playerpositionY = newposition.y;
	var playerpositionZ = newposition.z;
	{
		var qnewpositionX = newposition.x;
		var qnewpositionY = newposition.y;
		var qnewpositionZ = newposition.z + this.walldistance;
		var newempty = game.isTileEmptyForPhysics(game.mathFloor(qnewpositionX), game.mathFloor(qnewpositionZ), game.mathFloor(qnewpositionY)) && game.isTileEmptyForPhysics(game.mathFloor(qnewpositionX), game.mathFloor(qnewpositionZ), game.mathFloor(qnewpositionY) + 1);
		if (newposition.z - oldposition.z > 0) {
			if (!newempty) {
				velocity.z = -velocity.z;
				velocity.x *= this.bouncespeedmultiply;
				velocity.y *= this.bouncespeedmultiply;
				velocity.z *= this.bouncespeedmultiply;
				if (ismoving) {
					game.audioPlayAt("grenadebounce.ogg", newposition.x, newposition.y, newposition.z);
				}
			}
		}
	}
	{
		var qnewpositionX = newposition.x + this.walldistance;
		var qnewpositionY = newposition.y;
		var qnewpositionZ = newposition.z;
		var newempty = game.isTileEmptyForPhysics(game.mathFloor(qnewpositionX), game.mathFloor(qnewpositionZ), game.mathFloor(qnewpositionY)) && game.isTileEmptyForPhysics(game.mathFloor(qnewpositionX), game.mathFloor(qnewpositionZ), game.mathFloor(qnewpositionY) + 1);
		if (newposition.x - oldposition.x > 0) {
			if (!newempty) {
				velocity.x = -velocity.x;
				velocity.x *= this.bouncespeedmultiply;
				velocity.y *= this.bouncespeedmultiply;
				velocity.z *= this.bouncespeedmultiply;
				if (ismoving) {
					game.audioPlayAt("grenadebounce.ogg", newposition.x, newposition.y, newposition.z);
				}
			}
		}
	}
	{
		var qnewpositionX = newposition.x;
		var qnewpositionY = newposition.y - this.walldistance;
		var qnewpositionZ = newposition.z;
		var x = game.mathFloor(qnewpositionX);
		var y = game.mathFloor(qnewpositionZ);
		var z = game.mathFloor(qnewpositionY);
		var a_ = this.walldistance;
		var newfull = !game.isTileEmptyForPhysics(x, y, z) || qnewpositionX - game.mathFloor(qnewpositionX) <= a_ && !game.isTileEmptyForPhysics(x - 1, y, z) && game.isTileEmptyForPhysics(x - 1, y, z + 1) || qnewpositionX - game.mathFloor(qnewpositionX) >= 1 - a_ && !game.isTileEmptyForPhysics(x + 1, y, z) && game.isTileEmptyForPhysics(x + 1, y, z + 1) || qnewpositionZ - game.mathFloor(qnewpositionZ) <= a_ && !game.isTileEmptyForPhysics(x, y - 1, z) && game.isTileEmptyForPhysics(x, y - 1, z + 1) || qnewpositionZ - game.mathFloor(qnewpositionZ) >= 1 - a_ && !game.isTileEmptyForPhysics(x, y + 1, z) && game.isTileEmptyForPhysics(x, y + 1, z + 1);
		if (newposition.y - oldposition.y < 0) {
			if (newfull) {
				velocity.y = -velocity.y;
				velocity.x *= this.bouncespeedmultiply;
				velocity.y *= this.bouncespeedmultiply;
				velocity.z *= this.bouncespeedmultiply;
				if (ismoving) {
					game.audioPlayAt("grenadebounce.ogg", newposition.x, newposition.y, newposition.z);
				}
			}
		}
	}
	{
		var qnewpositionX = newposition.x;
		var qnewpositionY = newposition.y;
		var qnewpositionZ = newposition.z - this.walldistance;
		var newempty = game.isTileEmptyForPhysics(game.mathFloor(qnewpositionX), game.mathFloor(qnewpositionZ), game.mathFloor(qnewpositionY)) && game.isTileEmptyForPhysics(game.mathFloor(qnewpositionX), game.mathFloor(qnewpositionZ), game.mathFloor(qnewpositionY) + 1);
		if (newposition.z - oldposition.z < 0) {
			if (!newempty) {
				velocity.z = -velocity.z;
				velocity.x *= this.bouncespeedmultiply;
				velocity.y *= this.bouncespeedmultiply;
				velocity.z *= this.bouncespeedmultiply;
				if (ismoving) {
					game.audioPlayAt("grenadebounce.ogg", newposition.x, newposition.y, newposition.z);
				}
			}
		}
	}
	{
		var qnewpositionX = newposition.x - this.walldistance;
		var qnewpositionY = newposition.y;
		var qnewpositionZ = newposition.z;
		var newempty = game.isTileEmptyForPhysics(game.mathFloor(qnewpositionX), game.mathFloor(qnewpositionZ), game.mathFloor(qnewpositionY)) && game.isTileEmptyForPhysics(game.mathFloor(qnewpositionX), game.mathFloor(qnewpositionZ), game.mathFloor(qnewpositionY) + 1);
		if (newposition.x - oldposition.x < 0) {
			if (!newempty) {
				velocity.x = -velocity.x;
				velocity.x *= this.bouncespeedmultiply;
				velocity.y *= this.bouncespeedmultiply;
				velocity.z *= this.bouncespeedmultiply;
				if (ismoving) {
					game.audioPlayAt("grenadebounce.ogg", newposition.x, newposition.y, newposition.z);
				}
			}
		}
	}
	{
		var qnewpositionX = newposition.x;
		var qnewpositionY = newposition.y + modelheight;
		var qnewpositionZ = newposition.z;
		var newempty = game.isTileEmptyForPhysics(game.mathFloor(qnewpositionX), game.mathFloor(qnewpositionZ), game.mathFloor(qnewpositionY));
		if (newposition.y - oldposition.y > 0) {
			if (!newempty) {
				velocity.y = -velocity.y;
				velocity.x *= this.bouncespeedmultiply;
				velocity.y *= this.bouncespeedmultiply;
				velocity.z *= this.bouncespeedmultiply;
				if (ismoving) {
					game.audioPlayAt("grenadebounce.ogg", newposition.x, newposition.y, newposition.z);
				}
			}
		}
	}
	playerpositionY -= this.walldistance;
	return Vector3Ref.create(playerpositionX, playerpositionY, playerpositionZ);
}

ModGrenade.prototype.onNewFrameFixed = function(game, args) {
	for (var i = 0; i < game.entitiesCount; i++) {
		var entity = game.entities[i];
		if (entity == null) {
			continue;
		}
		if (entity.grenade == null) {
			continue;
		}
		this.updateGrenade(game, i, args.getDt());
	}
}

ModGrenade.prototype.updateGrenade = function(game, grenadeEntityId, dt) {
	var LocalPlayerPositionX = game.player.position.x;
	var LocalPlayerPositionY = game.player.position.y;
	var LocalPlayerPositionZ = game.player.position.z;
	var grenadeEntity = game.entities[grenadeEntityId];
	var grenadeSprite = grenadeEntity.sprite;
	var grenade = grenadeEntity.grenade;
	var oldposX = grenadeEntity.sprite.positionX;
	var oldposY = grenadeSprite.positionY;
	var oldposZ = grenadeSprite.positionZ;
	var newposX = grenadeSprite.positionX + grenade.velocityX * dt;
	var newposY = grenadeSprite.positionY + grenade.velocityY * dt;
	var newposZ = grenadeSprite.positionZ + grenade.velocityZ * dt;
	grenade.velocityY += -this.projectilegravity * dt;
	var velocity = Vector3Ref.create(grenade.velocityX, grenade.velocityY, grenade.velocityZ);
	var bouncePosition = this.grenadeBounce(game, Vector3Ref.create(oldposX, oldposY, oldposZ), Vector3Ref.create(newposX, newposY, newposZ), velocity, dt);
	grenade.velocityX = velocity.x;
	grenade.velocityY = velocity.y;
	grenade.velocityZ = velocity.z;
	grenadeSprite.positionX = bouncePosition.x;
	grenadeSprite.positionY = bouncePosition.y;
	grenadeSprite.positionZ = bouncePosition.z;
}

function ModGuiChat()
{
	this.chatFontSize = null;
	this.chatLinesMaxToDraw = 0;
	this.chatPageScroll = 0;
	this.chatScreenExpireTimeSeconds = 0;
	this.chatlines2 = null;
	this.chatlines2Count = 0;
	this.color_background = 0;
	this.font = null;
	this.game = null;
	this.one = null;
	this.one = 1;
	this.chatFontSize = 11;
	this.chatScreenExpireTimeSeconds = 20;
	this.chatLinesMaxToDraw = 10;
	this.font = new FontCi();
	this.font.family = "Arial";
	this.font.size = this.chatFontSize;
	this.chatlines2 = new Array(1024);
	this.color_background = Game.colorFromArgb(80, 0, 0, 0);
}
ModGuiChat.prototype = new ClientMod();

ModGuiChat.prototype.doAutocomplete = function(text) {
	if (!this.game.platform.stringEmpty(text)) {
		for (var i = 0; i < this.game.entitiesCount; i++) {
			var entity = this.game.entities[i];
			if (entity == null) {
				continue;
			}
			if (entity.drawName == null) {
				continue;
			}
			if (!entity.drawName.clientAutoComplete) {
				continue;
			}
			var p = entity.drawName;
			if (this.game.platform.stringStartsWithIgnoreCase(StringTools.stringSubstringToEnd(this.game.platform, p.name, 2), text)) {
				return StringTools.stringSubstringToEnd(this.game.platform, p.name, 2);
			}
		}
	}
	return "";
}

ModGuiChat.prototype.drawChatLines = function(all) {
	this.chatlines2Count = 0;
	var timeNow = this.game.platform.timeMillisecondsFromStart();
	var scroll;
	if (!all) {
		scroll = 0;
	}
	else {
		scroll = this.chatPageScroll;
	}
	var first = this.game.chatLinesCount - this.chatLinesMaxToDraw * (scroll + 1);
	if (first < 0) {
		first = 0;
	}
	var count = this.game.chatLinesCount;
	if (count > this.chatLinesMaxToDraw) {
		count = this.chatLinesMaxToDraw;
	}
	for (var i = first; i < first + count; i++) {
		var c = this.game.chatLines[i];
		if (all || (this.one * (timeNow - c.timeMilliseconds)) / (1000) < this.chatScreenExpireTimeSeconds) {
			this.chatlines2[this.chatlines2Count++] = c;
		}
	}
	this.font.size = this.chatFontSize * this.game.scale();
	var posX = 20;
	var posY = 90;
	var lineSpacing = this.font.size * 1.75;
	if (this.chatlines2Count > 0) {
		this.game.draw2dTexture(this.game.whiteTexture(), (posX - 4) * this.game.scale(), (posY - 4) * this.game.scale(), 758 * this.game.scale(), (this.chatlines2Count * lineSpacing + 4) * this.game.scale(), null, 0, this.color_background, false);
	}
	for (var i = 0; i < this.chatlines2Count; i++) {
		if (this.chatlines2[i].clickable) {
			this.font.style = 3;
		}
		else {
			this.font.style = 1;
		}
		this.game.draw2dText(this.chatlines2[i].text, this.font, posX * this.game.scale(), (posY + i * lineSpacing) * this.game.scale(), null, false);
	}
	if (this.chatPageScroll != 0) {
		this.game.draw2dText(this.game.platform.stringFormat("&7Page: {0}", this.game.platform.intToString(this.chatPageScroll)), this.font, posX * this.game.scale(), (posY + -1 * lineSpacing) * this.game.scale(), null, false);
	}
}

ModGuiChat.prototype.drawTypingBuffer = function() {
	this.font.size = this.chatFontSize * this.game.scale();
	var s = this.game.guiTypingBuffer;
	if (this.game.isTeamchat) {
		s = this.game.platform.stringFormat("&aTo team: &f{0}", s);
	}
	var posX;
	var posY;
	if (this.game.platform.isSmallScreen()) {
		posX = 20 * this.game.scale();
		posY = Math.floor(this.game.platform.getCanvasHeight() / 2) * this.game.scale();
	}
	else {
		posX = 20 * this.game.scale();
		posY = this.game.platform.getCanvasHeight() - 150 * this.game.scale();
	}
	this.game.draw2dTexture(this.game.whiteTexture(), (posX - 4) * this.game.scale(), (posY - 4) * this.game.scale(), 758 * this.game.scale(), (1.5 * this.font.size + 8) * this.game.scale(), null, 0, this.color_background, false);
	this.game.draw2dText(this.game.platform.stringFormat("{0}_", s), this.font, posX, posY, null, true);
}

ModGuiChat.prototype.onKeyDown = function(game_, args) {
	if (this.game.guistate != GuiState.NORMAL) {
		return;
	}
	var eKey = args.getKeyCode();
	if (eKey == this.game.getKey(116) && this.game.isShiftPressed && this.game.guiTyping == TypingState.NONE) {
		this.game.guiTyping = TypingState.TYPING;
		this.game.isTyping = true;
		this.game.guiTypingBuffer = "";
		this.game.isTeamchat = false;
		args.setHandled(true);
		return;
	}
	if (eKey == this.game.getKey(56) && this.game.guiTyping == TypingState.TYPING) {
		this.chatPageScroll++;
		args.setHandled(true);
	}
	if (eKey == this.game.getKey(57) && this.game.guiTyping == TypingState.TYPING) {
		this.chatPageScroll--;
		args.setHandled(true);
	}
	this.chatPageScroll = MathCi.clampInt(this.chatPageScroll, 0, Math.floor(this.game.chatLinesCount / this.chatLinesMaxToDraw));
	if (eKey == this.game.getKey(49) || eKey == this.game.getKey(82)) {
		if (this.game.guiTyping == TypingState.TYPING) {
			this.game.typinglog[this.game.typinglogCount++] = this.game.guiTypingBuffer;
			this.game.typinglogpos = this.game.typinglogCount;
			this.game.clientCommand(this.game.guiTypingBuffer);
			this.game.guiTypingBuffer = "";
			this.game.isTyping = false;
			this.game.guiTyping = TypingState.NONE;
			this.game.platform.showKeyboard(false);
		}
		else if (this.game.guiTyping == TypingState.NONE) {
			this.game.startTyping();
		}
		else if (this.game.guiTyping == TypingState.READY) {
			this.game.platform.consoleWriteLine("Keyboard_KeyDown ready");
		}
		args.setHandled(true);
		return;
	}
	if (this.game.guiTyping == TypingState.TYPING) {
		var key = eKey;
		if (key == this.game.getKey(53)) {
			if (StringTools.stringLength(this.game.platform, this.game.guiTypingBuffer) > 0) {
				this.game.guiTypingBuffer = StringTools.stringSubstring(this.game.platform, this.game.guiTypingBuffer, 0, StringTools.stringLength(this.game.platform, this.game.guiTypingBuffer) - 1);
			}
			args.setHandled(true);
			return;
		}
		if (this.game.keyboardStateRaw[this.game.getKey(3)] || this.game.keyboardStateRaw[this.game.getKey(4)]) {
			if (key == this.game.getKey(104)) {
				if (this.game.platform.clipboardContainsText()) {
					this.game.guiTypingBuffer = StringTools.stringAppend(this.game.platform, this.game.guiTypingBuffer, this.game.platform.clipboardGetText());
				}
				args.setHandled(true);
				return;
			}
		}
		if (key == this.game.getKey(45)) {
			this.game.typinglogpos--;
			if (this.game.typinglogpos < 0) {
				this.game.typinglogpos = 0;
			}
			if (this.game.typinglogpos >= 0 && this.game.typinglogpos < this.game.typinglogCount) {
				this.game.guiTypingBuffer = this.game.typinglog[this.game.typinglogpos];
			}
			args.setHandled(true);
		}
		if (key == this.game.getKey(46)) {
			this.game.typinglogpos++;
			if (this.game.typinglogpos > this.game.typinglogCount) {
				this.game.typinglogpos = this.game.typinglogCount;
			}
			if (this.game.typinglogpos >= 0 && this.game.typinglogpos < this.game.typinglogCount) {
				this.game.guiTypingBuffer = this.game.typinglog[this.game.typinglogpos];
			}
			if (this.game.typinglogpos == this.game.typinglogCount) {
				this.game.guiTypingBuffer = "";
			}
			args.setHandled(true);
		}
		if (eKey == this.game.getKey(52) && this.game.platform.stringTrim(this.game.guiTypingBuffer) != "") {
			var partsLength = new IntRef();
			var parts = this.game.platform.stringSplit(this.game.guiTypingBuffer, " ", partsLength);
			var completed = this.doAutocomplete(parts[partsLength.value - 1]);
			if (completed == "") {
				args.setHandled(true);
				return;
			}
			else if (partsLength.value == 1) {
				this.game.guiTypingBuffer = StringTools.stringAppend(this.game.platform, completed, ": ");
			}
			else {
				parts[partsLength.value - 1] = completed;
				this.game.guiTypingBuffer = StringTools.stringAppend(this.game.platform, this.game.platform.stringJoin(parts, " "), " ");
			}
			args.setHandled(true);
			return;
		}
		args.setHandled(true);
		return;
	}
}

ModGuiChat.prototype.onKeyPress = function(game_, args) {
	if (this.game.guistate != GuiState.NORMAL) {
		return;
	}
	var eKeyChar = args.getKeyChar();
	var chart = 116;
	var charT = 84;
	var chary = 121;
	var charY = 89;
	if ((eKeyChar == chart || eKeyChar == charT) && this.game.guiTyping == TypingState.NONE) {
		this.game.guiTyping = TypingState.TYPING;
		this.game.guiTypingBuffer = "";
		this.game.isTeamchat = false;
		return;
	}
	if ((eKeyChar == chary || eKeyChar == charY) && this.game.guiTyping == TypingState.NONE) {
		this.game.guiTyping = TypingState.TYPING;
		this.game.guiTypingBuffer = "";
		this.game.isTeamchat = true;
		return;
	}
	if (this.game.guiTyping == TypingState.TYPING) {
		var c = eKeyChar;
		if (this.game.platform.isValidTypingChar(c)) {
			this.game.guiTypingBuffer = StringTools.stringAppend(this.game.platform, this.game.guiTypingBuffer, this.game.charToString(c));
		}
	}
}

ModGuiChat.prototype.onMouseDown = function(game_, args) {
	for (var i = 0; i < this.chatlines2Count; i++) {
		var dx = 20;
		if (!this.game.platform.isMousePointerLocked()) {
			dx += 100;
		}
		var chatlineStartX = dx * this.game.scale();
		var chatlineStartY = (90 + i * 25) * this.game.scale();
		var chatlineSizeX = 500 * this.game.scale();
		var chatlineSizeY = 20 * this.game.scale();
		if (args.getX() > chatlineStartX && args.getX() < chatlineStartX + chatlineSizeX) {
			if (args.getY() > chatlineStartY && args.getY() < chatlineStartY + chatlineSizeY) {
				if (this.chatlines2[i].clickable) {
					this.game.platform.openLinkInBrowser(this.chatlines2[i].linkTarget);
				}
			}
		}
	}
}

ModGuiChat.prototype.onNewFrameDraw2d = function(game_, deltaTime) {
	this.game = game_;
	if (this.game.guistate == GuiState.MAP_LOADING) {
		return;
	}
	this.drawChatLines(this.game.guiTyping == TypingState.TYPING);
	if (this.game.guiTyping == TypingState.TYPING) {
		this.drawTypingBuffer();
	}
}

function ModGuiCrafting()
{
	this.craftingTableposx = 0;
	this.craftingTableposy = 0;
	this.craftingTableposz = 0;
	this.craftingblocks = null;
	this.craftingblocksCount = 0;
	this.craftingrecipes2 = null;
	this.craftingrecipes2Count = 0;
	this.craftingselectedrecipe = 0;
	this.currentRecipes = null;
	this.currentRecipesCount = 0;
	this.d_CraftingRecipes = null;
	this.d_CraftingRecipesCount = 0;
	this.d_CraftingTableTool = null;
	this.fontCraftingGui = null;
	this.handler = null;
	this.handler = new PacketHandlerCraftingRecipes();
	this.handler.mod = this;
	this.fontCraftingGui = new FontCi();
}
ModGuiCrafting.prototype = new ClientMod();

ModGuiCrafting.prototype.craftingMouse = function(game) {
	if (this.currentRecipes == null) {
		return;
	}
	var menustartx = game.xcenter(600);
	var menustarty = game.ycenter(this.currentRecipesCount * 80);
	if (game.mouseCurrentY >= menustarty && game.mouseCurrentY < menustarty + this.currentRecipesCount * 80) {
		this.craftingselectedrecipe = Math.floor((game.mouseCurrentY - menustarty) / 80);
	}
	else {
	}
	if (game.mouseleftclick) {
		if (this.currentRecipesCount != 0) {
			this.craftingRecipeSelected(game, this.craftingTableposx, this.craftingTableposy, this.craftingTableposz, IntRef.create(this.currentRecipes[this.craftingselectedrecipe]));
		}
		game.mouseleftclick = false;
		game.guiStateBackToGame();
	}
}

ModGuiCrafting.prototype.craftingRecipeSelected = function(game, x, y, z, recipe) {
	if (recipe == null) {
		return;
	}
	game.sendPacketClient(ClientPackets.craft(x, y, z, recipe.value));
}

ModGuiCrafting.prototype.craftingRecipesStart = function(game, recipes, recipesCount, blocks, blocksCount, posx, posy, posz) {
	this.craftingrecipes2 = recipes;
	this.craftingrecipes2Count = recipesCount;
	this.craftingblocks = blocks;
	this.craftingblocksCount = blocksCount;
	this.craftingTableposx = posx;
	this.craftingTableposy = posy;
	this.craftingTableposz = posz;
	game.guistate = GuiState.CRAFTING_RECIPES;
	game.menustate = new MenuState();
	game.setFreeMouse(true);
}

ModGuiCrafting.prototype.drawCraftingRecipes = function(game) {
	this.currentRecipes = new Int32Array(new ArrayBuffer(1024 << 2));
	this.currentRecipesCount = 0;
	for (var i = 0; i < this.craftingrecipes2Count; i++) {
		var r = this.craftingrecipes2[i];
		if (r == null) {
			continue;
		}
		var next = false;
		for (var k = 0; k < r.ingredientsCount; k++) {
			var ingredient = r.ingredients[k];
			if (ingredient == null) {
				continue;
			}
			if (this.craftingblocksFindAllCount(this.craftingblocks, this.craftingblocksCount, ingredient.type) < ingredient.amount) {
				next = true;
				break;
			}
		}
		if (!next) {
			this.currentRecipes[this.currentRecipesCount++] = i;
		}
	}
	var menustartx = game.xcenter(600);
	var menustarty = game.ycenter(this.currentRecipesCount * 80);
	if (this.currentRecipesCount == 0) {
		game.draw2dText(game.language.noMaterialsForCrafting(), this.fontCraftingGui, game.xcenter(200), game.ycenter(20), null, false);
		return;
	}
	for (var i = 0; i < this.currentRecipesCount; i++) {
		var r = this.craftingrecipes2[this.currentRecipes[i]];
		for (var ii = 0; ii < r.ingredientsCount; ii++) {
			var xx = menustartx + 20 + ii * 130;
			var yy = menustarty + i * 80;
			game.draw2dTexture(game.d_TerrainTextures.terrainTexture(), xx, yy, 32, 32, IntRef.create(game.textureIdForInventory[r.ingredients[ii].type]), game.texturesPacked(), Game.colorFromArgb(255, 255, 255, 255), false);
			game.draw2dText(game.platform.stringFormat2("{0} {1}", game.platform.intToString(r.ingredients[ii].amount), game.blocktypes[r.ingredients[ii].type].name), this.fontCraftingGui, xx + 50, yy, IntRef.create(i == this.craftingselectedrecipe ? Game.colorFromArgb(255, 255, 0, 0) : Game.colorFromArgb(255, 255, 255, 255)), false);
		}
		{
			var xx = menustartx + 20 + 400;
			var yy = menustarty + i * 80;
			game.draw2dTexture(game.d_TerrainTextures.terrainTexture(), xx, yy, 32, 32, IntRef.create(game.textureIdForInventory[r.output.type]), game.texturesPacked(), Game.colorFromArgb(255, 255, 255, 255), false);
			game.draw2dText(game.platform.stringFormat2("{0} {1}", game.platform.intToString(r.output.amount), game.blocktypes[r.output.type].name), this.fontCraftingGui, xx + 50, yy, IntRef.create(i == this.craftingselectedrecipe ? Game.colorFromArgb(255, 255, 0, 0) : Game.colorFromArgb(255, 255, 255, 255)), false);
		}
	}
}

ModGuiCrafting.prototype.onKeyDown = function(game, args) {
	var eKey = args.getKeyCode();
	if (eKey == game.getKey(87) && game.guiTyping == TypingState.NONE) {
		if (!(game.selectedBlockPositionX == -1 && game.selectedBlockPositionY == -1 && game.selectedBlockPositionZ == -1)) {
			var posx = game.selectedBlockPositionX;
			var posy = game.selectedBlockPositionZ;
			var posz = game.selectedBlockPositionY;
			if (game.map.getBlock(posx, posy, posz) == game.d_Data.blockIdCraftingTable()) {
				var tableCount = new IntRef();
				var table = this.d_CraftingTableTool.getTable(posx, posy, posz, tableCount);
				var onTableCount = new IntRef();
				var onTable = this.d_CraftingTableTool.getOnTable(table, tableCount.value, onTableCount);
				this.craftingRecipesStart(game, this.d_CraftingRecipes, this.d_CraftingRecipesCount, onTable, onTableCount.value, posx, posy, posz);
				args.setHandled(true);
			}
		}
	}
}

ModGuiCrafting.prototype.onNewFrameDraw2d = function(game, deltaTime) {
	if (this.d_CraftingTableTool == null) {
		this.d_CraftingTableTool = new CraftingTableTool();
		this.d_CraftingTableTool.d_Map = MapStorage2.create(game);
		this.d_CraftingTableTool.d_Data = game.d_Data;
	}
	game.packetHandlers[30] = this.handler;
	if (game.guistate != GuiState.CRAFTING_RECIPES) {
		return;
	}
	this.drawCraftingRecipes(game);
}

ModGuiCrafting.prototype.onNewFrameFixed = function(game, args) {
	if (game.guistate != GuiState.CRAFTING_RECIPES) {
		return;
	}
	this.craftingMouse(game);
}

ModGuiCrafting.prototype.craftingblocksFindAllCount = function(craftingblocks_, craftingblocksCount_, p) {
	var count = 0;
	for (var i = 0; i < craftingblocksCount_; i++) {
		if (craftingblocks_[i] == p) {
			count++;
		}
	}
	return count;
}

function ModGuiEscapeMenu()
{
	this.buttonMainExit = null;
	this.buttonMainOptions = null;
	this.buttonMainReturnToGame = null;
	this.changedResolution = false;
	this.escapemenustate = EscapeMenuState.MAIN;
	this.fontEscapeMenu = null;
	this.fontValues = null;
	this.fonts = null;
	this.fontsLength = 0;
	this.game = null;
	this.graphicsFontOption = null;
	this.graphicsOptionDarkenSides = null;
	this.graphicsOptionFramerate = null;
	this.graphicsOptionFullscreen = null;
	this.graphicsOptionResolution = null;
	this.graphicsOptionSmoothShadows = null;
	this.graphicsReturnToOptionsMenu = null;
	this.graphicsUseServerTexturesOption = null;
	this.graphicsViewDistanceOption = null;
	this.keyButtons = null;
	this.keysDefaultKeys = null;
	this.keysReturnToOptionsMenu = null;
	this.keyselectid = 0;
	this.loaded = false;
	this.one = null;
	this.optionsGraphics = null;
	this.optionsKeys = null;
	this.optionsOther = null;
	this.optionsReturnToMainMenu = null;
	this.originalResolutionHeight = 0;
	this.originalResolutionWidth = 0;
	this.otherAutoJumpOption = null;
	this.otherLanguageSetting = null;
	this.otherReturnToOptionsMenu = null;
	this.otherSoundOption = null;
	this.widgets = null;
	this.widgetsCount = 0;
	this.one = 1;
	this.fonts = new Array(4);
	this.fonts[0] = "Nice";
	this.fonts[1] = "Simple";
	this.fonts[2] = "BlackBackground";
	this.fonts[3] = "Default";
	this.fontsLength = 4;
	this.fontValues = new Int32Array(new ArrayBuffer(4 << 2));
	this.fontValues[0] = 0;
	this.fontValues[1] = 1;
	this.fontValues[2] = 2;
	this.fontValues[3] = 3;
	this.widgets = new Array(1024);
	this.keyselectid = -1;
	this.fontEscapeMenu = FontCi.create("Arial", 20, 0);
}
ModGuiEscapeMenu.prototype = new ClientMod();

ModGuiEscapeMenu.prototype.addWidget = function(b) {
	this.widgets[this.widgetsCount++] = b;
}

ModGuiEscapeMenu.prototype.escapeMenuMouse1 = function() {
	for (var i = 0; i < this.widgetsCount; i++) {
		var w = this.widgets[i];
		w.selected = this.rectContains(w.x, w.y, w.width, w.height, this.game.mouseCurrentX, this.game.mouseCurrentY);
		if (w.selected && this.game.mouseleftclick) {
			this.handleButtonClick(w);
			break;
		}
	}
}

ModGuiEscapeMenu.prototype.fontString = function() {
	return this.fonts[this.game.options.font];
}

ModGuiEscapeMenu.prototype.graphicsHandleClick = function(b) {
	var options = this.game.options;
	if (b == this.graphicsOptionSmoothShadows) {
		options.smoothshadows = !options.smoothshadows;
		this.game.d_TerrainChunkTesselator.enableSmoothLight = options.smoothshadows;
		if (options.smoothshadows) {
			options.blockShadowSave = (this.one * 7) / (10);
			this.game.d_TerrainChunkTesselator.blockShadow = options.blockShadowSave;
		}
		else {
			options.blockShadowSave = (this.one * 6) / (10);
			this.game.d_TerrainChunkTesselator.blockShadow = options.blockShadowSave;
		}
		this.game.redrawAllBlocks();
	}
	if (b == this.graphicsOptionDarkenSides) {
		options.enableBlockShadow = !options.enableBlockShadow;
		this.game.d_TerrainChunkTesselator.option_DarkenBlockSides = options.enableBlockShadow;
		this.game.redrawAllBlocks();
	}
	if (b == this.graphicsViewDistanceOption) {
		this.game.toggleFog();
	}
	if (b == this.graphicsOptionFramerate) {
		this.game.toggleVsync();
	}
	if (b == this.graphicsOptionResolution) {
		this.toggleResolution();
	}
	if (b == this.graphicsOptionFullscreen) {
		options.fullscreen = !options.fullscreen;
	}
	if (b == this.graphicsUseServerTexturesOption) {
		options.useServerTextures = !options.useServerTextures;
	}
	if (b == this.graphicsFontOption) {
		this.toggleFont();
	}
	if (b == this.graphicsReturnToOptionsMenu) {
		this.useFullscreen();
		this.useResolution();
		this.setEscapeMenuState(EscapeMenuState.OPTIONS);
	}
}

ModGuiEscapeMenu.prototype.graphicsSet = function() {
	var options = this.game.options;
	var language = this.game.language;
	this.graphicsOptionSmoothShadows = new Button();
	this.graphicsOptionSmoothShadows.text = this.game.platform.stringFormat(language.optionSmoothShadows(), options.smoothshadows ? language.on() : language.off());
	this.graphicsOptionDarkenSides = new Button();
	this.graphicsOptionDarkenSides.text = this.game.platform.stringFormat(language.get("OptionDarkenSides"), options.enableBlockShadow ? language.on() : language.off());
	this.graphicsViewDistanceOption = new Button();
	this.graphicsViewDistanceOption.text = this.game.platform.stringFormat(language.viewDistanceOption(), this.game.platform.intToString(this.game.platform.floatToInt(this.game.d_Config3d.viewdistance)));
	this.graphicsOptionFramerate = new Button();
	this.graphicsOptionFramerate.text = this.game.platform.stringFormat(language.optionFramerate(), this.vsyncString());
	this.graphicsOptionResolution = new Button();
	this.graphicsOptionResolution.text = this.game.platform.stringFormat(language.optionResolution(), this.resolutionString());
	this.graphicsOptionFullscreen = new Button();
	this.graphicsOptionFullscreen.text = this.game.platform.stringFormat(language.optionFullscreen(), options.fullscreen ? language.on() : language.off());
	this.graphicsUseServerTexturesOption = new Button();
	this.graphicsUseServerTexturesOption.text = this.game.platform.stringFormat(language.useServerTexturesOption(), options.useServerTextures ? language.on() : language.off());
	this.graphicsFontOption = new Button();
	this.graphicsFontOption.text = this.game.platform.stringFormat(language.fontOption(), this.fontString());
	this.graphicsReturnToOptionsMenu = new Button();
	this.graphicsReturnToOptionsMenu.text = language.returnToOptionsMenu();
	this.widgetsClear();
	this.addWidget(this.graphicsOptionSmoothShadows);
	this.addWidget(this.graphicsOptionDarkenSides);
	this.addWidget(this.graphicsViewDistanceOption);
	this.addWidget(this.graphicsOptionFramerate);
	this.addWidget(this.graphicsOptionResolution);
	this.addWidget(this.graphicsOptionFullscreen);
	this.addWidget(this.graphicsUseServerTexturesOption);
	this.addWidget(this.graphicsFontOption);
	this.addWidget(this.graphicsReturnToOptionsMenu);
}

ModGuiEscapeMenu.prototype.handleButtonClick = function(w) {
	this.mainHandleClick(w);
	this.optionsHandleClick(w);
	this.graphicsHandleClick(w);
	this.otherHandleClick(w);
	this.keysHandleClick(w);
}

ModGuiEscapeMenu.prototype.keyHelpCreate = function(text, defaultKey) {
	var h = new KeyHelp();
	h.text = text;
	h.defaultKey = defaultKey;
	return h;
}

ModGuiEscapeMenu.prototype.keyName = function(key) {
	return this.game.platform.keyName(key);
}

ModGuiEscapeMenu.prototype.keysHandleClick = function(b) {
	if (this.keyButtons != null) {
		for (var i = 0; i < 1024; i++) {
			if (this.keyButtons[i] == b) {
				this.keyselectid = i;
			}
		}
	}
	if (b == this.keysDefaultKeys) {
		this.game.options.keys = new Int32Array(new ArrayBuffer(256 << 2));
	}
	if (b == this.keysReturnToOptionsMenu) {
		this.setEscapeMenuState(EscapeMenuState.OPTIONS);
	}
}

ModGuiEscapeMenu.prototype.keysSet = function() {
	var language = this.game.language;
	this.keyButtons = new Array(1024);
	for (var i = 0; i < 1024; i++) {
		this.keyButtons[i] = null;
	}
	var helps = this.keyhelps();
	for (var i = 0; i < 1024; i++) {
		if (helps[i] == null) {
			break;
		}
		var defaultkey = helps[i].defaultKey;
		var key = defaultkey;
		if (this.game.options.keys[defaultkey] != 0) {
			key = this.game.options.keys[defaultkey];
		}
		this.keyButtons[i] = new Button();
		this.keyButtons[i].text = this.game.platform.stringFormat2(language.keyChange(), helps[i].text, this.keyName(key));
		this.addWidget(this.keyButtons[i]);
	}
	this.keysDefaultKeys = new Button();
	this.keysDefaultKeys.text = language.defaultKeys();
	this.keysReturnToOptionsMenu = new Button();
	this.keysReturnToOptionsMenu.text = language.returnToOptionsMenu();
	this.addWidget(this.keysDefaultKeys);
	this.addWidget(this.keysReturnToOptionsMenu);
}

ModGuiEscapeMenu.prototype.loadOptions = function() {
	var o = this.loadOptions_();
	if (o == null) {
		return;
	}
	this.game.options = o;
	var options = o;
	this.game.font = this.fontValues[options.font];
	this.game.updateTextRendererFont();
	this.game.d_Config3d.viewdistance = options.drawDistance;
	this.game.audioEnabled = options.enableSound;
	this.game.autoJumpEnabled = options.enableAutoJump;
	if (options.clientLanguage != "") {
		this.game.language.overrideLanguage = options.clientLanguage;
	}
	this.game.d_TerrainChunkTesselator.enableSmoothLight = options.smoothshadows;
	this.game.d_TerrainChunkTesselator.blockShadow = options.blockShadowSave;
	this.game.d_TerrainChunkTesselator.option_DarkenBlockSides = options.enableBlockShadow;
	this.game.eNABLE_LAG = options.framerate;
	this.useFullscreen();
	this.game.useVsync();
	this.useResolution();
}

ModGuiEscapeMenu.prototype.loadOptions_ = function() {
	var options = new OptionsCi();
	var preferences = this.game.platform.getPreferences();
	options.shadows = preferences.getBool("Shadows", true);
	options.font = preferences.getInt("Font", 0);
	options.drawDistance = preferences.getInt("DrawDistance", this.game.platform.isFastSystem() ? 128 : 32);
	options.useServerTextures = preferences.getBool("UseServerTextures", true);
	options.enableSound = preferences.getBool("EnableSound", true);
	options.enableAutoJump = preferences.getBool("EnableAutoJump", false);
	options.clientLanguage = preferences.getString("ClientLanguage", "");
	options.framerate = preferences.getInt("Framerate", 0);
	options.resolution = preferences.getInt("Resolution", 0);
	options.fullscreen = preferences.getBool("Fullscreen", false);
	options.smoothshadows = preferences.getBool("Smoothshadows", true);
	options.blockShadowSave = (this.one * preferences.getInt("BlockShadowSave", 70)) / (100);
	options.enableBlockShadow = preferences.getBool("EnableBlockShadow", true);
	for (var i = 0; i < 256; i++) {
		var preferencesKey = StringTools.stringAppend(this.game.platform, "Key", this.game.platform.intToString(i));
		var value = preferences.getInt(preferencesKey, 0);
		if (value != 0) {
			options.keys[i] = value;
		}
	}
	return options;
}

ModGuiEscapeMenu.prototype.mainHandleClick = function(b) {
	if (b == this.buttonMainReturnToGame) {
		this.game.guiStateBackToGame();
	}
	if (b == this.buttonMainOptions) {
		this.setEscapeMenuState(EscapeMenuState.OPTIONS);
	}
	if (b == this.buttonMainExit) {
		this.game.sendLeave(0);
		this.game.exitToMainMenu_();
	}
}

ModGuiEscapeMenu.prototype.mainSet = function() {
	var language = this.game.language;
	this.buttonMainReturnToGame = new Button();
	this.buttonMainReturnToGame.text = language.returnToGame();
	this.buttonMainOptions = new Button();
	this.buttonMainOptions.text = language.options();
	this.buttonMainExit = new Button();
	this.buttonMainExit.text = language.exit();
	this.widgetsClear();
	this.addWidget(this.buttonMainReturnToGame);
	this.addWidget(this.buttonMainOptions);
	this.addWidget(this.buttonMainExit);
}

ModGuiEscapeMenu.prototype.makeSimpleOptions = function(font, textheight) {
	var starty = this.game.ycenter(this.widgetsCount * textheight);
	for (var i = 0; i < this.widgetsCount; i++) {
		var s = this.widgets[i].text;
		var sizeWidth = this.game.textSizeWidth(s, font);
		var sizeHeight = this.game.textSizeHeight(s, font);
		var Width = this.game.platform.floatToInt(sizeWidth) + 10;
		var Height = this.game.platform.floatToInt(sizeHeight);
		var X = this.game.xcenter(sizeWidth);
		var Y = starty + textheight * i;
		this.widgets[i].x = X;
		this.widgets[i].y = Y;
		this.widgets[i].width = Width;
		this.widgets[i].height = Height;
		this.widgets[i].font = font;
		if (i == this.keyselectid) {
			this.widgets[i].fontcolor = Game.colorFromArgb(255, 0, 255, 0);
			this.widgets[i].fontcolorselected = Game.colorFromArgb(255, 0, 255, 0);
		}
	}
}

ModGuiEscapeMenu.prototype.onKeyDown = function(game_, args) {
	var eKey = args.getKeyCode();
	if (eKey == this.game.getKey(50)) {
		if (this.escapemenustate == EscapeMenuState.GRAPHICS || this.escapemenustate == EscapeMenuState.KEYS || this.escapemenustate == EscapeMenuState.OTHER) {
			this.setEscapeMenuState(EscapeMenuState.OPTIONS);
		}
		else if (this.escapemenustate == EscapeMenuState.OPTIONS) {
			this.saveOptions();
			this.setEscapeMenuState(EscapeMenuState.MAIN);
		}
		else {
			this.setEscapeMenuState(EscapeMenuState.MAIN);
			this.game.guiStateBackToGame();
		}
		args.setHandled(true);
	}
	if (this.escapemenustate == EscapeMenuState.KEYS) {
		if (this.keyselectid != -1) {
			this.game.options.keys[this.keyhelps()[this.keyselectid].defaultKey] = eKey;
			this.keyselectid = -1;
			args.setHandled(true);
		}
	}
	if (eKey == this.game.getKey(20)) {
		if (this.game.platform.getWindowState() == WindowState.FULLSCREEN) {
			this.game.platform.setWindowState(WindowState.NORMAL);
			this.restoreResolution();
			this.saveOptions();
		}
		else {
			this.game.platform.setWindowState(WindowState.FULLSCREEN);
			this.useResolution();
			this.saveOptions();
		}
		args.setHandled(true);
	}
}

ModGuiEscapeMenu.prototype.onNewFrameDraw2d = function(game_, deltaTime) {
	this.game = game_;
	if (!this.loaded) {
		this.loaded = true;
		this.loadOptions();
	}
	if (this.game.escapeMenuRestart) {
		this.game.escapeMenuRestart = false;
		this.setEscapeMenuState(EscapeMenuState.MAIN);
	}
	if (this.game.guistate != GuiState.ESCAPE_MENU) {
		return;
	}
	this.setEscapeMenuState(this.escapemenustate);
	this.escapeMenuMouse1();
	for (var i = 0; i < this.widgetsCount; i++) {
		var w = this.widgets[i];
		this.game.draw2dText(w.text, w.font, w.x, w.y, IntRef.create(w.selected ? w.fontcolorselected : w.fontcolor), false);
	}
}

ModGuiEscapeMenu.prototype.optionsHandleClick = function(b) {
	if (b == this.optionsGraphics) {
		this.setEscapeMenuState(EscapeMenuState.GRAPHICS);
	}
	if (b == this.optionsKeys) {
		this.setEscapeMenuState(EscapeMenuState.KEYS);
	}
	if (b == this.optionsOther) {
		this.setEscapeMenuState(EscapeMenuState.OTHER);
	}
	if (b == this.optionsReturnToMainMenu) {
		this.saveOptions();
		this.setEscapeMenuState(EscapeMenuState.MAIN);
	}
}

ModGuiEscapeMenu.prototype.optionsSet = function() {
	var language = this.game.language;
	this.optionsGraphics = new Button();
	this.optionsGraphics.text = language.graphics();
	this.optionsKeys = new Button();
	this.optionsKeys.text = language.keys();
	this.optionsOther = new Button();
	this.optionsOther.text = language.other();
	this.optionsReturnToMainMenu = new Button();
	this.optionsReturnToMainMenu.text = language.returnToMainMenu();
	this.widgetsClear();
	this.addWidget(this.optionsGraphics);
	this.addWidget(this.optionsKeys);
	this.addWidget(this.optionsOther);
	this.addWidget(this.optionsReturnToMainMenu);
}

ModGuiEscapeMenu.prototype.otherHandleClick = function(b) {
	if (b == this.otherSoundOption) {
		this.game.audioEnabled = !this.game.audioEnabled;
	}
	if (b == this.otherAutoJumpOption) {
		this.game.autoJumpEnabled = !this.game.autoJumpEnabled;
	}
	if (b == this.otherLanguageSetting) {
		this.game.language.nextLanguage();
	}
	if (b == this.otherReturnToOptionsMenu) {
		this.setEscapeMenuState(EscapeMenuState.OPTIONS);
	}
}

ModGuiEscapeMenu.prototype.otherSet = function() {
	var language = this.game.language;
	this.otherSoundOption = new Button();
	this.otherSoundOption.text = this.game.platform.stringFormat(language.soundOption(), this.game.audioEnabled ? language.on() : language.off());
	this.otherAutoJumpOption = new Button();
	this.otherAutoJumpOption.text = this.game.platform.stringFormat(language.autoJumpOption(), this.game.autoJumpEnabled ? language.on() : language.off());
	this.otherLanguageSetting = new Button();
	this.otherLanguageSetting.text = this.game.platform.stringFormat(language.clientLanguageOption(), language.getUsedLanguage());
	this.otherReturnToOptionsMenu = new Button();
	this.otherReturnToOptionsMenu.text = language.returnToOptionsMenu();
	this.widgetsClear();
	this.addWidget(this.otherSoundOption);
	this.addWidget(this.otherAutoJumpOption);
	this.addWidget(this.otherLanguageSetting);
	this.addWidget(this.otherReturnToOptionsMenu);
}

ModGuiEscapeMenu.prototype.rectContains = function(x, y, w, h, px, py) {
	return px >= x && py >= y && px < x + w && py < y + h;
}

ModGuiEscapeMenu.prototype.resolutionString = function() {
	var resolutionsCount = new IntRef();
	var res = this.game.platform.getDisplayResolutions(resolutionsCount)[this.game.options.resolution];
	return this.game.platform.stringFormat4("{0}x{1}, {2}, {3} Hz", this.game.platform.intToString(res.width), this.game.platform.intToString(res.height), this.game.platform.intToString(res.bitsPerPixel), this.game.platform.intToString(this.game.platform.floatToInt(res.refreshRate)));
}

ModGuiEscapeMenu.prototype.restoreResolution = function() {
	if (this.changedResolution) {
		this.game.platform.changeResolution(this.originalResolutionWidth, this.originalResolutionHeight, 32, -1);
		this.changedResolution = false;
	}
}

ModGuiEscapeMenu.prototype.saveOptions = function() {
	var options = this.game.options;
	options.font = this.game.font;
	options.shadows = true;
	options.drawDistance = this.game.platform.floatToInt(this.game.d_Config3d.viewdistance);
	options.enableSound = this.game.audioEnabled;
	options.enableAutoJump = this.game.autoJumpEnabled;
	if (this.game.language.overrideLanguage != null) {
		options.clientLanguage = this.game.language.overrideLanguage;
	}
	options.framerate = this.game.eNABLE_LAG;
	options.fullscreen = this.game.platform.getWindowState() == WindowState.FULLSCREEN;
	options.smoothshadows = this.game.d_TerrainChunkTesselator.enableSmoothLight;
	options.enableBlockShadow = this.game.d_TerrainChunkTesselator.option_DarkenBlockSides;
	this.saveOptions_(options);
}

ModGuiEscapeMenu.prototype.saveOptions_ = function(options) {
	var preferences = this.game.platform.getPreferences();
	preferences.setBool("Shadows", options.shadows);
	preferences.setInt("Font", options.font);
	preferences.setInt("DrawDistance", options.drawDistance);
	preferences.setBool("UseServerTextures", options.useServerTextures);
	preferences.setBool("EnableSound", options.enableSound);
	preferences.setBool("EnableAutoJump", options.enableAutoJump);
	if (options.clientLanguage != "") {
		preferences.setString("ClientLanguage", options.clientLanguage);
	}
	preferences.setInt("Framerate", options.framerate);
	preferences.setInt("Resolution", options.resolution);
	preferences.setBool("Fullscreen", options.fullscreen);
	preferences.setBool("Smoothshadows", options.smoothshadows);
	preferences.setInt("BlockShadowSave", this.game.platform.floatToInt(options.blockShadowSave * 100));
	preferences.setBool("EnableBlockShadow", options.enableBlockShadow);
	for (var i = 0; i < 256; i++) {
		var value = options.keys[i];
		var preferencesKey = StringTools.stringAppend(this.game.platform, "Key", this.game.platform.intToString(i));
		if (value != 0) {
			preferences.setInt(preferencesKey, value);
		}
		else {
			preferences.remove(preferencesKey);
		}
	}
	this.game.platform.setPreferences(preferences);
}

ModGuiEscapeMenu.prototype.setEscapeMenuState = function(state) {
	var language = this.game.language;
	this.escapemenustate = state;
	this.widgetsClear();
	if (state == EscapeMenuState.MAIN) {
		this.mainSet();
		this.makeSimpleOptions(this.fontEscapeMenu, 50);
	}
	else if (state == EscapeMenuState.OPTIONS) {
		this.optionsSet();
		this.makeSimpleOptions(this.fontEscapeMenu, 50);
	}
	else if (state == EscapeMenuState.GRAPHICS) {
		this.graphicsSet();
		this.makeSimpleOptions(this.fontEscapeMenu, 50);
	}
	else if (state == EscapeMenuState.OTHER) {
		this.otherSet();
		this.makeSimpleOptions(this.fontEscapeMenu, 50);
	}
	else if (state == EscapeMenuState.KEYS) {
		this.keysSet();
		var fontKeys = FontCi.create("Arial", 12, 0);
		var textheight = 20;
		this.makeSimpleOptions(fontKeys, textheight);
	}
}

ModGuiEscapeMenu.prototype.toggleFont = function() {
	var options = this.game.options;
	options.font++;
	if (options.font >= this.fontsLength) {
		options.font = 0;
	}
	this.game.font = this.fontValues[options.font];
	this.game.updateTextRendererFont();
	for (var i = 0; i < this.game.cachedTextTexturesMax; i++) {
		this.game.cachedTextTextures[i] = null;
	}
}

ModGuiEscapeMenu.prototype.toggleResolution = function() {
	var options = this.game.options;
	options.resolution++;
	var resolutionsCount = new IntRef();
	this.game.platform.getDisplayResolutions(resolutionsCount);
	if (options.resolution >= resolutionsCount.value) {
		options.resolution = 0;
	}
}

ModGuiEscapeMenu.prototype.useFullscreen = function() {
	if (this.game.options.fullscreen) {
		if (!this.changedResolution) {
			this.originalResolutionWidth = this.game.platform.getDisplayResolutionDefault().width;
			this.originalResolutionHeight = this.game.platform.getDisplayResolutionDefault().height;
			this.changedResolution = true;
		}
		this.game.platform.setWindowState(WindowState.FULLSCREEN);
		this.useResolution();
	}
	else {
		this.game.platform.setWindowState(WindowState.NORMAL);
		this.restoreResolution();
	}
}

ModGuiEscapeMenu.prototype.useResolution = function() {
	var options = this.game.options;
	var resolutionsCount = new IntRef();
	var resolutions = this.game.platform.getDisplayResolutions(resolutionsCount);
	if (resolutions == null) {
		return;
	}
	if (options.resolution >= resolutionsCount.value) {
		options.resolution = 0;
	}
	var res = resolutions[options.resolution];
	if (this.game.platform.getWindowState() == WindowState.FULLSCREEN) {
		this.game.platform.changeResolution(res.width, res.height, res.bitsPerPixel, res.refreshRate);
		this.game.platform.setWindowState(WindowState.NORMAL);
		this.game.platform.setWindowState(WindowState.FULLSCREEN);
	}
	else {
	}
}

ModGuiEscapeMenu.prototype.vsyncString = function() {
	if (this.game.eNABLE_LAG == 0) {
		return "Vsync";
	}
	else if (this.game.eNABLE_LAG == 1) {
		return "Unlimited";
	}
	else if (this.game.eNABLE_LAG == 2) {
		return "Lag";
	}
	else
		return null;
}

ModGuiEscapeMenu.prototype.widgetsClear = function() {
	this.widgetsCount = 0;
}

ModGuiEscapeMenu.prototype.keyhelps = function() {
	var n = 1024;
	var helps = new Array(n);
	for (var i = 0; i < n; i++) {
		helps[i] = null;
	}
	var language = this.game.language;
	var count = 0;
	helps[count++] = this.keyHelpCreate(language.keyMoveFoward(), 105);
	helps[count++] = this.keyHelpCreate(language.keyMoveBack(), 101);
	helps[count++] = this.keyHelpCreate(language.keyMoveLeft(), 83);
	helps[count++] = this.keyHelpCreate(language.keyMoveRight(), 86);
	helps[count++] = this.keyHelpCreate(language.keyJump(), 51);
	helps[count++] = this.keyHelpCreate(language.keyShowMaterialSelector(), 84);
	helps[count++] = this.keyHelpCreate(language.keySetSpawnPosition(), 98);
	helps[count++] = this.keyHelpCreate(language.keyRespawn(), 97);
	helps[count++] = this.keyHelpCreate(language.keyReloadWeapon(), 100);
	helps[count++] = this.keyHelpCreate(language.keyToggleFogDistance(), 88);
	helps[count++] = this.keyHelpCreate(this.game.platform.stringFormat(language.keyMoveSpeed(), "1"), 10);
	helps[count++] = this.keyHelpCreate(this.game.platform.stringFormat(language.keyMoveSpeed(), "10"), 11);
	helps[count++] = this.keyHelpCreate(language.keyFreeMove(), 12);
	helps[count++] = this.keyHelpCreate(language.keyThirdPersonCamera(), 14);
	helps[count++] = this.keyHelpCreate(language.keyTextEditor(), 18);
	helps[count++] = this.keyHelpCreate(language.keyFullscreen(), 20);
	helps[count++] = this.keyHelpCreate(language.keyScreenshot(), 21);
	helps[count++] = this.keyHelpCreate(language.keyPlayersList(), 52);
	helps[count++] = this.keyHelpCreate(language.keyChat(), 102);
	helps[count++] = this.keyHelpCreate(language.keyTeamChat(), 107);
	helps[count++] = this.keyHelpCreate(language.keyCraft(), 85);
	helps[count++] = this.keyHelpCreate(language.keyBlockInfo(), 91);
	helps[count++] = this.keyHelpCreate(language.keyUse(), 87);
	helps[count++] = this.keyHelpCreate(language.keyReverseMinecart(), 99);
	return helps;
}

function ModGuiInventory()
{
	this.cellCountInPageX = 0;
	this.cellCountInPageY = 0;
	this.cellCountTotalX = 0;
	this.cellCountTotalY = 0;
	this.cellDrawSize = 0;
	this.scrollLine = 0;
	this.scrollingDownTimeMilliseconds = 0;
	this.scrollingUpTimeMilliseconds = 0;
	this.controller = null;
	this.dataItems = null;
	this.game = null;
	this.inventoryUtil = null;
	this.wearPlaceCells = null;
	this.wearPlaceStart = null;
	this.wearPlaceStart = new Array(5);
	{
		this.wearPlaceStart[0] = PointRef.create(34, 100);
		this.wearPlaceStart[1] = PointRef.create(74, 100);
		this.wearPlaceStart[2] = PointRef.create(194, 100);
		this.wearPlaceStart[3] = PointRef.create(114, 100);
		this.wearPlaceStart[4] = PointRef.create(154, 100);
	}
	this.wearPlaceCells = new Array(5);
	{
		this.wearPlaceCells[0] = PointRef.create(1, 1);
		this.wearPlaceCells[1] = PointRef.create(1, 1);
		this.wearPlaceCells[2] = PointRef.create(1, 1);
		this.wearPlaceCells[3] = PointRef.create(1, 1);
		this.wearPlaceCells[4] = PointRef.create(1, 1);
	}
	this.cellCountInPageX = 12;
	this.cellCountInPageY = 7;
	this.cellCountTotalX = 12;
	this.cellCountTotalY = 42;
	this.cellDrawSize = 40;
}
ModGuiInventory.prototype = new ClientMod();

ModGuiInventory.prototype.activeMaterialCellSize = function() {
	return this.game.platform.floatToInt(48 * this.game.scale());
}

ModGuiInventory.prototype.cellsStartX = function() {
	return 33 + this.inventoryStartX();
}

ModGuiInventory.prototype.cellsStartY = function() {
	return 180 + this.inventoryStartY();
}

ModGuiInventory.prototype.drawItem = function(screenposX, screenposY, item, drawsizeX, drawsizeY) {
	if (item == null) {
		return;
	}
	var sizex = this.dataItems.itemSizeX(item);
	var sizey = this.dataItems.itemSizeY(item);
	if (drawsizeX == 0 || drawsizeX == -1) {
		drawsizeX = this.cellDrawSize * sizex;
		drawsizeY = this.cellDrawSize * sizey;
	}
	if (item.itemClass == 0) {
		if (item.blockId == 0) {
			return;
		}
		this.game.draw2dTexture(this.game.terrainTexture, screenposX, screenposY, drawsizeX, drawsizeY, IntRef.create(this.dataItems.textureIdForInventory()[item.blockId]), this.game.texturesPacked(), Game.colorFromArgb(255, 255, 255, 255), false);
		if (item.blockCount > 1) {
			var font = new FontCi();
			font.size = 8;
			this.game.draw2dText(this.game.platform.intToString(item.blockCount), font, screenposX, screenposY, null, false);
		}
	}
	else {
		this.game.draw2dBitmapFile(this.dataItems.itemGraphics(item), screenposX, screenposY, drawsizeX, drawsizeY);
	}
}

ModGuiInventory.prototype.drawItemInfo = function(screenposX, screenposY, item) {
	var sizex = this.dataItems.itemSizeX(item);
	var sizey = this.dataItems.itemSizeY(item);
	var tw = new IntRef();
	var th = new IntRef();
	var one = 1;
	var font = new FontCi();
	font.size = 10;
	this.game.platform.textSize(this.dataItems.itemInfo(item), font, tw, th);
	tw.value += 6;
	th.value += 4;
	var w = this.game.platform.floatToInt(tw.value + this.cellDrawSize * sizex);
	var h = this.game.platform.floatToInt(th.value < this.cellDrawSize * sizey ? this.cellDrawSize * sizey + 4 : th.value);
	if (screenposX < w + 20) {
		screenposX = w + 20;
	}
	if (screenposY < h + 20) {
		screenposY = h + 20;
	}
	if (screenposX > this.game.width() - (w + 20)) {
		screenposX = this.game.width() - (w + 20);
	}
	if (screenposY > this.game.height() - (h + 20)) {
		screenposY = this.game.height() - (h + 20);
	}
	this.game.draw2dTexture(this.game.whiteTexture(), screenposX - w, screenposY - h, w, h, null, 0, Game.colorFromArgb(255, 0, 0, 0), false);
	this.game.draw2dTexture(this.game.whiteTexture(), screenposX - w + 2, screenposY - h + 2, w - 4, h - 4, null, 0, Game.colorFromArgb(255, 105, 105, 105), false);
	this.game.draw2dText(this.dataItems.itemInfo(item), font, screenposX - tw.value + 4, screenposY - h + 2, null, false);
	var item2 = new Packet_Item();
	item2.blockId = item.blockId;
	this.drawItem(screenposX - w + 2, screenposY - h + 2, item2, 0, 0);
}

ModGuiInventory.prototype.drawMaterialSelector = function() {
	this.game.draw2dBitmapFile("materials.png", this.materialSelectorBackgroundStartX(), this.materialSelectorBackgroundStartY(), this.game.platform.floatToInt(1024 * this.game.scale()), this.game.platform.floatToInt(128 * this.game.scale()));
	var materialSelectorStartX_ = this.materialSelectorStartX();
	var materialSelectorStartY_ = this.materialSelectorStartY();
	for (var i = 0; i < 10; i++) {
		var item = this.game.d_Inventory.rightHand[i];
		if (item != null) {
			this.drawItem(materialSelectorStartX_ + i * this.activeMaterialCellSize(), materialSelectorStartY_, item, this.activeMaterialCellSize(), this.activeMaterialCellSize());
		}
	}
	this.game.draw2dBitmapFile("activematerial.png", this.materialSelectorStartX() + this.activeMaterialCellSize() * this.game.activeMaterial, this.materialSelectorStartY(), Math.floor(this.activeMaterialCellSize() * 64 / 48), Math.floor(this.activeMaterialCellSize() * 64 / 48));
}

ModGuiInventory.prototype.getItem = function(inventory, x, y) {
	for (var i = 0; i < inventory.itemsCount; i++) {
		if (inventory.items[i].x == x && inventory.items[i].y == y) {
			return inventory.items[i].value_;
		}
	}
	return null;
}

ModGuiInventory.prototype.inventoryStartX = function() {
	return Math.floor(this.game.width() / 2) - 280;
}

ModGuiInventory.prototype.inventoryStartY = function() {
	return Math.floor(this.game.height() / 2) - 300;
}

ModGuiInventory.prototype.isMouseOverCells = function() {
	return this.selectedCellOrScrollbar(this.game.mouseCurrentX, this.game.mouseCurrentY);
}

ModGuiInventory.prototype.materialSelectorBackgroundStartX = function() {
	return this.game.platform.floatToInt(Math.floor(this.game.width() / 2) - 256 * this.game.scale());
}

ModGuiInventory.prototype.materialSelectorBackgroundStartY = function() {
	return this.game.platform.floatToInt(this.game.height() - 90 * this.game.scale());
}

ModGuiInventory.prototype.materialSelectorStartX = function() {
	return this.game.platform.floatToInt(this.materialSelectorBackgroundStartX() + 17 * this.game.scale());
}

ModGuiInventory.prototype.materialSelectorStartY = function() {
	return this.game.platform.floatToInt(this.materialSelectorBackgroundStartY() + 17 * this.game.scale());
}

ModGuiInventory.prototype.onKeyPress = function(game_, args) {
	if (this.game.guistate != GuiState.INVENTORY) {
		return;
	}
	var keyChar = args.getKeyChar();
	if (keyChar == 49) {
		this.game.activeMaterial = 0;
	}
	if (keyChar == 50) {
		this.game.activeMaterial = 1;
	}
	if (keyChar == 51) {
		this.game.activeMaterial = 2;
	}
	if (keyChar == 52) {
		this.game.activeMaterial = 3;
	}
	if (keyChar == 53) {
		this.game.activeMaterial = 4;
	}
	if (keyChar == 54) {
		this.game.activeMaterial = 5;
	}
	if (keyChar == 55) {
		this.game.activeMaterial = 6;
	}
	if (keyChar == 56) {
		this.game.activeMaterial = 7;
	}
	if (keyChar == 57) {
		this.game.activeMaterial = 8;
	}
	if (keyChar == 48) {
		this.game.activeMaterial = 9;
	}
}

ModGuiInventory.prototype.onMouseDown = function(game_, args) {
	if (this.game.guistate != GuiState.INVENTORY) {
		return;
	}
	var scaledMouse = PointRef.create(args.getX(), args.getY());
	if (this.selectedMaterialSelectorSlot(scaledMouse) != null) {
		this.game.activeMaterial = this.selectedMaterialSelectorSlot(scaledMouse).value;
		{
			var p = new Packet_InventoryPosition();
			p.type = 2;
			p.materialId = this.game.activeMaterial;
			this.controller.inventoryClick(p);
		}
		args.setHandled(true);
		return;
	}
	if (this.game.guistate != GuiState.INVENTORY) {
		return;
	}
	var cellInPage = this.selectedCell(scaledMouse);
	if (cellInPage != null) {
		if (args.getButton() == 0) {
			var p = new Packet_InventoryPosition();
			p.type = 0;
			p.areaX = cellInPage.x;
			p.areaY = cellInPage.y + this.scrollLine;
			this.controller.inventoryClick(p);
			args.setHandled(true);
			return;
		}
		else {
			{
				var p = new Packet_InventoryPosition();
				p.type = 0;
				p.areaX = cellInPage.x;
				p.areaY = cellInPage.y + this.scrollLine;
				this.controller.inventoryClick(p);
			}
			{
				var p = new Packet_InventoryPosition();
				p.type = 3;
				p.wearPlace = 0;
				p.activeMaterial = this.game.activeMaterial;
				this.controller.inventoryClick(p);
			}
			{
				var p = new Packet_InventoryPosition();
				p.type = 0;
				p.areaX = cellInPage.x;
				p.areaY = cellInPage.y + this.scrollLine;
				this.controller.inventoryClick(p);
			}
		}
		if (this.game.guistate == GuiState.INVENTORY) {
			args.setHandled(true);
			return;
		}
	}
	if (this.selectedWearPlace(scaledMouse) != null) {
		var p = new Packet_InventoryPosition();
		p.type = 3;
		p.wearPlace = this.selectedWearPlace(scaledMouse).value;
		p.activeMaterial = this.game.activeMaterial;
		this.controller.inventoryClick(p);
		args.setHandled(true);
		return;
	}
	if (scaledMouse.x >= this.scrollUpButtonX() && scaledMouse.x < this.scrollUpButtonX() + this.scrollButtonSize() && scaledMouse.y >= this.scrollUpButtonY() && scaledMouse.y < this.scrollUpButtonY() + this.scrollButtonSize()) {
		this.scrollUp();
		this.scrollingUpTimeMilliseconds = this.game.platform.timeMillisecondsFromStart();
		args.setHandled(true);
		return;
	}
	if (scaledMouse.x >= this.scrollDownButtonX() && scaledMouse.x < this.scrollDownButtonX() + this.scrollButtonSize() && scaledMouse.y >= this.scrollDownButtonY() && scaledMouse.y < this.scrollDownButtonY() + this.scrollButtonSize()) {
		this.scrollDown();
		this.scrollingDownTimeMilliseconds = this.game.platform.timeMillisecondsFromStart();
		args.setHandled(true);
		return;
	}
	this.game.guiStateBackToGame();
	return;
}

ModGuiInventory.prototype.onMouseUp = function(game_, args) {
	if (this.game.guistate != GuiState.INVENTORY) {
		return;
	}
	this.scrollingUpTimeMilliseconds = 0;
	this.scrollingDownTimeMilliseconds = 0;
}

ModGuiInventory.prototype.onMouseWheelChanged = function(game_, args) {
	var delta = args.getDeltaPrecise();
	if ((game_.guistate == GuiState.NORMAL || game_.guistate == GuiState.INVENTORY && !this.isMouseOverCells()) && !game_.keyboardState[game_.getKey(1)]) {
		game_.activeMaterial -= game_.platform.floatToInt(delta);
		game_.activeMaterial = game_.activeMaterial % 10;
		while (game_.activeMaterial < 0) {
			game_.activeMaterial += 10;
		}
	}
	if (this.isMouseOverCells() && this.game.guistate == GuiState.INVENTORY) {
		if (delta > 0) {
			this.scrollUp();
		}
		if (delta < 0) {
			this.scrollDown();
		}
	}
}

ModGuiInventory.prototype.onNewFrameDraw2d = function(game_, deltaTime) {
	this.game = game_;
	if (this.dataItems == null) {
		this.dataItems = new GameDataItemsClient();
		this.dataItems.game = game_;
		this.controller = ClientInventoryController.create(game_);
		this.inventoryUtil = this.game.d_InventoryUtil;
	}
	if (this.game.guistate == GuiState.MAP_LOADING) {
		return;
	}
	this.drawMaterialSelector();
	if (this.game.guistate != GuiState.INVENTORY) {
		return;
	}
	if (this.scrollingUpTimeMilliseconds != 0 && this.game.platform.timeMillisecondsFromStart() - this.scrollingUpTimeMilliseconds > 250) {
		this.scrollingUpTimeMilliseconds = this.game.platform.timeMillisecondsFromStart();
		this.scrollUp();
	}
	if (this.scrollingDownTimeMilliseconds != 0 && this.game.platform.timeMillisecondsFromStart() - this.scrollingDownTimeMilliseconds > 250) {
		this.scrollingDownTimeMilliseconds = this.game.platform.timeMillisecondsFromStart();
		this.scrollDown();
	}
	var scaledMouse = PointRef.create(this.game.mouseCurrentX, this.game.mouseCurrentY);
	this.game.draw2dBitmapFile("inventory.png", this.inventoryStartX(), this.inventoryStartY(), 1024, 1024);
	for (var i = 0; i < this.game.d_Inventory.itemsCount; i++) {
		var k = this.game.d_Inventory.items[i];
		if (k == null) {
			continue;
		}
		var screeny = k.y - this.scrollLine;
		if (screeny >= 0 && screeny < this.cellCountInPageY) {
			this.drawItem(this.cellsStartX() + k.x * this.cellDrawSize, this.cellsStartY() + screeny * this.cellDrawSize, k.value_, 0, 0);
		}
	}
	if (this.game.d_Inventory.dragDropItem != null) {
		var selectedInPage = this.selectedCell(scaledMouse);
		if (selectedInPage != null) {
			var x = selectedInPage.x * this.cellDrawSize + this.cellsStartX();
			var y = selectedInPage.y * this.cellDrawSize + this.cellsStartY();
			var sizex = this.dataItems.itemSizeX(this.game.d_Inventory.dragDropItem);
			var sizey = this.dataItems.itemSizeY(this.game.d_Inventory.dragDropItem);
			if (selectedInPage.x + sizex <= this.cellCountInPageX && selectedInPage.y + sizey <= this.cellCountInPageY) {
				var c;
				var itemsAtAreaCount = new IntRef();
				var itemsAtArea = this.inventoryUtil.itemsAtArea(selectedInPage.x, selectedInPage.y + this.scrollLine, sizex, sizey, itemsAtAreaCount);
				if (itemsAtArea == null || itemsAtAreaCount.value > 1) {
					c = Game.colorFromArgb(100, 255, 0, 0);
				}
				else {
					c = Game.colorFromArgb(100, 0, 255, 0);
				}
				this.game.draw2dTexture(this.game.whiteTexture(), x, y, this.cellDrawSize * sizex, this.cellDrawSize * sizey, null, 0, c, false);
			}
		}
		var selectedWear = this.selectedWearPlace(scaledMouse);
		if (selectedWear != null) {
			var p = PointRef.create(this.wearPlaceStart[selectedWear.value].x + this.inventoryStartX(), this.wearPlaceStart[selectedWear.value].y + this.inventoryStartY());
			var size = this.wearPlaceCells[selectedWear.value];
			var c;
			var itemsAtArea = this.inventoryUtil.itemAtWearPlace(selectedWear.value, this.game.activeMaterial);
			if (!this.dataItems.canWear(selectedWear.value, this.game.d_Inventory.dragDropItem)) {
				c = Game.colorFromArgb(100, 255, 0, 0);
			}
			else {
				c = Game.colorFromArgb(100, 0, 255, 0);
			}
			this.game.draw2dTexture(this.game.whiteTexture(), p.x, p.y, this.cellDrawSize * size.x, this.cellDrawSize * size.y, null, 0, c, false);
		}
	}
	this.drawMaterialSelector();
	this.drawItem(this.wearPlaceStart[0].x + this.inventoryStartX(), this.wearPlaceStart[0].y + this.inventoryStartY(), this.game.d_Inventory.rightHand[this.game.activeMaterial], 0, 0);
	this.drawItem(this.wearPlaceStart[1].x + this.inventoryStartX(), this.wearPlaceStart[1].y + this.inventoryStartY(), this.game.d_Inventory.mainArmor, 0, 0);
	this.drawItem(this.wearPlaceStart[2].x + this.inventoryStartX(), this.wearPlaceStart[2].y + this.inventoryStartY(), this.game.d_Inventory.boots, 0, 0);
	this.drawItem(this.wearPlaceStart[3].x + this.inventoryStartX(), this.wearPlaceStart[3].y + this.inventoryStartY(), this.game.d_Inventory.helmet, 0, 0);
	this.drawItem(this.wearPlaceStart[4].x + this.inventoryStartX(), this.wearPlaceStart[4].y + this.inventoryStartY(), this.game.d_Inventory.gauntlet, 0, 0);
	if (this.selectedCell(scaledMouse) != null) {
		var selected = this.selectedCell(scaledMouse);
		selected.y += this.scrollLine;
		var itemAtCell = this.inventoryUtil.itemAtCell(selected);
		if (itemAtCell != null) {
			var item = this.getItem(this.game.d_Inventory, itemAtCell.x, itemAtCell.y);
			if (item != null) {
				var x = selected.x * this.cellDrawSize + this.cellsStartX();
				var y = selected.y * this.cellDrawSize + this.cellsStartY();
				this.drawItemInfo(scaledMouse.x, scaledMouse.y, item);
			}
		}
	}
	if (this.selectedWearPlace(scaledMouse) != null) {
		var selected = this.selectedWearPlace(scaledMouse).value;
		var itemAtWearPlace = this.inventoryUtil.itemAtWearPlace(selected, this.game.activeMaterial);
		if (itemAtWearPlace != null) {
			this.drawItemInfo(scaledMouse.x, scaledMouse.y, itemAtWearPlace);
		}
	}
	if (this.selectedMaterialSelectorSlot(scaledMouse) != null) {
		var selected = this.selectedMaterialSelectorSlot(scaledMouse).value;
		var item = this.game.d_Inventory.rightHand[selected];
		if (item != null) {
			this.drawItemInfo(scaledMouse.x, scaledMouse.y, item);
		}
	}
	if (this.game.d_Inventory.dragDropItem != null) {
		this.drawItem(scaledMouse.x, scaledMouse.y, this.game.d_Inventory.dragDropItem, 0, 0);
	}
}

ModGuiInventory.prototype.onTouchStart = function(game_, e) {
	var args = new MouseEventArgs();
	args.setX(e.getX());
	args.setY(e.getY());
	this.onMouseDown(game_, args);
	e.setHandled(args.getHandled());
}

ModGuiInventory.prototype.scrollButtonSize = function() {
	return this.cellDrawSize;
}

ModGuiInventory.prototype.scrollDown = function() {
	this.scrollLine++;
	var max = this.cellCountTotalY - this.cellCountInPageY;
	if (this.scrollLine >= max) {
		this.scrollLine = max;
	}
}

ModGuiInventory.prototype.scrollDownButtonX = function() {
	return this.cellsStartX() + this.cellCountInPageX * this.cellDrawSize;
}

ModGuiInventory.prototype.scrollDownButtonY = function() {
	return this.cellsStartY() + (this.cellCountInPageY - 1) * this.cellDrawSize;
}

ModGuiInventory.prototype.scrollUp = function() {
	this.scrollLine--;
	if (this.scrollLine < 0) {
		this.scrollLine = 0;
	}
}

ModGuiInventory.prototype.scrollUpButtonX = function() {
	return this.cellsStartX() + this.cellCountInPageX * this.cellDrawSize;
}

ModGuiInventory.prototype.scrollUpButtonY = function() {
	return this.cellsStartY();
}

ModGuiInventory.prototype.selectedCell = function(scaledMouse) {
	if (scaledMouse.x < this.cellsStartX() || scaledMouse.y < this.cellsStartY() || scaledMouse.x > this.cellsStartX() + this.cellCountInPageX * this.cellDrawSize || scaledMouse.y > this.cellsStartY() + this.cellCountInPageY * this.cellDrawSize) {
		return null;
	}
	var cell = PointRef.create(Math.floor((scaledMouse.x - this.cellsStartX()) / this.cellDrawSize), Math.floor((scaledMouse.y - this.cellsStartY()) / this.cellDrawSize));
	return cell;
}

ModGuiInventory.prototype.selectedCellOrScrollbar = function(scaledMouseX, scaledMouseY) {
	if (scaledMouseX < this.cellsStartX() || scaledMouseY < this.cellsStartY() || scaledMouseX > this.cellsStartX() + (this.cellCountInPageX + 1) * this.cellDrawSize || scaledMouseY > this.cellsStartY() + this.cellCountInPageY * this.cellDrawSize) {
		return false;
	}
	return true;
}

ModGuiInventory.prototype.selectedMaterialSelectorSlot = function(scaledMouse) {
	if (scaledMouse.x >= this.materialSelectorStartX() && scaledMouse.y >= this.materialSelectorStartY() && scaledMouse.x < this.materialSelectorStartX() + 10 * this.activeMaterialCellSize() && scaledMouse.y < this.materialSelectorStartY() + 10 * this.activeMaterialCellSize()) {
		return IntRef.create(Math.floor((scaledMouse.x - this.materialSelectorStartX()) / this.activeMaterialCellSize()));
	}
	return null;
}

ModGuiInventory.prototype.selectedWearPlace = function(scaledMouse) {
	for (var i = 0; i < 5; i++) {
		var p = this.wearPlaceStart[i];
		p.x += this.inventoryStartX();
		p.y += this.inventoryStartY();
		var cells = this.wearPlaceCells[i];
		if (scaledMouse.x >= p.x && scaledMouse.y >= p.y && scaledMouse.x < p.x + cells.x * this.cellDrawSize && scaledMouse.y < p.y + cells.y * this.cellDrawSize) {
			return IntRef.create(i);
		}
	}
	return null;
}

function ModGuiMapLoading()
{
	this.height = 0;
	this.width = 0;
	this.backgroundH = 0;
	this.backgroundW = 0;
}
ModGuiMapLoading.prototype = new ClientMod();

ModGuiMapLoading.prototype.drawBackground = function(game) {
	this.backgroundW = 512;
	this.backgroundH = 512;
	var countX = game.platform.floatToInt(Math.floor(this.width / this.backgroundW)) + 1;
	var countY = game.platform.floatToInt(Math.floor(this.height / this.backgroundH)) + 1;
	for (var x = 0; x < countX; x++) {
		for (var y = 0; y < countY; y++) {
			game.draw2dTexture(game.getTexture("background.png"), x * this.backgroundW, y * this.backgroundH, this.backgroundW, this.backgroundH, null, 0, Game.colorFromArgb(255, 255, 255, 255), false);
		}
	}
}

ModGuiMapLoading.prototype.onNewFrameDraw2d = function(game, deltaTime) {
	if (game.guistate != GuiState.MAP_LOADING) {
		return;
	}
	var platform = game.platform;
	var one = 1;
	this.width = platform.getCanvasWidth();
	this.height = platform.getCanvasHeight();
	this.drawBackground(game);
	var connecting = game.language.connecting();
	if (game.issingleplayer && !platform.singlePlayerServerLoaded()) {
		connecting = "Starting game...";
	}
	if (game.maploadingprogress.progressStatus != null) {
		connecting = game.maploadingprogress.progressStatus;
	}
	if (game.invalidVersionDrawMessage != null) {
		game.draw2dText(game.invalidVersionDrawMessage, game.fontMapLoading, game.xcenter(game.textSizeWidth(game.invalidVersionDrawMessage, game.fontMapLoading)), Math.floor(this.height / 2) - 50, null, false);
		var connect = "Click to connect";
		game.draw2dText(connect, game.fontMapLoading, game.xcenter(game.textSizeWidth(connect, game.fontMapLoading)), Math.floor(this.height / 2) + 50, null, false);
		return;
	}
	var serverNameWidth = new IntRef();
	var serverNameHeight = new IntRef();
	platform.textSize(game.serverInfo.serverName, game.fontMapLoading, serverNameWidth, serverNameHeight);
	game.draw2dText(game.serverInfo.serverName, game.fontMapLoading, game.xcenter(serverNameWidth.value), Math.floor(this.height / 2) - 150, null, false);
	if (game.serverInfo.serverMotd != null) {
		var serverMotdWidth = new IntRef();
		var serverMotdHeight = new IntRef();
		platform.textSize(game.serverInfo.serverMotd, game.fontMapLoading, serverMotdWidth, serverMotdHeight);
		game.draw2dText(game.serverInfo.serverMotd, game.fontMapLoading, game.xcenter(serverMotdWidth.value), Math.floor(this.height / 2) - 100, null, false);
	}
	var connectingWidth = new IntRef();
	var connectingHeight = new IntRef();
	platform.textSize(connecting, game.fontMapLoading, connectingWidth, connectingHeight);
	game.draw2dText(connecting, game.fontMapLoading, game.xcenter(connectingWidth.value), Math.floor(this.height / 2) - 50, null, false);
	var progress = platform.stringFormat(game.language.connectingProgressPercent(), platform.intToString(game.maploadingprogress.progressPercent));
	var progress1 = platform.stringFormat(game.language.connectingProgressKilobytes(), platform.intToString(Math.floor(game.maploadingprogress.progressBytes / 1024)));
	if (game.maploadingprogress.progressPercent > 0) {
		var progressWidth = new IntRef();
		var progressHeight = new IntRef();
		platform.textSize(progress, game.fontMapLoading, progressWidth, progressHeight);
		game.draw2dText(progress, game.fontMapLoading, game.xcenter(progressWidth.value), Math.floor(this.height / 2) - 20, null, false);
		var progress1Width = new IntRef();
		var progress1Height = new IntRef();
		platform.textSize(progress1, game.fontMapLoading, progress1Width, progress1Height);
		game.draw2dText(progress1, game.fontMapLoading, game.xcenter(progress1Width.value), Math.floor(this.height / 2) + 10, null, false);
		var progressratio = (one * game.maploadingprogress.progressPercent) / (100);
		var sizex = 400;
		var sizey = 40;
		game.draw2dTexture(game.whiteTexture(), game.xcenter(sizex), Math.floor(this.height / 2) + 70, sizex, sizey, null, 0, Game.colorFromArgb(255, 0, 0, 0), false);
		var red = Game.colorFromArgb(255, 255, 0, 0);
		var yellow = Game.colorFromArgb(255, 255, 255, 0);
		var green = Game.colorFromArgb(255, 0, 255, 0);
		var colors = new Int32Array(new ArrayBuffer(3 << 2));
		colors[0] = red;
		colors[1] = yellow;
		colors[2] = green;
		var c = InterpolationCi.interpolateColor(platform, progressratio, colors, 3);
		game.draw2dTexture(game.whiteTexture(), game.xcenter(sizex), Math.floor(this.height / 2) + 70, progressratio * sizex, sizey, null, 0, c, false);
	}
}

function ModGuiPlayerStats()
{
	this.healthPosX = 0;
	this.healthPosY = 0;
	this.oxygenPosX = 0;
	this.oxygenPosY = 0;
}
ModGuiPlayerStats.prototype = new ClientMod();

ModGuiPlayerStats.prototype.drawPlayerHealth = function(game) {
	if (game.playerStats != null) {
		var progress = (game.one * game.playerStats.currentHealth) / (game.playerStats.maxHealth);
		game.draw2dTexture(game.getTexture("ui_bar_background.png"), this.healthPosX, this.healthPosY, 220, 32, null, 0, Game.colorFromArgb(255, 255, 255, 255), false);
		game.draw2dTexturePart(game.getTexture("ui_bar_inner.png"), progress, 1, this.healthPosX, this.healthPosY, progress * 220, 32, Game.colorFromArgb(255, 255, 0, 0), false);
	}
}

ModGuiPlayerStats.prototype.drawPlayerOxygen = function(game) {
	if (game.playerStats != null) {
		if (game.playerStats.currentOxygen < game.playerStats.maxOxygen) {
			var progress = (game.one * game.playerStats.currentOxygen) / (game.playerStats.maxOxygen);
			game.draw2dTexture(game.getTexture("ui_bar_background.png"), this.oxygenPosX, this.oxygenPosY, 220, 32, null, 0, Game.colorFromArgb(255, 255, 255, 255), false);
			game.draw2dTexturePart(game.getTexture("ui_bar_inner.png"), progress, 1, this.oxygenPosX, this.oxygenPosY, progress * 220, 32, Game.colorFromArgb(255, 0, 0, 255), false);
		}
	}
}

ModGuiPlayerStats.prototype.onNewFrameDraw2d = function(game, deltaTime) {
	this.healthPosX = Math.floor(game.width() / 2) - 220 - 20;
	this.healthPosY = game.height() - 122;
	this.oxygenPosX = Math.floor(game.width() / 2) + 20;
	this.oxygenPosY = game.height() - 122;
	if (game.guistate != GuiState.MAP_LOADING) {
		this.drawPlayerHealth(game);
		this.drawPlayerOxygen(game);
	}
}

function ModGuiTextEditor()
{
	this.buffer = null;
	this.charSize = 0;
	this.cursorColumn = 0;
	this.cursorLine = 0;
	this.font = null;
	this.startX = 0;
	this.startY = 0;
	this.visible = false;
	this.buffer = new Array(128);
	for (var i = 0; i < 128; i++) {
		this.buffer[i] = new Int32Array(new ArrayBuffer(80 << 2));
	}
	this.startX = 100;
	this.startY = 100;
	this.charSize = 12;
	this.font = new FontCi();
	this.font.family = "Courier New";
	this.font.size = 12;
}
ModGuiTextEditor.prototype = new GameScreen();

ModGuiTextEditor.prototype.bufferToString = function() {
	var s = "";
	for (var i = 0; i < 128; i++) {
		var line = this.lineToString(this.buffer[i]);
		s = StringTools.stringAppend(this.game.platform, s, line);
	}
	return s;
}

ModGuiTextEditor.prototype.lineLength = function(line) {
	for (var i = 0; i < 80; i++) {
		if (line[i] == 0) {
			return i;
		}
	}
	return 80;
}

ModGuiTextEditor.prototype.lineToString = function(line) {
	if (line == null) {
		return "";
	}
	return this.game.platform.charArrayToString(line, this.lineLength(line));
}

ModGuiTextEditor.prototype.onKeyDown = function(game_, e) {
	if (e.getKeyCode() == this.game.getKey(18)) {
		this.visible = !this.visible;
	}
	if (!this.visible) {
		return;
	}
	if (e.getKeyCode() == 50) {
		this.visible = false;
	}
	if (e.getKeyCode() == 47) {
		this.cursorColumn--;
	}
	if (e.getKeyCode() == 48) {
		this.cursorColumn++;
	}
	if (e.getKeyCode() == 45) {
		this.cursorLine--;
	}
	if (e.getKeyCode() == 46) {
		this.cursorLine++;
	}
	if (e.getKeyCode() == 53) {
		this.cursorColumn--;
		e.setKeyCode(55);
	}
	if (this.cursorColumn < 0) {
		this.cursorColumn = 0;
	}
	if (this.cursorLine < 0) {
		this.cursorLine = 0;
	}
	if (this.cursorColumn >= 80) {
		this.cursorColumn = 80;
	}
	if (this.cursorLine > 128) {
		this.cursorLine = 128;
	}
	if (this.cursorColumn > this.lineLength(this.buffer[this.cursorLine])) {
		this.cursorColumn = this.lineLength(this.buffer[this.cursorLine]);
	}
	if (e.getKeyCode() == 55) {
		for (var i = this.cursorColumn; i < 79; i++) {
			this.buffer[this.cursorLine][i] = this.buffer[this.cursorLine][i + 1];
		}
	}
	e.setHandled(true);
}

ModGuiTextEditor.prototype.onKeyPress = function(game_, e) {
	if (!this.visible) {
		return;
	}
	if (e.getKeyChar() == 8) {
		return;
	}
	for (var i = 79; i > this.cursorColumn; i--) {
		this.buffer[this.cursorLine][i] = this.buffer[this.cursorLine][i - 1];
	}
	this.buffer[this.cursorLine][this.cursorColumn] = e.getKeyChar();
	this.cursorColumn++;
	e.setHandled(true);
}

ModGuiTextEditor.prototype.onNewFrameDraw2d = function(game, deltaTime) {
	var dt = deltaTime;
	if (!this.visible) {
		return;
	}
	game.draw2dTexture(game.whiteTexture(), this.startX, this.startY, 80 * this.charSize, 128 * this.charSize, null, 0, Game.colorFromArgb(255, 100, 100, 100), false);
	for (var i = 0; i < 128; i++) {
		game.draw2dText(this.lineToString(this.buffer[i]), this.font, this.startX, this.startY + this.charSize * i, null, false);
	}
	var spaces = new Int32Array(new ArrayBuffer(80 << 2));
	for (var i = 0; i < 80; i++) {
		spaces[i] = 32;
	}
	spaces[this.cursorColumn] = 95;
	var spacesString = game.platform.charArrayToString(spaces, this.cursorColumn + 1);
	game.draw2dText(spacesString, this.font, this.startX, this.startY + this.cursorLine * this.charSize, null, false);
}

function ModGuiTouchButtons()
{
	this.buttonCamera = null;
	this.buttonInventory = null;
	this.buttonMenu = null;
	this.buttonTalk = null;
	this.fontGuiTouchButtons = null;
	this.touchButtonsEnabled = false;
	this.touchIdMove = 0;
	this.touchIdRotate = 0;
	this.touchMoveStartX = 0;
	this.touchMoveStartY = 0;
	this.touchRotateStartX = 0;
	this.touchRotateStartY = 0;
	this.touchButtonsEnabled = false;
	this.buttonMenu = new MenuWidget();
	this.buttonMenu.image = "TouchMenu.png";
	this.buttonInventory = new MenuWidget();
	this.buttonInventory.image = "TouchInventory.png";
	this.buttonTalk = new MenuWidget();
	this.buttonTalk.image = "TouchTalk.png";
	this.buttonCamera = new MenuWidget();
	this.buttonCamera.image = "TouchCamera.png";
	this.widgets[0] = this.buttonMenu;
	this.widgets[1] = this.buttonInventory;
	this.widgets[2] = this.buttonTalk;
	this.widgets[3] = this.buttonCamera;
	this.touchIdMove = -1;
	this.touchIdRotate = -1;
	this.fontGuiTouchButtons = new FontCi();
}
ModGuiTouchButtons.prototype = new GameScreen();

ModGuiTouchButtons.prototype.onButton = function(w) {
	if (w == this.buttonMenu) {
		this.game.showEscapeMenu();
	}
	if (w == this.buttonInventory) {
		this.game.showInventory();
	}
	if (w == this.buttonTalk) {
		if (this.game.guiTyping == TypingState.NONE) {
			this.game.startTyping();
			this.game.platform.showKeyboard(true);
		}
		else {
			this.game.stopTyping();
			this.game.platform.showKeyboard(false);
		}
	}
	if (w == this.buttonCamera) {
		this.game.cameraChange();
	}
}

ModGuiTouchButtons.prototype.onNewFrameDraw2d = function(game_, deltaTime) {
	if (!this.touchButtonsEnabled) {
		return;
	}
	this.game = game_;
	var dt = deltaTime;
	var buttonSize = 80;
	if (this.game.guistate != GuiState.NORMAL) {
		return;
	}
	this.buttonMenu.x = 16 * this.scale();
	this.buttonMenu.y = 16 * this.scale();
	this.buttonMenu.sizex = buttonSize * this.scale();
	this.buttonMenu.sizey = buttonSize * this.scale();
	this.buttonInventory.x = 16 * this.scale();
	this.buttonInventory.y = 112 * this.scale();
	this.buttonInventory.sizex = buttonSize * this.scale();
	this.buttonInventory.sizey = buttonSize * this.scale();
	this.buttonTalk.x = 16 * this.scale();
	this.buttonTalk.y = 208 * this.scale();
	this.buttonTalk.sizex = buttonSize * this.scale();
	this.buttonTalk.sizey = buttonSize * this.scale();
	this.buttonCamera.x = 16 * this.scale();
	this.buttonCamera.y = 304 * this.scale();
	this.buttonCamera.sizex = buttonSize * this.scale();
	this.buttonCamera.sizey = buttonSize * this.scale();
	if (!this.game.platform.isMousePointerLocked()) {
		if (this.game.cameratype == CameraType.FPP || this.game.cameratype == CameraType.TPP) {
			this.fontGuiTouchButtons.size = this.scale() * 50;
			this.game.draw2dText("Move", this.fontGuiTouchButtons, Math.floor(this.game.width() * 5 / 100), Math.floor(this.game.height() * 85 / 100), null, false);
			this.game.draw2dText("Look", this.fontGuiTouchButtons, Math.floor(this.game.width() * 80 / 100), Math.floor(this.game.height() * 85 / 100), null, false);
		}
		this.drawWidgets();
	}
}

ModGuiTouchButtons.prototype.onTouchEnd = function(game_, e) {
	this.screenOnTouchEnd(e);
	if (e.getHandled()) {
		return;
	}
	if (e.getId() == this.touchIdMove) {
		this.touchIdMove = -1;
		this.game.touchMoveDx = 0;
		this.game.touchMoveDy = 0;
	}
	if (e.getId() == this.touchIdRotate) {
		this.touchIdRotate = -1;
		this.game.touchOrientationDx = 0;
		this.game.touchOrientationDy = 0;
	}
}

ModGuiTouchButtons.prototype.onTouchMove = function(game, e) {
	var one = 1;
	if (e.getId() == this.touchIdMove) {
		var range = (game.width() * one) / (20);
		game.touchMoveDx = e.getX() - this.touchMoveStartX;
		game.touchMoveDy = -(e.getY() - 1 - this.touchMoveStartY);
		var length = game.length(game.touchMoveDx, game.touchMoveDy, 0);
		if (e.getY() < Math.floor(game.height() * 50 / 100)) {
			game.touchMoveDx = 0;
			game.touchMoveDy = 1;
		}
		else {
			if (length > 0) {
				game.touchMoveDx /= length;
				game.touchMoveDy /= length;
			}
		}
	}
	if (e.getId() == this.touchIdRotate) {
		game.touchOrientationDx += (e.getX() - this.touchRotateStartX) / ((game.width() * one) / (40));
		game.touchOrientationDy += (e.getY() - this.touchRotateStartY) / ((game.width() * one) / (40));
		this.touchRotateStartX = e.getX();
		this.touchRotateStartY = e.getY();
	}
}

ModGuiTouchButtons.prototype.onTouchStart = function(game_, e) {
	this.touchButtonsEnabled = true;
	this.screenOnTouchStart(e);
	if (e.getHandled()) {
		return;
	}
	if (e.getX() <= Math.floor(this.game.width() / 2)) {
		if (this.touchIdMove == -1) {
			this.touchIdMove = e.getId();
			this.touchMoveStartX = e.getX();
			this.touchMoveStartY = e.getY();
			this.game.touchMoveDx = 0;
			if (e.getY() < Math.floor(this.game.height() * 50 / 100)) {
				this.game.touchMoveDy = 1;
			}
			else {
				this.game.touchMoveDy = 0;
			}
		}
	}
	if (this.touchIdMove != -1 && e.getId() != this.touchIdMove || e.getX() > Math.floor(this.game.width() / 2)) {
		if (this.touchIdRotate == -1) {
			this.touchIdRotate = e.getId();
			this.touchRotateStartX = e.getX();
			this.touchRotateStartY = e.getY();
		}
	}
}

ModGuiTouchButtons.prototype.scale = function() {
	return this.game.scale();
}

function ModInterpolatePositions()
{
}
ModInterpolatePositions.prototype = new ClientMod();

ModInterpolatePositions.prototype.interpolatePositions = function(game, dt) {
	for (var i = 0; i < game.entitiesCount; i++) {
		var e = game.entities[i];
		if (e == null) {
			continue;
		}
		if (e.networkPosition == null) {
			continue;
		}
		if (i == game.localPlayerId) {
			continue;
		}
		if (!e.networkPosition.positionLoaded) {
			continue;
		}
		if (e.playerDrawInfo == null) {
			e.playerDrawInfo = new PlayerDrawInfo();
		}
		if (e.playerDrawInfo.interpolation == null) {
			var n = new NetworkInterpolation();
			var playerInterpolate = new PlayerInterpolate();
			playerInterpolate.platform = game.platform;
			n.req = playerInterpolate;
			n.dELAYMILLISECONDS = 500;
			n.eXTRAPOLATE = false;
			n.eXTRAPOLATION_TIMEMILLISECONDS = 300;
			e.playerDrawInfo.interpolation = n;
		}
		e.playerDrawInfo.interpolation.dELAYMILLISECONDS = MathCi.maxInt(100, game.serverInfo.serverPing.roundtripTimeTotalMilliseconds());
		var p = e;
		var info = p.playerDrawInfo;
		var networkposX = p.networkPosition.x;
		var networkposY = p.networkPosition.y;
		var networkposZ = p.networkPosition.z;
		if (!game.vec3Equal(networkposX, networkposY, networkposZ, info.lastnetworkposX, info.lastnetworkposY, info.lastnetworkposZ) || p.networkPosition.rotx != info.lastnetworkrotx || p.networkPosition.roty != info.lastnetworkroty || p.networkPosition.rotz != info.lastnetworkrotz) {
			var state = new PlayerInterpolationState();
			state.positionX = networkposX;
			state.positionY = networkposY;
			state.positionZ = networkposZ;
			state.rotx = p.networkPosition.rotx;
			state.roty = p.networkPosition.roty;
			state.rotz = p.networkPosition.rotz;
			info.interpolation.addNetworkPacket(state, game.totaltimeMilliseconds);
		}
		var curstate = game.platform.castToPlayerInterpolationState(info.interpolation.interpolatedState(game.totaltimeMilliseconds));
		if (curstate == null) {
			curstate = new PlayerInterpolationState();
		}
		if (game.enablePlayerUpdatePositionContainsKey(i) && !game.enablePlayerUpdatePosition(i)) {
			curstate.positionX = p.networkPosition.x;
			curstate.positionY = p.networkPosition.y;
			curstate.positionZ = p.networkPosition.z;
		}
		var curposX = curstate.positionX;
		var curposY = curstate.positionY;
		var curposZ = curstate.positionZ;
		info.velocityX = curposX - info.lastcurposX;
		info.velocityY = curposY - info.lastcurposY;
		info.velocityZ = curposZ - info.lastcurposZ;
		info.moves = !game.vec3Equal(curposX, curposY, curposZ, info.lastcurposX, info.lastcurposY, info.lastcurposZ);
		info.lastcurposX = curposX;
		info.lastcurposY = curposY;
		info.lastcurposZ = curposZ;
		info.lastnetworkposX = networkposX;
		info.lastnetworkposY = networkposY;
		info.lastnetworkposZ = networkposZ;
		info.lastnetworkrotx = p.networkPosition.rotx;
		info.lastnetworkroty = p.networkPosition.roty;
		info.lastnetworkrotz = p.networkPosition.rotz;
		p.position.x = curposX;
		p.position.y = curposY;
		p.position.z = curposZ;
		p.position.rotx = curstate.rotx;
		p.position.roty = curstate.roty;
		p.position.rotz = curstate.rotz;
	}
}

ModInterpolatePositions.prototype.onNewFrame = function(game, args) {
	this.interpolatePositions(game, args.getDt());
}

function ModLoadPlayerTextures()
{
	this.skinserver = null;
	this.skinserverResponse = null;
	this.started = false;
}
ModLoadPlayerTextures.prototype = new ClientMod();

ModLoadPlayerTextures.prototype.loadPlayerTextures = function(game) {
	if (!game.issingleplayer) {
		if (this.skinserverResponse.done) {
			this.skinserver = game.platform.stringFromUtf8ByteArray(this.skinserverResponse.value, this.skinserverResponse.valueLength);
		}
		else if (this.skinserverResponse.error) {
			this.skinserver = null;
		}
		else {
			return;
		}
	}
	for (var i = 0; i < game.entitiesCount; i++) {
		var e = game.entities[i];
		if (e == null) {
			continue;
		}
		if (e.drawModel == null) {
			continue;
		}
		if (e.drawModel.currentTexture != -1) {
			continue;
		}
		if (!game.issingleplayer && e.drawModel.downloadSkin && this.skinserver != null && e.drawModel.texture_ == null) {
			if (e.drawModel.skinDownloadResponse == null) {
				e.drawModel.skinDownloadResponse = new HttpResponseCi();
				var url = StringTools.stringAppend(game.platform, this.skinserver, StringTools.stringSubstringToEnd(game.platform, e.drawName.name, 2));
				url = StringTools.stringAppend(game.platform, url, ".png");
				game.platform.webClientDownloadDataAsync(url, e.drawModel.skinDownloadResponse);
				continue;
			}
			if (!e.drawModel.skinDownloadResponse.error) {
				if (!e.drawModel.skinDownloadResponse.done) {
					continue;
				}
				var bmp_ = game.platform.bitmapCreateFromPng(e.drawModel.skinDownloadResponse.value, e.drawModel.skinDownloadResponse.valueLength);
				if (bmp_ != null) {
					e.drawModel.currentTexture = game.getTextureOrLoad(e.drawName.name, bmp_);
					game.platform.bitmapDelete(bmp_);
					continue;
				}
			}
		}
		if (e.drawModel.texture_ == null) {
			e.drawModel.currentTexture = game.getTexture("mineplayer.png");
			continue;
		}
		var file = game.getFile(e.drawModel.texture_);
		if (file == null) {
			e.drawModel.currentTexture = 0;
			continue;
		}
		var bmp = game.platform.bitmapCreateFromPng(file, game.platform.byteArrayLength(file));
		if (bmp == null) {
			e.drawModel.currentTexture = 0;
			continue;
		}
		e.drawModel.currentTexture = game.getTextureOrLoad(e.drawModel.texture_, bmp);
		game.platform.bitmapDelete(bmp);
	}
}

ModLoadPlayerTextures.prototype.onNewFrame = function(game, args) {
	if (game.guistate == GuiState.MAP_LOADING) {
		return;
	}
	if (!this.started) {
		this.started = true;
		if (!game.issingleplayer) {
			this.skinserverResponse = new HttpResponseCi();
			game.platform.webClientDownloadDataAsync("http://manicdigger.sourceforge.net/skinserver.txt", this.skinserverResponse);
		}
	}
	this.loadPlayerTextures(game);
}

function ModManagerSimple()
{
}

function ModManagerSimple1()
{
	this.server = null;
}
ModManagerSimple1.prototype = new ModManagerSimple();

ModManagerSimple1.prototype.addToInventory = function(player, block, amount) {
	var inv = this.server.clients[player].inventory;
	for (var i = 0; i < 10; i++) {
		if (inv.rightHand[i].blockId == 0) {
			inv.rightHand[i].blockId = this.getBlockTypeId(block);
			inv.rightHand[i].blockCount = amount;
			break;
		}
	}
	this.server.clients[player].inventoryDirty = true;
}

ModManagerSimple1.prototype.createBlockType = function(name) {
	var b = new BlockTypeSimple();
	b.setName(name);
	this.server.blockTypes[this.server.blockTypesCount++] = b.block;
	return b;
}

ModManagerSimple1.prototype.getBlockTypeId = function(p) {
	for (var i = 0; i < this.server.blockTypesCount; i++) {
		if (this.server.blockTypes[i] == null) {
			continue;
		}
		if (Game.stringEquals(this.server.blockTypes[i].name, p)) {
			return i;
		}
	}
	return -1;
}

ModManagerSimple1.prototype.start = function(serverSimple) {
	this.server = serverSimple;
}

function ModNetworkEntity()
{
	this.despawn = null;
	this.position = null;
	this.spawn = null;
	this.spawn = new ClientPacketHandlerEntitySpawn();
	this.position = new ClientPacketHandlerEntityPosition();
	this.despawn = new ClientPacketHandlerEntityDespawn();
}
ModNetworkEntity.prototype = new ClientMod();

ModNetworkEntity.prototype.onNewFrame = function(game, args) {
	game.packetHandlers[66] = this.spawn;
	game.packetHandlers[67] = this.position;
	game.packetHandlers[68] = this.despawn;
}

function ModNetworkProcess()
{
	this.currentChunk = null;
	this.currentChunkCount = 0;
	this.decompressedchunk = null;
	this.game = null;
	this.receivedchunk = null;
	this.currentChunk = new Uint8Array(new ArrayBuffer(65536));
	this.currentChunkCount = 0;
	this.receivedchunk = new Int32Array(new ArrayBuffer(32768 << 2));
	this.decompressedchunk = new Uint8Array(new ArrayBuffer(65536));
}
ModNetworkProcess.prototype = new ClientMod();

ModNetworkProcess.prototype.networkProcess = function() {
	this.game.currentTimeMilliseconds = this.game.platform.timeMillisecondsFromStart();
	if (this.game.main == null) {
		return;
	}
	var msg;
	for (;;) {
		if (this.game.invalidVersionPacketIdentification != null) {
			break;
		}
		msg = this.game.main.readMessage();
		if (msg == null) {
			break;
		}
		this.tryReadPacket(msg.message, msg.messageLength);
	}
}

ModNetworkProcess.prototype.onReadOnlyBackgroundThread = function(game_, dt) {
	this.game = game_;
	this.networkProcess();
}

ModNetworkProcess.prototype.processInBackground = function(packet) {
	switch (packet.id) {
	case 57:
		var arr = packet.chunkPart.compressedChunkPart;
		var arrLength = this.game.platform.byteArrayLength(arr);
		for (var i = 0; i < arrLength; i++) {
			this.currentChunk[this.currentChunkCount++] = arr[i];
		}
		break;
	case 15:
		{
			var p = packet.chunk_;
			if (this.currentChunkCount != 0) {
				this.game.platform.gzipDecompress(this.currentChunk, this.currentChunkCount, this.decompressedchunk);
				{
					var i = 0;
					for (var zz = 0; zz < p.sizeZ; zz++) {
						for (var yy = 0; yy < p.sizeY; yy++) {
							for (var xx = 0; xx < p.sizeX; xx++) {
								var block = (this.decompressedchunk[i + 1] << 8) + this.decompressedchunk[i];
								if (block < 1024) {
									this.receivedchunk[(zz * p.sizeY + yy) * p.sizeX + xx] = block;
								}
								i += 2;
							}
						}
					}
				}
			}
			else {
				var size = p.sizeX * p.sizeY * p.sizeZ;
				for (var i = 0; i < size; i++) {
					this.receivedchunk[i] = 0;
				}
			}
			{
				this.game.map.setMapPortion(p.x, p.y, p.z, this.receivedchunk, p.sizeX, p.sizeY, p.sizeZ);
				for (var xx = 0; xx < 2; xx++) {
					for (var yy = 0; yy < 2; yy++) {
						for (var zz = 0; zz < 2; zz++) {
						}
					}
				}
			}
			this.game.receivedMapLength += this.currentChunkCount;
			this.currentChunkCount = 0;
		}
		break;
	case 21:
		{
			var p = packet.heightmapChunk;
			this.game.platform.gzipDecompress(p.compressedHeightmap, this.game.platform.byteArrayLength(p.compressedHeightmap), this.decompressedchunk);
			var decompressedchunk1 = Game.byteArrayToUshortArray(this.decompressedchunk, p.sizeX * p.sizeY * 2);
			for (var xx = 0; xx < p.sizeX; xx++) {
				for (var yy = 0; yy < p.sizeY; yy++) {
					var height = decompressedchunk1[MapUtilCi.index2d(xx, yy, p.sizeX)];
					this.game.d_Heightmap.setBlock(p.x + xx, p.y + yy, height);
				}
			}
		}
		break;
	}
}

ModNetworkProcess.prototype.tryReadPacket = function(data, dataLength) {
	var packet = new Packet_Server();
	Packet_ServerSerializer.deserializeBuffer(data, dataLength, packet);
	this.processInBackground(packet);
	var task = new ProcessPacketTask();
	task.game = this.game;
	task.packet_ = packet;
	this.game.queueActionCommit(task);
	this.game.lastReceivedMilliseconds = this.game.currentTimeMilliseconds;
}

function ModPicking()
{
	this.fastclicking = false;
	this.fillarea = null;
	this.fillend = null;
	this.fillstart = null;
	this.lastbuildMilliseconds = 0;
	this.tempRay = null;
	this.tempRayStartPoint = null;
	this.tempViewport = null;
	this.unproject = null;
	this.unproject = new Unproject();
	this.tempViewport = new Float32Array(new ArrayBuffer(4 << 2));
	this.tempRay = new Float32Array(new ArrayBuffer(4 << 2));
	this.tempRayStartPoint = new Float32Array(new ArrayBuffer(4 << 2));
	this.fillarea = new DictionaryVector3Float();
}
ModPicking.prototype = new ClientMod();

ModPicking.prototype.buildDelay = function(game) {
	var default_ = (1 * 95) / (100) * 1 / (game.basemovespeed);
	var item = game.d_Inventory.rightHand[game.activeMaterial];
	if (item == null || item.itemClass != 0) {
		return default_;
	}
	var delay = game.deserializeFloat(game.blocktypes[item.blockId].delayFloat);
	if (delay == 0) {
		return default_;
	}
	return delay;
}

ModPicking.prototype.clearFillArea = function(game) {
	for (var i = 0; i < this.fillarea.itemsCount; i++) {
		var k = this.fillarea.items[i];
		if (k == null) {
			continue;
		}
		game.setBlock(k.x, k.y, k.z, game.platform.floatToInt(k.value));
		game.redrawBlock(k.x, k.y, k.z);
	}
	this.fillarea.clear();
}

ModPicking.prototype.currentPickDistance = function(game) {
	var pick_distance = game.pICK_DISTANCE;
	var inHand = game.blockInHand();
	if (inHand != null) {
		if (game.blocktypes[inHand.value].pickDistanceWhenUsedFloat > 0) {
			pick_distance = game.deserializeFloat(game.blocktypes[inHand.value].pickDistanceWhenUsedFloat);
		}
	}
	if (game.cameratype == CameraType.TPP) {
		pick_distance = game.tppcameradistance + game.pICK_DISTANCE;
	}
	if (game.cameratype == CameraType.OVERHEAD) {
		if (game.platform.isFastSystem()) {
			pick_distance = 100;
		}
		else {
			pick_distance = game.overheadcameradistance * 2;
		}
	}
	return pick_distance;
}

ModPicking.prototype.fillFill = function(game, a_, b_) {
	var startx = MathCi.minInt(a_.x, b_.x);
	var endx = MathCi.maxInt(a_.x, b_.x);
	var starty = MathCi.minInt(a_.y, b_.y);
	var endy = MathCi.maxInt(a_.y, b_.y);
	var startz = MathCi.minInt(a_.z, b_.z);
	var endz = MathCi.maxInt(a_.z, b_.z);
	for (var x = startx; x <= endx; x++) {
		for (var y = starty; y <= endy; y++) {
			for (var z = startz; z <= endz; z++) {
				if (this.fillarea.count() > game.fillAreaLimit) {
					this.clearFillArea(game);
					return;
				}
				if (!game.isFillBlock(game.map.getBlock(x, y, z))) {
					this.fillarea.set(x, y, z, game.map.getBlock(x, y, z));
					game.setBlock(x, y, z, game.d_Data.blockIdFillArea());
					game.redrawBlock(x, y, z);
				}
			}
		}
	}
}

ModPicking.prototype.getAim = function(game) {
	if (game.currentAimRadius() <= 1) {
		return PointFloatRef.create(0, 0);
	}
	var half = 0.5;
	var x;
	var y;
	for (;;) {
		x = (game.rnd.nextFloat() - half) * game.currentAimRadius() * 2;
		y = (game.rnd.nextFloat() - half) * game.currentAimRadius() * 2;
		var dist1 = game.platform.mathSqrt(x * x + y * y);
		if (dist1 <= game.currentAimRadius()) {
			break;
		}
	}
	return PointFloatRef.create(x, y);
}

ModPicking.prototype.getPickingLine = function(game, retPick, ispistolshoot) {
	var mouseX;
	var mouseY;
	if (game.cameratype == CameraType.FPP || game.cameratype == CameraType.TPP) {
		mouseX = Math.floor(game.width() / 2);
		mouseY = Math.floor(game.height() / 2);
	}
	else {
		mouseX = game.mouseCurrentX;
		mouseY = game.mouseCurrentY;
	}
	var aim = this.getAim(game);
	if (ispistolshoot && (aim.x != 0 || aim.y != 0)) {
		mouseX += game.platform.floatToInt(aim.x);
		mouseY += game.platform.floatToInt(aim.y);
	}
	this.tempViewport[0] = 0;
	this.tempViewport[1] = 0;
	this.tempViewport[2] = game.width();
	this.tempViewport[3] = game.height();
	this.unproject.unProject(mouseX, game.height() - mouseY, 1, game.mvMatrix.peek(), game.pMatrix.peek(), this.tempViewport, this.tempRay);
	this.unproject.unProject(mouseX, game.height() - mouseY, 0, game.mvMatrix.peek(), game.pMatrix.peek(), this.tempViewport, this.tempRayStartPoint);
	var raydirX = this.tempRay[0] - this.tempRayStartPoint[0];
	var raydirY = this.tempRay[1] - this.tempRayStartPoint[1];
	var raydirZ = this.tempRay[2] - this.tempRayStartPoint[2];
	var raydirLength = game.length(raydirX, raydirY, raydirZ);
	raydirX /= raydirLength;
	raydirY /= raydirLength;
	raydirZ /= raydirLength;
	retPick.start = new Float32Array(new ArrayBuffer(3 << 2));
	retPick.start[0] = this.tempRayStartPoint[0];
	retPick.start[1] = this.tempRayStartPoint[1];
	retPick.start[2] = this.tempRayStartPoint[2];
	var pickDistance1 = this.currentPickDistance(game) * (ispistolshoot ? 100 : 1);
	pickDistance1 += 1;
	retPick.end = new Float32Array(new ArrayBuffer(3 << 2));
	retPick.end[0] = this.tempRayStartPoint[0] + raydirX * pickDistance1;
	retPick.end[1] = this.tempRayStartPoint[1] + raydirY * pickDistance1;
	retPick.end[2] = this.tempRayStartPoint[2] + raydirZ * pickDistance1;
}

ModPicking.prototype.nextBullet = function(game, bulletsshot) {
	var one = 1;
	var left = game.mouseLeft;
	var middle = game.mouseMiddle;
	var right = game.mouseRight;
	var IsNextShot = bulletsshot != 0;
	if (!game.leftpressedpicking) {
		if (game.mouseleftclick) {
			game.leftpressedpicking = true;
		}
		else {
			left = false;
		}
	}
	else {
		if (game.mouseleftdeclick) {
			game.leftpressedpicking = false;
			left = false;
		}
	}
	if (!left) {
		game.currentAttackedBlock = null;
	}
	var item = game.d_Inventory.rightHand[game.activeMaterial];
	var ispistol = item != null && game.blocktypes[item.blockId].isPistol;
	var ispistolshoot = ispistol && left;
	var isgrenade = ispistol && game.blocktypes[item.blockId].pistolType == 1;
	if (ispistol && isgrenade) {
		ispistolshoot = game.mouseleftdeclick;
	}
	if (game.mouseleftclick) {
		game.grenadecookingstartMilliseconds = game.platform.timeMillisecondsFromStart();
		if (ispistol && isgrenade) {
			if (game.blocktypes[item.blockId].sounds.shootCount > 0) {
				game.audioPlay(game.platform.stringFormat("{0}.ogg", game.blocktypes[item.blockId].sounds.shoot[0]));
			}
		}
	}
	var wait = (one * (game.platform.timeMillisecondsFromStart() - game.grenadecookingstartMilliseconds)) / (1000);
	if (isgrenade && left) {
		if (wait >= game.grenadetime && isgrenade && game.grenadecookingstartMilliseconds != 0) {
			ispistolshoot = true;
			game.mouseleftdeclick = true;
		}
		else {
			return;
		}
	}
	else {
		game.grenadecookingstartMilliseconds = 0;
	}
	if (ispistol && game.mouserightclick && game.platform.timeMillisecondsFromStart() - game.lastironsightschangeMilliseconds >= 500) {
		game.ironSights = !game.ironSights;
		game.lastironsightschangeMilliseconds = game.platform.timeMillisecondsFromStart();
	}
	var pick2count = new IntRef();
	var pick = new Line3D();
	this.getPickingLine(game, pick, ispistolshoot);
	var pick2 = game.pick(game.s, pick, pick2count);
	if (left) {
		game.handSetAttackDestroy = true;
	}
	else if (right) {
		game.handSetAttackBuild = true;
	}
	if (game.overheadcamera && pick2count.value > 0 && left) {
		if (game.follow == null) {
			game.playerdestination = Vector3Ref.create(pick2[0].blockPos[0], pick2[0].blockPos[1] + 1, pick2[0].blockPos[2]);
		}
	}
	var pickdistanceok = pick2count.value > 0;
	if (pickdistanceok) {
		if (game.dist(pick2[0].blockPos[0] + one / (2), pick2[0].blockPos[1] + one / (2), pick2[0].blockPos[2] + one / (2), pick.start[0], pick.start[1], pick.start[2]) > this.currentPickDistance(game)) {
			pickdistanceok = false;
		}
	}
	var playertileempty = game.isTileEmptyForPhysics(game.platform.floatToInt(game.player.position.x), game.platform.floatToInt(game.player.position.z), game.platform.floatToInt(game.player.position.y + one / (2)));
	var playertileemptyclose = game.isTileEmptyForPhysicsClose(game.platform.floatToInt(game.player.position.x), game.platform.floatToInt(game.player.position.z), game.platform.floatToInt(game.player.position.y + one / (2)));
	var pick0 = new BlockPosSide();
	if (pick2count.value > 0 && (pickdistanceok && (playertileempty || playertileemptyclose) || game.overheadcamera)) {
		game.selectedBlockPositionX = game.platform.floatToInt(pick2[0].current()[0]);
		game.selectedBlockPositionY = game.platform.floatToInt(pick2[0].current()[1]);
		game.selectedBlockPositionZ = game.platform.floatToInt(pick2[0].current()[2]);
		pick0 = pick2[0];
	}
	else {
		game.selectedBlockPositionX = -1;
		game.selectedBlockPositionY = -1;
		game.selectedBlockPositionZ = -1;
		pick0.blockPos = new Float32Array(new ArrayBuffer(3 << 2));
		pick0.blockPos[0] = -1;
		pick0.blockPos[1] = -1;
		pick0.blockPos[2] = -1;
	}
	this.pickEntity(game, pick, pick2, pick2count);
	if (game.cameratype == CameraType.FPP || game.cameratype == CameraType.TPP) {
		var ntileX = game.platform.floatToInt(pick0.current()[0]);
		var ntileY = game.platform.floatToInt(pick0.current()[1]);
		var ntileZ = game.platform.floatToInt(pick0.current()[2]);
		if (game.isUsableBlock(game.map.getBlock(ntileX, ntileZ, ntileY))) {
			game.currentAttackedBlock = Vector3IntRef.create(ntileX, ntileZ, ntileY);
		}
	}
	if (game.getFreeMouse()) {
		if (pick2count.value > 0) {
			this.onPick_(pick0);
		}
		return;
	}
	if ((one * (game.platform.timeMillisecondsFromStart() - this.lastbuildMilliseconds)) / (1000) >= this.buildDelay(game) || IsNextShot) {
		if (left && game.d_Inventory.rightHand[game.activeMaterial] == null) {
			game.sendPacketClient(ClientPackets.monsterHit(game.platform.floatToInt(2 + game.rnd.nextFloat() * 4)));
		}
		if (left && !this.fastclicking) {
			this.fastclicking = false;
		}
		if ((left || right || middle) && !isgrenade) {
			this.lastbuildMilliseconds = game.platform.timeMillisecondsFromStart();
		}
		if (isgrenade && game.mouseleftdeclick) {
			this.lastbuildMilliseconds = game.platform.timeMillisecondsFromStart();
		}
		if (game.reloadstartMilliseconds != 0) {
			this.pickingEnd(left, right, middle, ispistol);
			return;
		}
		if (ispistolshoot) {
			if (!(game.loadedAmmo[item.blockId] > 0) || !(game.totalAmmo[item.blockId] > 0)) {
				game.audioPlay("Dry Fire Gun-SoundBible.com-2053652037.ogg");
				this.pickingEnd(left, right, middle, ispistol);
				return;
			}
		}
		if (ispistolshoot) {
			var toX = pick.end[0];
			var toY = pick.end[1];
			var toZ = pick.end[2];
			if (pick2count.value > 0) {
				toX = pick2[0].blockPos[0];
				toY = pick2[0].blockPos[1];
				toZ = pick2[0].blockPos[2];
			}
			var shot = new Packet_ClientShot();
			shot.fromX = game.serializeFloat(pick.start[0]);
			shot.fromY = game.serializeFloat(pick.start[1]);
			shot.fromZ = game.serializeFloat(pick.start[2]);
			shot.toX = game.serializeFloat(toX);
			shot.toY = game.serializeFloat(toY);
			shot.toZ = game.serializeFloat(toZ);
			shot.hitPlayer = -1;
			for (var i = 0; i < game.entitiesCount; i++) {
				if (game.entities[i] == null) {
					continue;
				}
				if (game.entities[i].drawModel == null) {
					continue;
				}
				var p_ = game.entities[i];
				if (p_.networkPosition == null) {
					continue;
				}
				if (!p_.networkPosition.positionLoaded) {
					continue;
				}
				var feetposX = p_.position.x;
				var feetposY = p_.position.y;
				var feetposZ = p_.position.z;
				var bodybox = new Box3D();
				var headsize = (p_.drawModel.modelHeight - p_.drawModel.eyeHeight) * 2;
				var h = p_.drawModel.modelHeight - headsize;
				var r = (one * 35) / (100);
				bodybox.addPoint(feetposX - r, feetposY + 0, feetposZ - r);
				bodybox.addPoint(feetposX - r, feetposY + 0, feetposZ + r);
				bodybox.addPoint(feetposX + r, feetposY + 0, feetposZ - r);
				bodybox.addPoint(feetposX + r, feetposY + 0, feetposZ + r);
				bodybox.addPoint(feetposX - r, feetposY + h, feetposZ - r);
				bodybox.addPoint(feetposX - r, feetposY + h, feetposZ + r);
				bodybox.addPoint(feetposX + r, feetposY + h, feetposZ - r);
				bodybox.addPoint(feetposX + r, feetposY + h, feetposZ + r);
				var headbox = new Box3D();
				headbox.addPoint(feetposX - r, feetposY + h, feetposZ - r);
				headbox.addPoint(feetposX - r, feetposY + h, feetposZ + r);
				headbox.addPoint(feetposX + r, feetposY + h, feetposZ - r);
				headbox.addPoint(feetposX + r, feetposY + h, feetposZ + r);
				headbox.addPoint(feetposX - r, feetposY + h + headsize, feetposZ - r);
				headbox.addPoint(feetposX - r, feetposY + h + headsize, feetposZ + r);
				headbox.addPoint(feetposX + r, feetposY + h + headsize, feetposZ - r);
				headbox.addPoint(feetposX + r, feetposY + h + headsize, feetposZ + r);
				var p;
				var localeyeposX = game.eyesPosX();
				var localeyeposY = game.eyesPosY();
				var localeyeposZ = game.eyesPosZ();
				p = Intersection.checkLineBoxExact(pick, headbox);
				if (p != null) {
					if (pick2count.value == 0 || game.dist(pick2[0].blockPos[0], pick2[0].blockPos[1], pick2[0].blockPos[2], localeyeposX, localeyeposY, localeyeposZ) > game.dist(p[0], p[1], p[2], localeyeposX, localeyeposY, localeyeposZ)) {
						if (!isgrenade) {
							var entity = new Entity();
							var sprite = new Sprite();
							sprite.positionX = p[0];
							sprite.positionY = p[1];
							sprite.positionZ = p[2];
							sprite.image = "blood.png";
							entity.sprite = sprite;
							entity.expires = Expires.create((one * 2) / (10));
							game.entityAddLocal(entity);
						}
						shot.hitPlayer = i;
						shot.isHitHead = 1;
					}
				}
				else {
					p = Intersection.checkLineBoxExact(pick, bodybox);
					if (p != null) {
						if (pick2count.value == 0 || game.dist(pick2[0].blockPos[0], pick2[0].blockPos[1], pick2[0].blockPos[2], localeyeposX, localeyeposY, localeyeposZ) > game.dist(p[0], p[1], p[2], localeyeposX, localeyeposY, localeyeposZ)) {
							if (!isgrenade) {
								var entity = new Entity();
								var sprite = new Sprite();
								sprite.positionX = p[0];
								sprite.positionY = p[1];
								sprite.positionZ = p[2];
								sprite.image = "blood.png";
								entity.sprite = sprite;
								entity.expires = Expires.create((one * 2) / (10));
								game.entityAddLocal(entity);
							}
							shot.hitPlayer = i;
							shot.isHitHead = 0;
						}
					}
				}
			}
			shot.weaponBlock = item.blockId;
			game.loadedAmmo[item.blockId] = game.loadedAmmo[item.blockId] - 1;
			game.totalAmmo[item.blockId] = game.totalAmmo[item.blockId] - 1;
			var projectilespeed = game.deserializeFloat(game.blocktypes[item.blockId].projectileSpeedFloat);
			if (projectilespeed == 0) {
				{
					var entity = game.createBulletEntity(pick.start[0], pick.start[1], pick.start[2], toX, toY, toZ, 150);
					game.entityAddLocal(entity);
				}
			}
			else {
				var vX = toX - pick.start[0];
				var vY = toY - pick.start[1];
				var vZ = toZ - pick.start[2];
				var vLength = game.length(vX, vY, vZ);
				vX /= vLength;
				vY /= vLength;
				vZ /= vLength;
				vX *= projectilespeed;
				vY *= projectilespeed;
				vZ *= projectilespeed;
				shot.explodesAfter = game.serializeFloat(game.grenadetime - wait);
				{
					var grenadeEntity = new Entity();
					var sprite = new Sprite();
					sprite.image = "ChemicalGreen.png";
					sprite.size = 14;
					sprite.animationcount = 0;
					sprite.positionX = pick.start[0];
					sprite.positionY = pick.start[1];
					sprite.positionZ = pick.start[2];
					grenadeEntity.sprite = sprite;
					var projectile = new Grenade_();
					projectile.velocityX = vX;
					projectile.velocityY = vY;
					projectile.velocityZ = vZ;
					projectile.block = item.blockId;
					projectile.sourcePlayer = game.localPlayerId;
					grenadeEntity.expires = Expires.create(game.grenadetime - wait);
					grenadeEntity.grenade = projectile;
					game.entityAddLocal(grenadeEntity);
				}
			}
			var packet = new Packet_Client();
			packet.id = 54;
			packet.shot = shot;
			game.sendPacketClient(packet);
			if (game.blocktypes[item.blockId].sounds.shootEndCount > 0) {
				game.pistolcycle = game.rnd.next() % game.blocktypes[item.blockId].sounds.shootEndCount;
				game.audioPlay(game.platform.stringFormat("{0}.ogg", game.blocktypes[item.blockId].sounds.shootEnd[game.pistolcycle]));
			}
			bulletsshot++;
			if (bulletsshot < game.deserializeFloat(game.blocktypes[item.blockId].bulletsPerShotFloat)) {
				this.nextBullet(game, bulletsshot);
			}
			game.player.position.rotx -= game.rnd.nextFloat() * game.currentRecoil();
			game.player.position.roty += game.rnd.nextFloat() * game.currentRecoil() * 2 - game.currentRecoil();
			this.pickingEnd(left, right, middle, ispistol);
			return;
		}
		if (ispistol && right) {
			this.pickingEnd(left, right, middle, ispistol);
			return;
		}
		if (pick2count.value > 0) {
			if (middle) {
				var newtileX = game.platform.floatToInt(pick0.current()[0]);
				var newtileY = game.platform.floatToInt(pick0.current()[1]);
				var newtileZ = game.platform.floatToInt(pick0.current()[2]);
				if (game.map.isValidPos(newtileX, newtileZ, newtileY)) {
					var clonesource = game.map.getBlock(newtileX, newtileZ, newtileY);
					var clonesource2 = game.d_Data.whenPlayerPlacesGetsConvertedTo()[clonesource];
					var gotoDone = false;
					for (var i = 0; i < 10; i++) {
						if (game.d_Inventory.rightHand[i] != null && game.d_Inventory.rightHand[i].itemClass == 0 && game.d_Inventory.rightHand[i].blockId == clonesource2) {
							game.activeMaterial = i;
							gotoDone = true;
						}
					}
					if (!gotoDone) {
						var freehand = game.d_InventoryUtil.freeHand(game.activeMaterial);
						for (var i = 0; i < game.d_Inventory.itemsCount; i++) {
							var k = game.d_Inventory.items[i];
							if (k == null) {
								continue;
							}
							if (k.value_.itemClass == 0 && k.value_.blockId == clonesource2) {
								if (freehand != null) {
									game.wearItem(game.inventoryPositionMainArea(k.x, k.y), game.inventoryPositionMaterialSelector(freehand.value));
									break;
								}
								if (game.d_Inventory.rightHand[game.activeMaterial] != null && game.d_Inventory.rightHand[game.activeMaterial].itemClass == 0) {
									game.moveToInventory(game.inventoryPositionMaterialSelector(game.activeMaterial));
									game.wearItem(game.inventoryPositionMainArea(k.x, k.y), game.inventoryPositionMaterialSelector(game.activeMaterial));
								}
							}
						}
					}
					var sound = game.d_Data.cloneSound()[clonesource];
					if (sound != null) {
						game.audioPlay(game.platform.stringFormat("{0}.ogg", sound[0]));
					}
				}
			}
			if (left || right) {
				var tile = pick0;
				var newtileX;
				var newtileY;
				var newtileZ;
				if (right) {
					newtileX = game.platform.floatToInt(tile.translated()[0]);
					newtileY = game.platform.floatToInt(tile.translated()[1]);
					newtileZ = game.platform.floatToInt(tile.translated()[2]);
				}
				else {
					newtileX = game.platform.floatToInt(tile.current()[0]);
					newtileY = game.platform.floatToInt(tile.current()[1]);
					newtileZ = game.platform.floatToInt(tile.current()[2]);
				}
				if (game.map.isValidPos(newtileX, newtileZ, newtileY)) {
					if (!(pick0.blockPos[0] == -1 && pick0.blockPos[1] == -1 && pick0.blockPos[2] == -1)) {
						var blocktype;
						if (left) {
							blocktype = game.map.getBlock(newtileX, newtileZ, newtileY);
						}
						else {
							blocktype = game.blockInHand() == null ? 1 : game.blockInHand().value;
						}
						if (left && blocktype == game.d_Data.blockIdAdminium()) {
							this.pickingEnd(left, right, middle, ispistol);
							return;
						}
						var sound = left ? game.d_Data.breakSound()[blocktype] : game.d_Data.buildSound()[blocktype];
						if (sound != null) {
							game.audioPlay(game.platform.stringFormat("{0}.ogg", sound[0]));
						}
					}
					if (!right) {
						var posx = newtileX;
						var posy = newtileZ;
						var posz = newtileY;
						game.currentAttackedBlock = Vector3IntRef.create(posx, posy, posz);
						if (!game.blockHealth.containsKey(posx, posy, posz)) {
							game.blockHealth.set(posx, posy, posz, game.getCurrentBlockHealth(posx, posy, posz));
						}
						game.blockHealth.set(posx, posy, posz, game.blockHealth.get(posx, posy, posz) - game.weaponAttackStrength());
						var health = game.getCurrentBlockHealth(posx, posy, posz);
						if (health <= 0) {
							if (game.currentAttackedBlock != null) {
								game.blockHealth.remove(posx, posy, posz);
							}
							game.currentAttackedBlock = null;
							this.onPick(game, game.platform.floatToInt(newtileX), game.platform.floatToInt(newtileZ), game.platform.floatToInt(newtileY), game.platform.floatToInt(tile.current()[0]), game.platform.floatToInt(tile.current()[2]), game.platform.floatToInt(tile.current()[1]), tile.collisionPos, right);
						}
						this.pickingEnd(left, right, middle, ispistol);
						return;
					}
					if (!right) {
						game.particleEffectBlockBreak.startParticleEffect(newtileX, newtileY, newtileZ);
					}
					if (!game.map.isValidPos(newtileX, newtileZ, newtileY)) {
						game.platform.throwException("Error in picking - NextBullet()");
					}
					this.onPick(game, game.platform.floatToInt(newtileX), game.platform.floatToInt(newtileZ), game.platform.floatToInt(newtileY), game.platform.floatToInt(tile.current()[0]), game.platform.floatToInt(tile.current()[2]), game.platform.floatToInt(tile.current()[1]), tile.collisionPos, right);
				}
			}
		}
	}
	this.pickingEnd(left, right, middle, ispistol);
}

ModPicking.prototype.onMouseDown = function(game, args) {
	if (game.guistate == GuiState.NORMAL) {
		this.updatePicking(game);
		this.updateEntityHit(game);
	}
}

ModPicking.prototype.onMouseUp = function(game, args) {
	if (game.guistate == GuiState.NORMAL) {
		this.updatePicking(game);
	}
}

ModPicking.prototype.onNewFrameReadOnlyMainThread = function(game, deltaTime) {
	if (game.guistate == GuiState.NORMAL) {
		this.updatePicking(game);
	}
}

ModPicking.prototype.onPick = function(game, blockposX, blockposY, blockposZ, blockposoldX, blockposoldY, blockposoldZ, collisionPos, right) {
	var xfract = collisionPos[0] - game.mathFloor(collisionPos[0]);
	var zfract = collisionPos[2] - game.mathFloor(collisionPos[2]);
	var activematerial = game.materialSlots_(game.activeMaterial);
	var railstart = game.d_Data.blockIdRailstart();
	if (activematerial == railstart + 3 || activematerial == railstart + 60) {
		var dirnew;
		if (activematerial == railstart + 3) {
			dirnew = this.pickHorizontalVertical(xfract, zfract);
		}
		else {
			dirnew = this.pickCorners(xfract, zfract);
		}
		var dir = game.d_Data.rail()[game.map.getBlock(blockposoldX, blockposoldY, blockposoldZ)];
		if (dir != 0) {
			blockposX = blockposoldX;
			blockposY = blockposoldY;
			blockposZ = blockposoldZ;
		}
		activematerial = railstart + (dir | DirectionUtils.toRailDirectionFlags(dirnew));
	}
	var x = game.platform.floatToInt(blockposX);
	var y = game.platform.floatToInt(blockposY);
	var z = game.platform.floatToInt(blockposZ);
	var mode = right ? 1 : 0;
	{
		if (game.isAnyPlayerInPos(x, y, z) || activematerial == 151) {
			return;
		}
		var v = Vector3IntRef.create(x, y, z);
		var oldfillstart = this.fillstart;
		var oldfillend = this.fillend;
		if (mode == 1) {
			if (game.blocktypes[activematerial].isTool) {
				this.onPickUseWithTool(game, blockposX, blockposY, blockposZ);
				return;
			}
			if (activematerial == game.d_Data.blockIdCuboid()) {
				this.clearFillArea(game);
				if (this.fillstart != null) {
					var f = this.fillstart;
					if (!game.isFillBlock(game.map.getBlock(f.x, f.y, f.z))) {
						this.fillarea.set(f.x, f.y, f.z, game.map.getBlock(f.x, f.y, f.z));
					}
					game.setBlock(f.x, f.y, f.z, game.d_Data.blockIdFillStart());
					this.fillFill(game, v, this.fillstart);
				}
				if (!game.isFillBlock(game.map.getBlock(v.x, v.y, v.z))) {
					this.fillarea.set(v.x, v.y, v.z, game.map.getBlock(v.x, v.y, v.z));
				}
				game.setBlock(v.x, v.y, v.z, game.d_Data.blockIdCuboid());
				this.fillend = v;
				game.redrawBlock(v.x, v.y, v.z);
				return;
			}
			if (activematerial == game.d_Data.blockIdFillStart()) {
				this.clearFillArea(game);
				if (!game.isFillBlock(game.map.getBlock(v.x, v.y, v.z))) {
					this.fillarea.set(v.x, v.y, v.z, game.map.getBlock(v.x, v.y, v.z));
				}
				game.setBlock(v.x, v.y, v.z, game.d_Data.blockIdFillStart());
				this.fillstart = v;
				this.fillend = null;
				game.redrawBlock(v.x, v.y, v.z);
				return;
			}
			if (this.fillarea.containsKey(v.x, v.y, v.z)) {
				game.sendFillArea(this.fillstart.x, this.fillstart.y, this.fillstart.z, this.fillend.x, this.fillend.y, this.fillend.z, activematerial);
				this.clearFillArea(game);
				this.fillstart = null;
				this.fillend = null;
				return;
			}
		}
		else {
			if (game.blocktypes[activematerial].isTool) {
				this.onPickUseWithTool(game, blockposX, blockposY, blockposoldZ);
				return;
			}
			if (this.fillstart != null && this.fillstart.x == v.x && this.fillstart.y == v.y && this.fillstart.z == v.z) {
				this.clearFillArea(game);
				this.fillstart = null;
				this.fillend = null;
				return;
			}
			if (this.fillend != null && this.fillend.x == v.x && this.fillend.y == v.y && this.fillend.z == v.z) {
				this.clearFillArea(game);
				this.fillend = null;
				return;
			}
		}
		game.sendSetBlockAndUpdateSpeculative(activematerial, x, y, z, mode);
	}
}

ModPicking.prototype.onPickUseWithTool = function(game, posX, posY, posZ) {
	game.sendSetBlock(posX, posY, posZ, 3, game.d_Inventory.rightHand[game.activeMaterial].blockId, game.activeMaterial);
}

ModPicking.prototype.onPick_ = function(pick0) {
}

ModPicking.prototype.pickCorners = function(xfract, zfract) {
	var half = 0.5;
	if (xfract < half && zfract < half) {
		return RailDirection.UP_LEFT;
	}
	if (xfract >= half && zfract < half) {
		return RailDirection.UP_RIGHT;
	}
	if (xfract < half && zfract >= half) {
		return RailDirection.DOWN_LEFT;
	}
	return RailDirection.DOWN_RIGHT;
}

ModPicking.prototype.pickEntity = function(game, pick, pick2, pick2count) {
	game.selectedEntityId = -1;
	game.currentlyAttackedEntity = -1;
	var one = 1;
	for (var i = 0; i < game.entitiesCount; i++) {
		if (game.entities[i] == null) {
			continue;
		}
		if (i == game.localPlayerId) {
			continue;
		}
		if (game.entities[i].drawModel == null) {
			continue;
		}
		var p_ = game.entities[i];
		if (p_.networkPosition == null) {
			continue;
		}
		if (!p_.networkPosition.positionLoaded) {
			continue;
		}
		if (!p_.usable) {
			continue;
		}
		var feetposX = p_.position.x;
		var feetposY = p_.position.y;
		var feetposZ = p_.position.z;
		var dist = game.dist(feetposX, feetposY, feetposZ, game.player.position.x, game.player.position.y, game.player.position.z);
		if (dist > 5) {
			continue;
		}
		var bodybox = new Box3D();
		var h = p_.drawModel.modelHeight;
		var r = (one * 35) / (100);
		bodybox.addPoint(feetposX - r, feetposY + 0, feetposZ - r);
		bodybox.addPoint(feetposX - r, feetposY + 0, feetposZ + r);
		bodybox.addPoint(feetposX + r, feetposY + 0, feetposZ - r);
		bodybox.addPoint(feetposX + r, feetposY + 0, feetposZ + r);
		bodybox.addPoint(feetposX - r, feetposY + h, feetposZ - r);
		bodybox.addPoint(feetposX - r, feetposY + h, feetposZ + r);
		bodybox.addPoint(feetposX + r, feetposY + h, feetposZ - r);
		bodybox.addPoint(feetposX + r, feetposY + h, feetposZ + r);
		var p;
		var localeyeposX = game.eyesPosX();
		var localeyeposY = game.eyesPosY();
		var localeyeposZ = game.eyesPosZ();
		p = Intersection.checkLineBoxExact(pick, bodybox);
		if (p != null) {
			if (pick2count.value == 0 || game.dist(pick2[0].blockPos[0], pick2[0].blockPos[1], pick2[0].blockPos[2], localeyeposX, localeyeposY, localeyeposZ) > game.dist(p[0], p[1], p[2], localeyeposX, localeyeposY, localeyeposZ)) {
				game.selectedEntityId = i;
				if (game.cameratype == CameraType.FPP || game.cameratype == CameraType.TPP) {
					game.currentlyAttackedEntity = i;
				}
			}
		}
	}
}

ModPicking.prototype.pickHorizontalVertical = function(xfract, yfract) {
	var x = xfract;
	var y = yfract;
	if (y >= x && y >= 1 - x) {
		return RailDirection.VERTICAL;
	}
	if (y < x && y < 1 - x) {
		return RailDirection.VERTICAL;
	}
	return RailDirection.HORIZONTAL;
}

ModPicking.prototype.pickingEnd = function(left, right, middle, ispistol) {
	this.fastclicking = false;
	if (!(left || right || middle) && !ispistol) {
		this.lastbuildMilliseconds = 0;
		this.fastclicking = true;
	}
}

ModPicking.prototype.updateEntityHit = function(game) {
	if (game.currentlyAttackedEntity != -1 && game.mouseLeft) {
		for (var i = 0; i < game.clientmodsCount; i++) {
			if (game.clientmods[i] == null) {
				continue;
			}
			var args = new OnUseEntityArgs();
			args.entityId = game.currentlyAttackedEntity;
			game.clientmods[i].onHitEntity(game, args);
		}
		game.sendPacketClient(ClientPackets.hitEntity(game.currentlyAttackedEntity));
	}
}

ModPicking.prototype.updatePicking = function(game) {
	if (game.followId() != null) {
		game.selectedBlockPositionX = -1;
		game.selectedBlockPositionY = -1;
		game.selectedBlockPositionZ = -1;
		return;
	}
	this.nextBullet(game, 0);
}

function ModPush()
{
}
ModPush.prototype = new ClientMod();

ModPush.prototype.onNewFrameFixed = function(game, args) {
	game.pushX = 0;
	game.pushY = 0;
	game.pushZ = 0;
	var LocalPlayerPositionX = game.player.position.x;
	var LocalPlayerPositionY = game.player.position.y;
	var LocalPlayerPositionZ = game.player.position.z;
	for (var i = 0; i < game.entitiesCount; i++) {
		var entity = game.entities[i];
		if (entity == null) {
			continue;
		}
		if (entity.push == null) {
			continue;
		}
		if (entity.networkPosition != null && !entity.networkPosition.positionLoaded) {
			continue;
		}
		var kposX = game.deserializeFloat(entity.push.xFloat);
		var kposY = game.deserializeFloat(entity.push.zFloat);
		var kposZ = game.deserializeFloat(entity.push.yFloat);
		if (entity.push.isRelativeToPlayerPosition != 0) {
			kposX += LocalPlayerPositionX;
			kposY += LocalPlayerPositionY;
			kposZ += LocalPlayerPositionZ;
		}
		var dist = game.dist(kposX, kposY, kposZ, LocalPlayerPositionX, LocalPlayerPositionY, LocalPlayerPositionZ);
		if (dist < game.deserializeFloat(entity.push.rangeFloat)) {
			var diffX = LocalPlayerPositionX - kposX;
			var diffY = LocalPlayerPositionY - kposY;
			var diffZ = LocalPlayerPositionZ - kposZ;
			game.pushX += diffX;
			game.pushY += diffY;
			game.pushZ += diffZ;
		}
	}
}

function ModRail()
{
	this.currentdirection = VehicleDirection12.HORIZONTAL_LEFT;
	this.currentrailblockX = 0;
	this.currentrailblockY = 0;
	this.currentrailblockZ = 0;
	this.currentrailblockprogress = null;
	this.currentvehiclespeed = null;
	this.d_RailMapUtil = null;
	this.lastdirection = VehicleDirection12.HORIZONTAL_LEFT;
	this.lastrailsound = 0;
	this.lastrailsoundtimeMilliseconds = 0;
	this.localMinecart = null;
	this.one = null;
	this.originalmodelheight = null;
	this.railheight = null;
	this.railriding = false;
	this.wasepressed = false;
	this.wasqpressed = false;
	this.one = 1;
	this.railheight = (this.one * 3) / (10);
}
ModRail.prototype = new ClientMod();

ModRail.prototype.bestNewDirection = function(dirVehicleDirection12Flags, turnleft, turnright, retFound) {
	retFound.value = true;
	if (turnright) {
		if ((dirVehicleDirection12Flags & 2048) != 0) {
			return VehicleDirection12.DOWN_RIGHT_RIGHT;
		}
		if ((dirVehicleDirection12Flags & 64) != 0) {
			return VehicleDirection12.UP_RIGHT_UP;
		}
		if ((dirVehicleDirection12Flags & 32) != 0) {
			return VehicleDirection12.UP_LEFT_LEFT;
		}
		if ((dirVehicleDirection12Flags & 256) != 0) {
			return VehicleDirection12.DOWN_LEFT_DOWN;
		}
	}
	if (turnleft) {
		if ((dirVehicleDirection12Flags & 1024) != 0) {
			return VehicleDirection12.DOWN_RIGHT_DOWN;
		}
		if ((dirVehicleDirection12Flags & 128) != 0) {
			return VehicleDirection12.UP_RIGHT_RIGHT;
		}
		if ((dirVehicleDirection12Flags & 16) != 0) {
			return VehicleDirection12.UP_LEFT_UP;
		}
		if ((dirVehicleDirection12Flags & 512) != 0) {
			return VehicleDirection12.DOWN_LEFT_LEFT;
		}
	}
	if ((dirVehicleDirection12Flags & 8) != 0) {
		return VehicleDirection12.VERTICAL_DOWN;
	}
	if ((dirVehicleDirection12Flags & 4) != 0) {
		return VehicleDirection12.VERTICAL_UP;
	}
	if ((dirVehicleDirection12Flags & 1) != 0) {
		return VehicleDirection12.HORIZONTAL_LEFT;
	}
	if ((dirVehicleDirection12Flags & 2) != 0) {
		return VehicleDirection12.HORIZONTAL_RIGHT;
	}
	if ((dirVehicleDirection12Flags & 256) != 0) {
		return VehicleDirection12.DOWN_LEFT_DOWN;
	}
	if ((dirVehicleDirection12Flags & 512) != 0) {
		return VehicleDirection12.DOWN_LEFT_LEFT;
	}
	if ((dirVehicleDirection12Flags & 1024) != 0) {
		return VehicleDirection12.DOWN_RIGHT_DOWN;
	}
	if ((dirVehicleDirection12Flags & 2048) != 0) {
		return VehicleDirection12.DOWN_RIGHT_RIGHT;
	}
	if ((dirVehicleDirection12Flags & 32) != 0) {
		return VehicleDirection12.UP_LEFT_LEFT;
	}
	if ((dirVehicleDirection12Flags & 16) != 0) {
		return VehicleDirection12.UP_LEFT_UP;
	}
	if ((dirVehicleDirection12Flags & 128) != 0) {
		return VehicleDirection12.UP_RIGHT_RIGHT;
	}
	if ((dirVehicleDirection12Flags & 64) != 0) {
		return VehicleDirection12.UP_RIGHT_UP;
	}
	retFound.value = false;
	return VehicleDirection12.DOWN_LEFT_DOWN;
}

ModRail.prototype.currentRailPos = function(game) {
	var slope = this.d_RailMapUtil.getRailSlope(this.currentrailblockX, this.currentrailblockY, this.currentrailblockZ);
	var aX = this.currentrailblockX;
	var aY = this.currentrailblockY;
	var aZ = this.currentrailblockZ;
	var x_correction = 0;
	var y_correction = 0;
	var z_correction = 0;
	var half = this.one / (2);
	switch (this.currentdirection) {
	case VehicleDirection12.HORIZONTAL_RIGHT:
		x_correction += this.currentrailblockprogress;
		y_correction += half;
		if (slope == RailSlope.TWO_RIGHT_RAISED)
			z_correction += this.currentrailblockprogress;
		if (slope == RailSlope.TWO_LEFT_RAISED)
			z_correction += 1 - this.currentrailblockprogress;
		break;
	case VehicleDirection12.HORIZONTAL_LEFT:
		x_correction += 1 - this.currentrailblockprogress;
		y_correction += half;
		if (slope == RailSlope.TWO_RIGHT_RAISED)
			z_correction += 1 - this.currentrailblockprogress;
		if (slope == RailSlope.TWO_LEFT_RAISED)
			z_correction += this.currentrailblockprogress;
		break;
	case VehicleDirection12.VERTICAL_DOWN:
		x_correction += half;
		y_correction += this.currentrailblockprogress;
		if (slope == RailSlope.TWO_DOWN_RAISED)
			z_correction += this.currentrailblockprogress;
		if (slope == RailSlope.TWO_UP_RAISED)
			z_correction += 1 - this.currentrailblockprogress;
		break;
	case VehicleDirection12.VERTICAL_UP:
		x_correction += half;
		y_correction += 1 - this.currentrailblockprogress;
		if (slope == RailSlope.TWO_DOWN_RAISED)
			z_correction += 1 - this.currentrailblockprogress;
		if (slope == RailSlope.TWO_UP_RAISED)
			z_correction += this.currentrailblockprogress;
		break;
	case VehicleDirection12.UP_LEFT_LEFT:
		x_correction += half * (1 - this.currentrailblockprogress);
		y_correction += half * this.currentrailblockprogress;
		break;
	case VehicleDirection12.UP_LEFT_UP:
		x_correction += half * this.currentrailblockprogress;
		y_correction += half - half * this.currentrailblockprogress;
		break;
	case VehicleDirection12.UP_RIGHT_RIGHT:
		x_correction += half + half * this.currentrailblockprogress;
		y_correction += half * this.currentrailblockprogress;
		break;
	case VehicleDirection12.UP_RIGHT_UP:
		x_correction += 1 - half * this.currentrailblockprogress;
		y_correction += half - half * this.currentrailblockprogress;
		break;
	case VehicleDirection12.DOWN_LEFT_LEFT:
		x_correction += half * (1 - this.currentrailblockprogress);
		y_correction += 1 - half * this.currentrailblockprogress;
		break;
	case VehicleDirection12.DOWN_LEFT_DOWN:
		x_correction += half * this.currentrailblockprogress;
		y_correction += half + half * this.currentrailblockprogress;
		break;
	case VehicleDirection12.DOWN_RIGHT_RIGHT:
		x_correction += half + half * this.currentrailblockprogress;
		y_correction += 1 - half * this.currentrailblockprogress;
		break;
	case VehicleDirection12.DOWN_RIGHT_DOWN:
		x_correction += 1 - half * this.currentrailblockprogress;
		y_correction += half + half * this.currentrailblockprogress;
		break;
	}
	return Vector3Ref.create(aX + x_correction, aZ + this.railheight + 1 + z_correction, aY + y_correction);
}

ModRail.prototype.exitVehicle = function(game) {
	game.setCharacterEyesHeight(this.originalmodelheight);
	this.railriding = false;
	game.controls.setFreemove(0);
	game.enable_move = true;
}

ModRail.prototype.getUpDownMove = function(game, railblockX, railblockY, railblockZ, dir) {
	if (!game.map.isValidPos(railblockX, railblockY, railblockZ)) {
		return 0;
	}
	var slope = this.d_RailMapUtil.getRailSlope(railblockX, railblockY, railblockZ);
	if (slope == RailSlope.TWO_DOWN_RAISED && dir == TileEnterDirection.UP) {
		return 1;
	}
	if (slope == RailSlope.TWO_UP_RAISED && dir == TileEnterDirection.DOWN) {
		return 1;
	}
	if (slope == RailSlope.TWO_LEFT_RAISED && dir == TileEnterDirection.RIGHT) {
		return 1;
	}
	if (slope == RailSlope.TWO_RIGHT_RAISED && dir == TileEnterDirection.LEFT) {
		return 1;
	}
	if (slope == RailSlope.TWO_DOWN_RAISED && dir == TileEnterDirection.DOWN) {
		return 2;
	}
	if (slope == RailSlope.TWO_UP_RAISED && dir == TileEnterDirection.UP) {
		return 2;
	}
	if (slope == RailSlope.TWO_LEFT_RAISED && dir == TileEnterDirection.LEFT) {
		return 2;
	}
	if (slope == RailSlope.TWO_RIGHT_RAISED && dir == TileEnterDirection.RIGHT) {
		return 2;
	}
	return 0;
}

ModRail.nextTile = function(direction, currentTileX, currentTileY, currentTileZ) {
	return ModRail.nextTile_(DirectionUtils.resultExit(direction), currentTileX, currentTileY, currentTileZ);
}

ModRail.nextTile_ = function(direction, currentTileX, currentTileY, currentTileZ) {
	switch (direction) {
	case TileExitDirection.LEFT:
		return Vector3IntRef.create(currentTileX - 1, currentTileY, currentTileZ);
	case TileExitDirection.RIGHT:
		return Vector3IntRef.create(currentTileX + 1, currentTileY, currentTileZ);
	case TileExitDirection.UP:
		return Vector3IntRef.create(currentTileX, currentTileY - 1, currentTileZ);
	case TileExitDirection.DOWN:
		return Vector3IntRef.create(currentTileX, currentTileY + 1, currentTileZ);
	default:
		return null;
	}
}

ModRail.prototype.onNewFrameFixed = function(game, args) {
	if (this.d_RailMapUtil == null) {
		this.d_RailMapUtil = new RailMapUtil();
		this.d_RailMapUtil.game = game;
	}
	this.railOnNewFrame(game, args.getDt());
}

ModRail.prototype.possibleRails = function(game, enter) {
	var possible_railsVehicleDirection12Flags = 0;
	if (game.map.isValidPos(enter.blockPositionX, enter.blockPositionY, enter.blockPositionZ)) {
		var newpositionrail = game.d_Data.rail()[game.map.getBlock(enter.blockPositionX, enter.blockPositionY, enter.blockPositionZ)];
		var all_possible_rails = new Array(3);
		var all_possible_railsCount = 0;
		var possibleRails3 = DirectionUtils.possibleNewRails3(enter.enterDirection);
		for (var i = 0; i < 3; i++) {
			var z = possibleRails3[i];
			if ((newpositionrail & DirectionUtils.toRailDirectionFlags(DirectionUtils.toRailDirection(z))) != 0) {
				all_possible_rails[all_possible_railsCount++] = z;
			}
		}
		possible_railsVehicleDirection12Flags = DirectionUtils.toVehicleDirection12Flags_(all_possible_rails, all_possible_railsCount);
	}
	return possible_railsVehicleDirection12Flags;
}

ModRail.prototype.railOnNewFrame = function(game, dt) {
	if (this.localMinecart == null) {
		this.localMinecart = new Entity();
		this.localMinecart.minecart = new Minecart();
		game.entityAddLocal(this.localMinecart);
	}
	this.localMinecart.minecart.enabled = this.railriding;
	if (this.railriding) {
		var m = this.localMinecart.minecart;
		m.positionX = game.player.position.x;
		m.positionY = game.player.position.y;
		m.positionZ = game.player.position.z;
		m.direction = this.currentdirection;
		m.lastdirection = this.lastdirection;
		m.progress = this.currentrailblockprogress;
	}
	game.localplayeranimationhint.inVehicle = this.railriding;
	game.localplayeranimationhint.drawFixX = 0;
	game.localplayeranimationhint.drawFixY = this.railriding ? Math.floor(-this.one * 7 / 10) : 0;
	game.localplayeranimationhint.drawFixZ = 0;
	var turnright = game.keyboardState[game.getKey(86)];
	var turnleft = game.keyboardState[game.getKey(83)];
	this.railSound(game);
	if (this.railriding) {
		game.controls.setFreemove(1);
		game.enable_move = false;
		var railPos = this.currentRailPos(game);
		game.player.position.x = railPos.x;
		game.player.position.y = railPos.y;
		game.player.position.z = railPos.z;
		this.currentrailblockprogress += this.currentvehiclespeed * dt;
		if (this.currentrailblockprogress >= 1) {
			this.lastdirection = this.currentdirection;
			this.currentrailblockprogress = 0;
			var newenter = new TileEnterData();
			var nexttile = ModRail.nextTile(this.currentdirection, this.currentrailblockX, this.currentrailblockY, this.currentrailblockZ);
			newenter.blockPositionX = nexttile.x;
			newenter.blockPositionY = nexttile.y;
			newenter.blockPositionZ = nexttile.z;
			if (this.getUpDownMove(game, this.currentrailblockX, this.currentrailblockY, this.currentrailblockZ, DirectionUtils.resultEnter(DirectionUtils.resultExit(this.currentdirection))) == 1) {
				newenter.blockPositionZ++;
			}
			if (this.getUpDownMove(game, newenter.blockPositionX, newenter.blockPositionY, newenter.blockPositionZ - 1, DirectionUtils.resultEnter(DirectionUtils.resultExit(this.currentdirection))) == 2) {
				newenter.blockPositionZ--;
			}
			newenter.enterDirection = DirectionUtils.resultEnter(DirectionUtils.resultExit(this.currentdirection));
			var newdirFound = new BoolRef();
			var newdir = this.bestNewDirection(this.possibleRails(game, newenter), turnleft, turnright, newdirFound);
			if (!newdirFound.value) {
				this.currentdirection = DirectionUtils.reverse(this.currentdirection);
			}
			else {
				this.currentdirection = newdir;
				this.currentrailblockX = game.platform.floatToInt(newenter.blockPositionX);
				this.currentrailblockY = game.platform.floatToInt(newenter.blockPositionY);
				this.currentrailblockZ = game.platform.floatToInt(newenter.blockPositionZ);
			}
		}
	}
	if (game.keyboardState[game.getKey(105)] && game.guiTyping != TypingState.TYPING) {
		this.currentvehiclespeed += 1 * dt;
	}
	if (game.keyboardState[game.getKey(101)] && game.guiTyping != TypingState.TYPING) {
		this.currentvehiclespeed -= 5 * dt;
	}
	if (this.currentvehiclespeed < 0) {
		this.currentvehiclespeed = 0;
	}
	if (!this.wasqpressed && game.keyboardState[game.getKey(99)] && game.guiTyping != TypingState.TYPING) {
		this.reverse();
	}
	if (!this.wasepressed && game.keyboardState[game.getKey(87)] && !this.railriding && game.controls.getFreemove() == 0 && game.guiTyping != TypingState.TYPING) {
		this.currentrailblockX = game.platform.floatToInt(game.player.position.x);
		this.currentrailblockY = game.platform.floatToInt(game.player.position.z);
		this.currentrailblockZ = game.platform.floatToInt(game.player.position.y) - 1;
		if (!game.map.isValidPos(this.currentrailblockX, this.currentrailblockY, this.currentrailblockZ)) {
			this.exitVehicle(game);
		}
		else {
			var railunderplayer = game.d_Data.rail()[game.map.getBlock(this.currentrailblockX, this.currentrailblockY, this.currentrailblockZ)];
			this.railriding = true;
			this.originalmodelheight = game.getCharacterEyesHeight();
			game.setCharacterEyesHeight(this.minecartheight());
			this.currentvehiclespeed = 0;
			if ((railunderplayer & 1) != 0) {
				this.currentdirection = VehicleDirection12.HORIZONTAL_RIGHT;
			}
			else if ((railunderplayer & 2) != 0) {
				this.currentdirection = VehicleDirection12.VERTICAL_UP;
			}
			else if ((railunderplayer & 4) != 0) {
				this.currentdirection = VehicleDirection12.UP_LEFT_UP;
			}
			else if ((railunderplayer & 8) != 0) {
				this.currentdirection = VehicleDirection12.UP_RIGHT_UP;
			}
			else if ((railunderplayer & 16) != 0) {
				this.currentdirection = VehicleDirection12.DOWN_LEFT_LEFT;
			}
			else if ((railunderplayer & 32) != 0) {
				this.currentdirection = VehicleDirection12.DOWN_RIGHT_RIGHT;
			}
			else {
				this.exitVehicle(game);
			}
			this.lastdirection = this.currentdirection;
		}
	}
	else if (!this.wasepressed && game.keyboardState[game.getKey(87)] && this.railriding && game.guiTyping != TypingState.TYPING) {
		this.exitVehicle(game);
		game.player.position.y += (this.one * 7) / (10);
	}
	this.wasqpressed = game.keyboardState[game.getKey(99)] && game.guiTyping != TypingState.TYPING;
	this.wasepressed = game.keyboardState[game.getKey(87)] && game.guiTyping != TypingState.TYPING;
}

ModRail.prototype.railSound = function(game) {
	var railsoundpersecond = this.currentvehiclespeed;
	if (railsoundpersecond > 10) {
		railsoundpersecond = 10;
	}
	game.audioPlayLoop("railnoise.wav", this.railriding && railsoundpersecond > (this.one * 1) / (10), false);
	if (!this.railriding) {
		return;
	}
	if (game.platform.timeMillisecondsFromStart() - this.lastrailsoundtimeMilliseconds > 1000 / (railsoundpersecond)) {
		game.audioPlay(game.platform.stringFormat("rail{0}.wav", game.platform.intToString(this.lastrailsound + 1)));
		this.lastrailsoundtimeMilliseconds = game.platform.timeMillisecondsFromStart();
		this.lastrailsound++;
		if (this.lastrailsound >= 4) {
			this.lastrailsound = 0;
		}
	}
}

ModRail.prototype.reverse = function() {
	this.currentdirection = DirectionUtils.reverse(this.currentdirection);
	this.currentrailblockprogress = 1 - this.currentrailblockprogress;
	this.lastdirection = this.currentdirection;
}

ModRail.prototype.minecartheight = function() {
	return this.one / (2);
}

function ModReloadAmmo()
{
}
ModReloadAmmo.prototype = new ClientMod();

ModReloadAmmo.prototype.onKeyDown = function(game, args) {
	if (!(game.guistate == GuiState.NORMAL && game.guiTyping == TypingState.NONE)) {
		return;
	}
	var eKey = args.getKeyCode();
	if (eKey == game.getKey(100)) {
		var item = game.d_Inventory.rightHand[game.activeMaterial];
		if (item != null && item.itemClass == 0 && game.blocktypes[item.blockId].isPistol && game.reloadstartMilliseconds == 0) {
			var sound = game.rnd.next() % game.blocktypes[item.blockId].sounds.reloadCount;
			game.audioPlay(StringTools.stringAppend(game.platform, game.blocktypes[item.blockId].sounds.reload[sound], ".ogg"));
			game.reloadstartMilliseconds = game.platform.timeMillisecondsFromStart();
			game.reloadblock = item.blockId;
			game.sendPacketClient(ClientPackets.reload());
		}
	}
}

ModReloadAmmo.prototype.onNewFrameFixed = function(game, args) {
	if (game.reloadstartMilliseconds != 0 && (game.one * (game.platform.timeMillisecondsFromStart() - game.reloadstartMilliseconds)) / (1000) > game.deserializeFloat(game.blocktypes[game.reloadblock].reloadDelayFloat)) {
		{
			var loaded = game.totalAmmo[game.reloadblock];
			loaded = MathCi.minInt(game.blocktypes[game.reloadblock].ammoMagazine, loaded);
			game.loadedAmmo[game.reloadblock] = loaded;
			game.reloadstartMilliseconds = 0;
			game.reloadblock = -1;
		}
	}
}

function ModScreenshot()
{
	this.screenshotFlashFramesLeft = 0;
	this.takeScreenshot = false;
	this.takeScreenshot = false;
	this.screenshotFlashFramesLeft = 0;
}
ModScreenshot.prototype = new ClientMod();

ModScreenshot.prototype.drawScreenshotFlash = function(game) {
	game.draw2dTexture(game.whiteTexture(), 0, 0, game.platform.getCanvasWidth(), game.platform.getCanvasHeight(), null, 0, Game.colorFromArgb(255, 255, 255, 255), false);
	var screenshottext = "&0Screenshot";
	var textWidth = new IntRef();
	var textHeight = new IntRef();
	var font = new FontCi();
	font.size = 50;
	game.platform.textSize(screenshottext, font, textWidth, textHeight);
	game.draw2dText(screenshottext, font, game.xcenter(textWidth.value), game.ycenter(textHeight.value), null, false);
}

ModScreenshot.prototype.onKeyDown = function(game, args) {
	if (args.getKeyCode() == game.getKey(21)) {
		this.takeScreenshot = true;
		args.setHandled(true);
	}
}

ModScreenshot.prototype.onNewFrameDraw2d = function(game, deltaTime) {
	if (this.takeScreenshot) {
		this.takeScreenshot = false;
		game.platform.saveScreenshot();
		this.screenshotFlashFramesLeft = 5;
	}
	if (this.screenshotFlashFramesLeft > 0) {
		this.drawScreenshotFlash(game);
		this.screenshotFlashFramesLeft--;
	}
}

function ModSendActiveMaterial()
{
	this.previousActiveMaterialBlock = 0;
}
ModSendActiveMaterial.prototype = new ClientMod();

ModSendActiveMaterial.prototype.onNewFrameFixed = function(game, args) {
	var activeitem = game.d_Inventory.rightHand[game.activeMaterial];
	var activeblock = 0;
	if (activeitem != null) {
		activeblock = activeitem.blockId;
	}
	if (activeblock != this.previousActiveMaterialBlock) {
		game.sendPacketClient(ClientPackets.activeMaterialSlot(game.activeMaterial));
	}
	this.previousActiveMaterialBlock = activeblock;
}

function ModSendPosition()
{
}
ModSendPosition.prototype = new ClientMod();

ModSendPosition.prototype.onNewFrame = function(game, args) {
	if (game.spawned && game.platform.timeMillisecondsFromStart() - game.lastpositionsentMilliseconds > 100) {
		game.lastpositionsentMilliseconds = game.platform.timeMillisecondsFromStart();
		game.sendPacketClient(ClientPackets.positionAndOrientation(game, game.localPlayerId, game.player.position.x, game.player.position.y, game.player.position.z, game.player.position.rotx, game.player.position.roty, game.player.position.rotz, game.localstance));
	}
}

function ModServerSimple()
{
	this.server = null;
}
ModServerSimple.prototype = new ClientMod();

ModServerSimple.prototype.onReadOnlyBackgroundThread = function(game, dt) {
	this.server.update();
}

function ModSimple()
{
}

ModSimple.prototype.generateChunk = function(cx, cy, cz, chunk) {
}

ModSimple.prototype.getHeight = function() {
	return -1;
}

ModSimple.prototype.onPlayerJoin = function(playerId) {
}

function ModSimpleDefault()
{
	this.m = null;
}
ModSimpleDefault.prototype = new ModSimple();

ModSimpleDefault.prototype.onPlayerJoin = function(playerId) {
	this.m.addToInventory(playerId, "Dirt", 0);
	this.m.addToInventory(playerId, "Stone", 0);
	this.m.addToInventory(playerId, "Wood", 0);
	this.m.addToInventory(playerId, "Brick", 0);
}

ModSimpleDefault.prototype.start = function(manager) {
	this.m = manager;
	var empty = manager.createBlockType("Empty");
	empty.setDrawType(0);
	empty.setWalkableType(0);
	var stone = manager.createBlockType("Stone");
	stone.setDrawType(1);
	stone.setWalkableType(2);
	stone.setAllTextures("Stone");
	var dirt = manager.createBlockType("Dirt");
	dirt.setDrawType(1);
	dirt.setWalkableType(2);
	dirt.setAllTextures("Dirt");
	var grass = manager.createBlockType("Grass");
	grass.setDrawType(1);
	grass.setWalkableType(2);
	grass.setTextureTop("Grass");
	grass.setTextureBack("GrassSide");
	grass.setTextureFront("GrassSide");
	grass.setTextureLeft("GrassSide");
	grass.setTextureRight("GrassSide");
	grass.setTextureBottom("Dirt");
	var wood = manager.createBlockType("Wood");
	wood.setDrawType(1);
	wood.setWalkableType(2);
	wood.setAllTextures("OakWood");
	var brick = manager.createBlockType("Brick");
	brick.setDrawType(1);
	brick.setWalkableType(2);
	brick.setAllTextures("Brick");
	manager.createBlockType("Sponge");
	manager.createBlockType("Trampoline");
	var adminium = manager.createBlockType("Adminium");
	adminium.setDrawType(1);
	adminium.setWalkableType(2);
	adminium.setAllTextures("Adminium");
	manager.createBlockType("Compass");
	manager.createBlockType("Ladder");
	manager.createBlockType("EmptyHand");
	manager.createBlockType("CraftingTable");
	manager.createBlockType("Lava");
	manager.createBlockType("StationaryLava");
	manager.createBlockType("FillStart");
	manager.createBlockType("Cuboid");
	manager.createBlockType("FillArea");
	manager.createBlockType("Minecart");
	manager.createBlockType("Rail0");
}

function ModSimpleWorldGenerator()
{
	this.m = null;
}
ModSimpleWorldGenerator.prototype = new ModSimple();

ModSimpleWorldGenerator.prototype.generateChunk = function(cx, cy, cz, chunk) {
	var grass = this.m.getBlockTypeId("Grass");
	var dirt = this.m.getBlockTypeId("Dirt");
	var stone = this.m.getBlockTypeId("Stone");
	var adminium = this.m.getBlockTypeId("Adminium");
	for (var xx = 0; xx < 32; xx++) {
		for (var yy = 0; yy < 32; yy++) {
			for (var zz = 0; zz < 32; zz++) {
				var z = cz * 32 + zz;
				var height = 32;
				var block = 0;
				if (z > height) {
					block = 0;
				}
				else if (z == height) {
					block = grass;
				}
				else if (z > height - 5) {
					block = dirt;
				}
				else {
					block = stone;
				}
				if (z == 0) {
					block = adminium;
				}
				chunk[(zz * 32 + yy) * 32 + xx] = block;
			}
		}
	}
}

ModSimpleWorldGenerator.prototype.getHeight = function() {
	return 33;
}

ModSimpleWorldGenerator.prototype.start = function(manager) {
	this.m = manager;
}

function ModSkySphereAnimated()
{
	this.glowPixels = null;
	this.skyPixels = null;
	this.skymodel = null;
	this.stars = null;
	this.started = false;
	this.stars = new ModSkySphereStatic();
}
ModSkySphereAnimated.prototype = new ClientMod();

ModSkySphereAnimated.prototype.draw = function(game, fov) {
	var size = 1000;
	if (game.fancySkysphere) {
		this.skymodel = this.getSphereModelData2(this.skymodel, game.platform, size, size, 64, 64, this.skyPixels, this.glowPixels, game.sunPositionX, game.sunPositionY, game.sunPositionZ);
	}
	else {
		this.skymodel = this.getSphereModelData2(this.skymodel, game.platform, size, size, 20, 20, this.skyPixels, this.glowPixels, game.sunPositionX, game.sunPositionY, game.sunPositionZ);
	}
	game.set3dProjection(size * 2, fov);
	game.gLMatrixModeModelView();
	game.gLPushMatrix();
	game.gLTranslate(game.player.position.x, game.player.position.y, game.player.position.z);
	game.platform.bindTexture2d(0);
	game.drawModelData(this.skymodel);
	game.gLPopMatrix();
	game.set3dProjection(game.zfar(), fov);
}

ModSkySphereAnimated.prototype.drawSkySphere = function(game) {
	if (!this.started) {
		this.started = true;
		var skyBmp = game.platform.bitmapCreateFromPng(game.getFile("sky.png"), game.getFileLength("sky.png"));
		var glowBmp = game.platform.bitmapCreateFromPng(game.getFile("glow.png"), game.getFileLength("glow.png"));
		this.skyPixels = new Int32Array(new ArrayBuffer(1048576 << 2));
		this.glowPixels = new Int32Array(new ArrayBuffer(1048576 << 2));
		game.platform.bitmapGetPixelsArgb(skyBmp, this.skyPixels);
		game.platform.bitmapGetPixelsArgb(glowBmp, this.glowPixels);
		game.platform.bitmapDelete(skyBmp);
		game.platform.bitmapDelete(glowBmp);
	}
	game.platform.gLDisableAlphaTest();
	game.platform.glDisableDepthTest();
	this.draw(game, game.currentfov());
	game.platform.gLEnableAlphaTest();
	game.platform.glEnableDepthTest();
}

ModSkySphereAnimated.prototype.getSphereModelData2 = function(data, platform, radius, height, segments, rings, skyPixels_, glowPixels_, sunX, sunY, sunZ) {
	var i = 0;
	if (data == null) {
		data = new ModelData();
		data.xyz = new Float32Array(new ArrayBuffer(rings * segments * 3 << 2));
		data.uv = new Float32Array(new ArrayBuffer(rings * segments * 2 << 2));
		data.rgba = new Uint8Array(new ArrayBuffer(rings * segments * 4));
		data.setVerticesCount(segments * rings);
		data.setIndicesCount(segments * rings * 6);
		data.setIndices(SphereModelData.calculateElements(radius, height, segments, rings));
	}
	for (var y = 0; y < rings; y++) {
		var yFloat = y;
		var phiFloat = yFloat / (rings - 1) * Game.getPi();
		for (var x = 0; x < segments; x++) {
			var xFloat = x;
			var theta = xFloat / (segments - 1) * 2 * Game.getPi();
			var vx = radius * Platform.sin(phiFloat) * Platform.cos(theta);
			var vy = height * Platform.cos(phiFloat);
			var vz = radius * Platform.sin(phiFloat) * Platform.sin(theta);
			var u = xFloat / (segments - 1);
			var v = yFloat / (rings - 1);
			data.xyz[i * 3 + 0] = vx;
			data.xyz[i * 3 + 1] = vy;
			data.xyz[i * 3 + 2] = vz;
			data.uv[i * 2 + 0] = u;
			data.uv[i * 2 + 1] = v;
			var vertexLength = platform.mathSqrt(vx * vx + vy * vy + vz * vz);
			var vertexXNormalized = vx / (vertexLength);
			var vertexYNormalized = vy / (vertexLength);
			var vertexZNormalized = vz / (vertexLength);
			var sunLength = platform.mathSqrt(sunX * sunX + sunY * sunY + sunZ * sunZ);
			if (sunLength == 0) {
				sunLength = 1;
			}
			var sunXNormalized = sunX / (sunLength);
			var sunYNormalized = sunY / (sunLength);
			var sunZNormalized = sunZ / (sunLength);
			var dx = vertexXNormalized - sunXNormalized;
			var dy = vertexYNormalized - sunYNormalized;
			var dz = vertexZNormalized - sunZNormalized;
			var proximityToSun = 1 - platform.mathSqrt(dx * dx + dy * dy + dz * dz) / (2);
			var one = 1;
			var skyColor = ModSkySphereAnimated.texture2d(platform, skyPixels_, (sunYNormalized + 2) / (4), 1 - (vertexYNormalized + 1) / (2));
			var skyColorA = (one * Game.colorA(skyColor)) / (255);
			var skyColorR = (one * Game.colorR(skyColor)) / (255);
			var skyColorG = (one * Game.colorG(skyColor)) / (255);
			var skyColorB = (one * Game.colorB(skyColor)) / (255);
			var glowColor = ModSkySphereAnimated.texture2d(platform, glowPixels_, (sunYNormalized + one) / (2), 1 - proximityToSun);
			var glowColorA = (one * Game.colorA(glowColor)) / (255);
			var glowColorR = (one * Game.colorR(glowColor)) / (255);
			var glowColorG = (one * Game.colorG(glowColor)) / (255);
			var glowColorB = (one * Game.colorB(glowColor)) / (255);
			var colorR = skyColorR + glowColorR * glowColorA;
			var colorG = skyColorG + glowColorG * glowColorA;
			var colorB = skyColorB + glowColorB * glowColorA;
			var colorA = skyColorA;
			if (colorR > 1) {
				colorR = 1;
			}
			if (colorG > 1) {
				colorG = 1;
			}
			if (colorB > 1) {
				colorB = 1;
			}
			if (colorA > 1) {
				colorA = 1;
			}
			data.rgba[i * 4 + 0] = Game.intToByte(platform.floatToInt(colorR * 255));
			data.rgba[i * 4 + 1] = Game.intToByte(platform.floatToInt(colorG * 255));
			data.rgba[i * 4 + 2] = Game.intToByte(platform.floatToInt(colorB * 255));
			data.rgba[i * 4 + 3] = Game.intToByte(platform.floatToInt(colorA * 255));
			i++;
		}
	}
	return data;
}

ModSkySphereAnimated.prototype.onNewFrameDraw3d = function(game, deltaTime) {
	game.skySphereNight = true;
	this.stars.onNewFrameDraw3d(game, deltaTime);
	game.platform.glDisableFog();
	this.drawSkySphere(game);
	game.setFog();
}

ModSkySphereAnimated.texture2d = function(platform, pixelsArgb, x, y) {
	var px = platform.floatToInt(x * 511);
	var py = platform.floatToInt(y * 511);
	px = ModSkySphereAnimated.positive_modulo(px, 511);
	py = ModSkySphereAnimated.positive_modulo(py, 511);
	return pixelsArgb[MapUtilCi.index2d(px, py, 512)];
}

ModSkySphereAnimated.positive_modulo = function(i, n) {
	return (i % n + n) % n;
}

function ModSkySphereStatic()
{
	this.skyTexture = 0;
	this.skymodel = null;
	this.skyspherenighttexture = 0;
	this.skyspheretexture = 0;
	this.skyTexture = -1;
	this.skyspheretexture = -1;
	this.skyspherenighttexture = -1;
}
ModSkySphereStatic.prototype = new ClientMod();

ModSkySphereStatic.prototype.draw = function(game, fov) {
	if (this.skyTexture == -1) {
		game.platform.throwException("InvalidOperationException");
	}
	var size = 1000;
	if (this.skymodel == null) {
		this.skymodel = game.platform.createModel(SphereModelData.getSphereModelData(size, size, 20, 20));
	}
	game.set3dProjection(size * 2, fov);
	game.gLMatrixModeModelView();
	game.gLPushMatrix();
	game.gLTranslate(game.player.position.x, game.player.position.y, game.player.position.z);
	game.platform.bindTexture2d(this.skyTexture);
	game.drawModel(this.skymodel);
	game.gLPopMatrix();
	game.set3dProjection(game.zfar(), fov);
}

ModSkySphereStatic.prototype.drawSkySphere = function(game) {
	if (this.skyspheretexture == -1) {
		var skysphereBmp = game.platform.bitmapCreateFromPng(game.getFile("skysphere.png"), game.getFileLength("skysphere.png"));
		var skysphereNightBmp = game.platform.bitmapCreateFromPng(game.getFile("skyspherenight.png"), game.getFileLength("skyspherenight.png"));
		this.skyspheretexture = game.platform.loadTextureFromBitmap(skysphereBmp);
		this.skyspherenighttexture = game.platform.loadTextureFromBitmap(skysphereNightBmp);
		game.platform.bitmapDelete(skysphereBmp);
		game.platform.bitmapDelete(skysphereNightBmp);
	}
	var texture = game.skySphereNight ? this.skyspherenighttexture : this.skyspheretexture;
	if (game.shadowssimple) {
		texture = this.skyspheretexture;
	}
	this.skyTexture = texture;
	this.draw(game, game.currentfov());
}

ModSkySphereStatic.prototype.onNewFrameDraw3d = function(game, deltaTime) {
	game.platform.glDisableFog();
	this.drawSkySphere(game);
	game.setFog();
}

function ModUnloadRendererChunks()
{
	this.chunksize = 0;
	this.game = null;
	this.mapsizexchunks = 0;
	this.mapsizeychunks = 0;
	this.mapsizezchunks = 0;
	this.unloadIterationXy = 0;
	this.unloadxyztemp = null;
	this.unloadxyztemp = new Vector3IntRef();
}
ModUnloadRendererChunks.prototype = new ClientMod();

ModUnloadRendererChunks.prototype.onReadOnlyBackgroundThread = function(game_, dt) {
	this.game = game_;
	this.chunksize = 16;
	this.mapsizexchunks = Math.floor(this.game.map.mapSizeX / this.chunksize);
	this.mapsizeychunks = Math.floor(this.game.map.mapSizeY / this.chunksize);
	this.mapsizezchunks = Math.floor(this.game.map.mapSizeZ / this.chunksize);
	var px = Math.floor(this.game.platform.floatToInt(this.game.player.position.x) / this.chunksize);
	var py = Math.floor(this.game.platform.floatToInt(this.game.player.position.z) / this.chunksize);
	var pz = Math.floor(this.game.platform.floatToInt(this.game.player.position.y) / this.chunksize);
	var chunksxy = Math.floor(Math.floor(this.mapAreaSize() / this.chunksize) / 2);
	var chunksz = Math.floor(Math.floor(this.mapAreaSizeZ() / this.chunksize) / 2);
	var startx = px - chunksxy;
	var endx = px + chunksxy;
	var starty = py - chunksxy;
	var endy = py + chunksxy;
	var startz = pz - chunksz;
	var endz = pz + chunksz;
	if (startx < 0) {
		startx = 0;
	}
	if (starty < 0) {
		starty = 0;
	}
	if (startz < 0) {
		startz = 0;
	}
	if (endx >= this.mapsizexchunks) {
		endx = this.mapsizexchunks - 1;
	}
	if (endy >= this.mapsizeychunks) {
		endy = this.mapsizeychunks - 1;
	}
	if (endz >= this.mapsizezchunks) {
		endz = this.mapsizezchunks - 1;
	}
	var mapsizexchunks_ = this.mapsizexchunks;
	var mapsizeychunks_ = this.mapsizeychunks;
	var mapsizezchunks_ = this.mapsizezchunks;
	var count;
	if (this.game.platform.isFastSystem()) {
		count = 1000;
	}
	else {
		count = 250;
	}
	for (var i = 0; i < count; i++) {
		this.unloadIterationXy++;
		if (this.unloadIterationXy >= mapsizexchunks_ * mapsizeychunks_ * mapsizezchunks_) {
			this.unloadIterationXy = 0;
		}
		MapUtilCi.posInt(this.unloadIterationXy, mapsizexchunks_, mapsizeychunks_, this.unloadxyztemp);
		var x = this.unloadxyztemp.x;
		var y = this.unloadxyztemp.y;
		var z = this.unloadxyztemp.z;
		var pos = MapUtilCi.index3d(x, y, z, mapsizexchunks_, mapsizeychunks_);
		var unloaded = false;
		var c = this.game.map.chunks[pos];
		if (c == null || c.rendered == null || c.rendered.ids == null) {
			continue;
		}
		if (x < startx || y < starty || z < startz || x > endx || y > endy || z > endz) {
			var unloadChunkPos = pos;
			var commit = new UnloadRendererChunksCommit();
			commit.game = this.game;
			commit.unloadChunkPos = unloadChunkPos;
			this.game.queueActionCommit(commit);
		}
		unloaded = true;
		if (unloaded) {
			break;
		}
	}
}

ModUnloadRendererChunks.prototype.centerAreaSize = function() {
	return Math.floor(this.game.platform.floatToInt(this.game.d_Config3d.viewdistance) / 2);
}

ModUnloadRendererChunks.prototype.mapAreaSize = function() {
	return this.game.platform.floatToInt(this.game.d_Config3d.viewdistance) * 2;
}

ModUnloadRendererChunks.prototype.mapAreaSizeZ = function() {
	return this.mapAreaSize();
}

function ModUpdateMain()
{
}
ModUpdateMain.prototype = new ClientMod();

ModUpdateMain.prototype.onReadOnlyMainThread = function(game, dt) {
	game.update(dt);
}

function ModWalkSound()
{
	this.lastwalksound = 0;
	this.one = null;
	this.stepsoundduration = null;
	this.walksoundtimer = null;
	this.one = 1;
	this.walksoundtimer = 0;
	this.lastwalksound = 0;
	this.stepsoundduration = (this.one * 4) / (10);
}
ModWalkSound.prototype = new ClientMod();

ModWalkSound.prototype.getSoundCount = function(soundwalk) {
	var count = 0;
	for (var i = 0; i < 8; i++) {
		if (soundwalk[i] != null) {
			count++;
		}
	}
	return count;
}

ModWalkSound.prototype.onNewFrameFixed = function(game, args) {
	if (game.followId() == null) {
		if (game.soundnow.value) {
			this.updateWalkSound(game, -1);
		}
		if (game.isplayeronground && game.controls.movedx != 0 || game.controls.movedy != 0) {
			this.updateWalkSound(game, args.getDt());
		}
	}
}

ModWalkSound.prototype.updateWalkSound = function(game, dt) {
	if (dt == -1) {
		dt = this.stepsoundduration / (2);
	}
	this.walksoundtimer += dt;
	var soundwalk = this.soundwalkcurrent(game);
	if (this.getSoundCount(soundwalk) == 0) {
		return;
	}
	if (this.walksoundtimer >= this.stepsoundduration) {
		this.walksoundtimer = 0;
		this.lastwalksound++;
		if (this.lastwalksound >= this.getSoundCount(soundwalk)) {
			this.lastwalksound = 0;
		}
		if (game.rnd.next() % 100 < 40) {
			this.lastwalksound = game.rnd.next() % this.getSoundCount(soundwalk);
		}
		game.audioPlay(game.platform.stringFormat("{0}.ogg", soundwalk[this.lastwalksound]));
	}
}

ModWalkSound.prototype.soundwalkcurrent = function(game) {
	var b = game.blockUnderPlayer();
	if (b != -1) {
		return game.d_Data.walkSound()[b];
	}
	return game.d_Data.walkSound()[0];
}

function Model()
{
}

function ModelData()
{
	this.indices = null;
	this.indicesCount = 0;
	this.indicesMax = 0;
	this.mode = 0;
	this.rgba = null;
	this.uv = null;
	this.verticesCount = 0;
	this.verticesMax = 0;
	this.xyz = null;
}

ModelData.prototype.getIndicesCount = function() {
	return this.indicesCount;
}

ModelData.prototype.getRgbaCount = function() {
	return this.verticesCount * 4;
}

ModelData.prototype.getUvCount = function() {
	return this.verticesCount * 2;
}

ModelData.prototype.getVerticesCount = function() {
	return this.verticesCount;
}

ModelData.prototype.getXyzCount = function() {
	return this.verticesCount * 3;
}

ModelData.prototype.setIndicesCount = function(value) {
	this.indicesCount = value;
}

ModelData.prototype.setVerticesCount = function(value) {
	this.verticesCount = value;
}

ModelData.prototype.getIndices = function() {
	return this.indices;
}

ModelData.prototype.getMode = function() {
	return this.mode;
}

ModelData.prototype.getRgba = function() {
	return this.rgba;
}

ModelData.prototype.getUv = function() {
	return this.uv;
}

ModelData.prototype.getXyz = function() {
	return this.xyz;
}

ModelData.prototype.setIndices = function(p) {
	this.indices = p;
}

ModelData.prototype.setMode = function(p) {
	this.mode = p;
}

ModelData.prototype.setRgba = function(p) {
	this.rgba = p;
}

ModelData.prototype.setUv = function(p) {
	this.uv = p;
}

ModelData.prototype.setXyz = function(p) {
	this.xyz = p;
}

function ModelDataTool()
{
}

ModelDataTool.addIndex = function(model, index) {
	if (model.indicesCount >= model.indicesMax) {
		var indicesCount = model.indicesCount;
		var indices = new Int32Array(new ArrayBuffer(indicesCount * 2 << 2));
		for (var i = 0; i < indicesCount; i++) {
			indices[i] = model.indices[i];
		}
		model.indices = indices;
		model.indicesMax = model.indicesMax * 2;
	}
	model.indices[model.indicesCount++] = index;
}

ModelDataTool.addVertex = function(model, x, y, z, u, v, color) {
	if (model.verticesCount >= model.verticesMax) {
		var xyzCount = model.getXyzCount();
		var xyz = new Float32Array(new ArrayBuffer(xyzCount * 2 << 2));
		for (var i = 0; i < xyzCount; i++) {
			xyz[i] = model.xyz[i];
		}
		var uvCount = model.getUvCount();
		var uv = new Float32Array(new ArrayBuffer(uvCount * 2 << 2));
		for (var i = 0; i < uvCount; i++) {
			uv[i] = model.uv[i];
		}
		var rgbaCount = model.getRgbaCount();
		var rgba = new Uint8Array(new ArrayBuffer(rgbaCount * 2));
		for (var i = 0; i < rgbaCount; i++) {
			rgba[i] = model.rgba[i];
		}
		model.xyz = xyz;
		model.uv = uv;
		model.rgba = rgba;
		model.verticesMax = model.verticesMax * 2;
	}
	model.xyz[model.getXyzCount() + 0] = x;
	model.xyz[model.getXyzCount() + 1] = y;
	model.xyz[model.getXyzCount() + 2] = z;
	model.uv[model.getUvCount() + 0] = u;
	model.uv[model.getUvCount() + 1] = v;
	model.rgba[model.getRgbaCount() + 0] = Game.intToByte(Game.colorR(color));
	model.rgba[model.getRgbaCount() + 1] = Game.intToByte(Game.colorG(color));
	model.rgba[model.getRgbaCount() + 2] = Game.intToByte(Game.colorB(color));
	model.rgba[model.getRgbaCount() + 3] = Game.intToByte(Game.colorA(color));
	model.verticesCount++;
}

function MonitorObject()
{
}

function MouseButtonEnum()
{
}
MouseButtonEnum.LEFT = 0;
MouseButtonEnum.MIDDLE = 1;
MouseButtonEnum.RIGHT = 2;

function MouseEventArgs()
{
	this.button = 0;
	this.emulated = false;
	this.forceUsage = false;
	this.handled = false;
	this.movementX = 0;
	this.movementY = 0;
	this.x = 0;
	this.y = 0;
}

MouseEventArgs.prototype.getButton = function() {
	return this.button;
}

MouseEventArgs.prototype.getEmulated = function() {
	return this.emulated;
}

MouseEventArgs.prototype.getForceUsage = function() {
	return this.forceUsage;
}

MouseEventArgs.prototype.getHandled = function() {
	return this.handled;
}

MouseEventArgs.prototype.getMovementX = function() {
	return this.movementX;
}

MouseEventArgs.prototype.getMovementY = function() {
	return this.movementY;
}

MouseEventArgs.prototype.getX = function() {
	return this.x;
}

MouseEventArgs.prototype.getY = function() {
	return this.y;
}

MouseEventArgs.prototype.setButton = function(value) {
	this.button = value;
}

MouseEventArgs.prototype.setEmulated = function(value) {
	this.emulated = value;
}

MouseEventArgs.prototype.setForceUsage = function(value) {
	this.forceUsage = value;
}

MouseEventArgs.prototype.setHandled = function(value) {
	this.handled = value;
}

MouseEventArgs.prototype.setMovementX = function(value) {
	this.movementX = value;
}

MouseEventArgs.prototype.setMovementY = function(value) {
	this.movementY = value;
}

MouseEventArgs.prototype.setX = function(value) {
	this.x = value;
}

MouseEventArgs.prototype.setY = function(value) {
	this.y = value;
}

function MouseWheelEventArgs()
{
	this.delta = 0;
	this.deltaPrecise = null;
}

MouseWheelEventArgs.prototype.getDelta = function() {
	return this.delta;
}

MouseWheelEventArgs.prototype.getDeltaPrecise = function() {
	return this.deltaPrecise;
}

MouseWheelEventArgs.prototype.setDelta = function(value) {
	this.delta = value;
}

MouseWheelEventArgs.prototype.setDeltaPrecise = function(value) {
	this.deltaPrecise = value;
}

var MyNetDeliveryMethod = {
	UNKNOWN : 0,
	UNRELIABLE : 1,
	UNRELIABLE_SEQUENCED : 2,
	RELIABLE_UNORDERED : 3,
	RELIABLE_SEQUENCED : 4,
	RELIABLE_ORDERED : 5
}

function NetIncomingMessage()
{
	this.senderConnection = null;
	this.type = NetworkMessageType.DATA;
	this.message = null;
	this.messageLength = 0;
}

function NetworkInterpolation()
{
	this.dELAYMILLISECONDS = 0;
	this.eXTRAPOLATE = false;
	this.eXTRAPOLATION_TIMEMILLISECONDS = 0;
	this.received = null;
	this.receivedCount = 0;
	this.req = null;
	this.received = new Array(128);
	this.dELAYMILLISECONDS = 200;
	this.eXTRAPOLATION_TIMEMILLISECONDS = 200;
}
NetworkInterpolation.prototype = new INetworkInterpolation();

NetworkInterpolation.prototype.addNetworkPacket = function(c, timeMilliseconds) {
	var p = new Packet_();
	p.content = c;
	p.timestampMilliseconds = timeMilliseconds;
	var max = 100;
	if (this.receivedCount >= max) {
		for (var i = 0; i < max - 1; i++) {
			this.received[i] = this.received[i + 1];
		}
		this.receivedCount = max - 1;
	}
	this.received[this.receivedCount++] = p;
}

NetworkInterpolation.prototype.interpolatedState = function(timeMilliseconds) {
	var curtimeMilliseconds = timeMilliseconds;
	var interpolationtimeMilliseconds = curtimeMilliseconds - this.dELAYMILLISECONDS;
	var p1;
	var p2;
	if (this.receivedCount == 0) {
		return null;
	}
	var result;
	if (this.receivedCount > 0 && interpolationtimeMilliseconds < this.received[0].timestampMilliseconds) {
		p1 = 0;
		p2 = 0;
	}
	else if (this.eXTRAPOLATE && this.receivedCount >= 2 && interpolationtimeMilliseconds > this.received[this.receivedCount - 1].timestampMilliseconds) {
		p1 = this.receivedCount - 2;
		p2 = this.receivedCount - 1;
		interpolationtimeMilliseconds = MathCi.minInt(interpolationtimeMilliseconds, this.received[this.receivedCount - 1].timestampMilliseconds + this.eXTRAPOLATION_TIMEMILLISECONDS);
	}
	else {
		p1 = 0;
		for (var i = 0; i < this.receivedCount; i++) {
			if (this.received[i].timestampMilliseconds <= interpolationtimeMilliseconds) {
				p1 = i;
			}
		}
		p2 = p1;
		if (this.receivedCount - 1 > p1) {
			p2++;
		}
	}
	if (p1 == p2) {
		result = this.received[p1].content;
	}
	else {
		var one = 1;
		result = this.req.interpolate(this.received[p1].content, this.received[p2].content, (one * (interpolationtimeMilliseconds - this.received[p1].timestampMilliseconds)) / (this.received[p2].timestampMilliseconds - this.received[p1].timestampMilliseconds));
	}
	return result;
}

var NetworkMessageType = {
	DATA : 0,
	CONNECT : 1,
	DISCONNECT : 2
}

function NewFrameEventArgs()
{
	this.dt = null;
}

NewFrameEventArgs.prototype.getDt = function() {
	return this.dt;
}

NewFrameEventArgs.prototype.setDt = function(p) {
	this.dt = p;
}

function Node()
{
	this.head = null;
	this.name = null;
	this.parentName = null;
	this.pivotx = null;
	this.pivoty = null;
	this.pivotz = null;
	this.posx = null;
	this.posy = null;
	this.posz = null;
	this.rotatex = null;
	this.rotatey = null;
	this.rotatez = null;
	this.scalex = null;
	this.scaley = null;
	this.scalez = null;
	this.sizex = null;
	this.sizey = null;
	this.sizez = null;
	this.u = null;
	this.v = null;
}

function NotifyMapAction()
{
	this.clientId = 0;
	this.server = null;
}
NotifyMapAction.prototype = new Action_();

NotifyMapAction.prototype.loadAndSendChunk = function(x, y, z) {
	var c = this.server.clients[this.clientId];
	var pos = MapUtilCi.index2d(x, y, Math.floor(this.server.mapSizeX / 32));
	if (c.chunksseen[pos] == null) {
		c.chunksseen[pos] = new Array(Math.floor(this.server.mapSizeZ / 32));
	}
	c.chunksseen[pos][z] = true;
	var chunk = new Int32Array(new ArrayBuffer(32768 << 2));
	for (var i = 0; i < this.server.modsCount; i++) {
		this.server.mods[i].generateChunk(x, y, z, chunk);
	}
	var chunkBytes = MiscCi.ushortArrayToByteArray(chunk, 32768);
	var compressedLength = new IntRef();
	var chunkCompressed = this.server.platform.gzipCompress(chunkBytes, 65536, compressedLength);
	this.server.queueMainThreadAction(SendPacketAction.create(this.server, this.clientId, ServerPackets.chunkPart(chunkCompressed)));
	this.server.queueMainThreadAction(SendPacketAction.create(this.server, this.clientId, ServerPackets.chunk_(x * 32, y * 32, z * 32, 32)));
}

NotifyMapAction.prototype.nearestDirty = function(clientid, playerx, playery, playerz, retNearest) {
	var nearestdist = 2147483647;
	retNearest[0] = -1;
	retNearest[1] = -1;
	retNearest[2] = -1;
	var px = Math.floor(playerx / 32);
	var py = Math.floor(playery / 32);
	var pz = Math.floor(playerz / 32);
	var chunksxy = Math.floor(Math.floor(this.mapAreaSize() / 32) / 2);
	var chunksz = Math.floor(Math.floor(this.mapAreaSizeZ() / 32) / 2);
	var startx = px - chunksxy;
	var endx = px + chunksxy;
	var starty = py - chunksxy;
	var endy = py + chunksxy;
	var startz = pz - chunksz;
	var endz = pz + chunksz;
	if (startx < 0) {
		startx = 0;
	}
	if (starty < 0) {
		starty = 0;
	}
	if (startz < 0) {
		startz = 0;
	}
	if (endx >= this.mapsizexchunks()) {
		endx = this.mapsizexchunks() - 1;
	}
	if (endy >= this.mapsizeychunks()) {
		endy = this.mapsizeychunks() - 1;
	}
	if (endz >= this.mapsizezchunks()) {
		endz = this.mapsizezchunks() - 1;
	}
	var client = this.server.clients[clientid];
	for (var x = startx; x <= endx; x++) {
		for (var y = starty; y <= endy; y++) {
			var pos = MapUtilCi.index2d(x, y, Math.floor(this.server.mapSizeX / 32));
			if (client.chunksseen[pos] == null) {
				client.chunksseen[pos] = new Array(Math.floor(this.server.mapSizeZ / 32));
			}
			for (var z = startz; z <= endz; z++) {
				var column = client.chunksseen[pos];
				if (column[z]) {
					continue;
				}
				{
					var dx = px - x;
					var dy = py - y;
					var dz = pz - z;
					var dist = dx * dx + dy * dy + dz * dz;
					if (dist < nearestdist) {
						nearestdist = dist;
						retNearest[0] = x;
						retNearest[1] = y;
						retNearest[2] = z;
					}
				}
			}
		}
	}
}

NotifyMapAction.prototype.run = function() {
	var nearest = new Int32Array(new ArrayBuffer(3 << 2));
	var client = this.server.clients[this.clientId];
	var x = this.server.platform.floatToInt(client.glX);
	var y = this.server.platform.floatToInt(client.glZ);
	var z = this.server.platform.floatToInt(client.glY);
	this.nearestDirty(this.clientId, x, y, z, nearest);
	if (nearest[0] != -1) {
		this.loadAndSendChunk(nearest[0], nearest[1], nearest[2]);
	}
	this.server.clients[this.clientId].notifyMapAction = null;
}

NotifyMapAction.prototype.mapAreaSize = function() {
	return this.server.chunkdrawdistance * 32 * 2;
}

NotifyMapAction.prototype.mapAreaSizeZ = function() {
	return this.mapAreaSize();
}

NotifyMapAction.prototype.mapsizexchunks = function() {
	return Math.floor(this.server.mapSizeX / 32);
}

NotifyMapAction.prototype.mapsizeychunks = function() {
	return Math.floor(this.server.mapSizeY / 32);
}

NotifyMapAction.prototype.mapsizezchunks = function() {
	return Math.floor(this.server.mapSizeZ / 32);
}

function OnCrashHandler()
{
}

OnCrashHandler.prototype.onCrash = function() {
}

function OnCrashHandlerLeave()
{
	this.g = null;
}
OnCrashHandlerLeave.prototype = new OnCrashHandler();

OnCrashHandlerLeave.create = function(game) {
	var oncrash = new OnCrashHandlerLeave();
	oncrash.g = game;
	return oncrash;
}

OnCrashHandlerLeave.prototype.onCrash = function() {
	this.g.sendLeave(1);
}

function OnUseEntityArgs()
{
	this.entityId = 0;
}

function OptionsCi()
{
	this.blockShadowSave = null;
	this.clientLanguage = null;
	this.drawDistance = 0;
	this.enableAutoJump = false;
	this.enableBlockShadow = false;
	this.enableSound = false;
	this.font = 0;
	this.framerate = 0;
	this.fullscreen = false;
	this.keys = null;
	this.resolution = 0;
	this.shadows = false;
	this.smoothshadows = false;
	this.useServerTextures = false;
	var one = 1;
	this.shadows = false;
	this.font = 0;
	this.drawDistance = 32;
	this.useServerTextures = true;
	this.enableSound = true;
	this.enableAutoJump = false;
	this.clientLanguage = "";
	this.framerate = 0;
	this.resolution = 0;
	this.fullscreen = false;
	this.smoothshadows = true;
	this.blockShadowSave = (one * 6) / (10);
	this.enableBlockShadow = true;
	this.keys = new Int32Array(new ArrayBuffer(256 << 2));
}

function PacketHandlerCraftingRecipes()
{
	this.mod = null;
}
PacketHandlerCraftingRecipes.prototype = new ClientPacketHandler();

PacketHandlerCraftingRecipes.prototype.handle = function(game, packet) {
	this.mod.d_CraftingRecipes = packet.craftingRecipes.craftingRecipes;
	this.mod.d_CraftingRecipesCount = packet.craftingRecipes.craftingRecipesCount;
}

function Packet_()
{
	this.content = null;
	this.timestampMilliseconds = 0;
}

function Packet_BlockSetModeEnum()
{
}
Packet_BlockSetModeEnum.CREATE = 1;
Packet_BlockSetModeEnum.DESTROY = 0;
Packet_BlockSetModeEnum.USE = 2;
Packet_BlockSetModeEnum.USE_WITH_TOOL = 3;

function Packet_BlockType()
{
	this.aimRadiusFloat = 0;
	this.ammoMagazine = 0;
	this.ammoTotal = 0;
	this.bulletsPerShotFloat = 0;
	this.damageBodyFloat = 0;
	this.damageHeadFloat = 0;
	this.damageToPlayer = 0;
	this.delayFloat = 0;
	this.drawType = 0;
	this.explosionRangeFloat = 0;
	this.explosionTimeFloat = 0;
	this.handimage = null;
	this.ironSightsAimRadiusFloat = 0;
	this.ironSightsEnabled = false;
	this.ironSightsFovFloat = 0;
	this.ironSightsImage = null;
	this.ironSightsMoveSpeedFloat = 0;
	this.isBuildable = false;
	this.isPistol = false;
	this.isSlipperyWalk = false;
	this.isTool = false;
	this.isUsable = false;
	this.lightRadius = 0;
	this.name = null;
	this.pickDistanceWhenUsedFloat = 0;
	this.pistolType = 0;
	this.projectileBounce = false;
	this.projectileSpeedFloat = 0;
	this.rail = 0;
	this.recoilFloat = 0;
	this.reloadDelayFloat = 0;
	this.sounds = null;
	this.startInventoryAmount = 0;
	this.strength = 0;
	this.textureIdBack = null;
	this.textureIdBottom = null;
	this.textureIdForInventory = null;
	this.textureIdFront = null;
	this.textureIdLeft = null;
	this.textureIdRight = null;
	this.textureIdTop = null;
	this.walkSpeedFloat = 0;
	this.walkSpeedWhenUsedFloat = 0;
	this.walkableType = 0;
	this.whenPlacedGetsConvertedTo = 0;
}

Packet_BlockType.prototype.getAimRadiusFloat = function() {
	return this.aimRadiusFloat;
}

Packet_BlockType.prototype.getAmmoMagazine = function() {
	return this.ammoMagazine;
}

Packet_BlockType.prototype.getAmmoTotal = function() {
	return this.ammoTotal;
}

Packet_BlockType.prototype.getBulletsPerShotFloat = function() {
	return this.bulletsPerShotFloat;
}

Packet_BlockType.prototype.getDamageBodyFloat = function() {
	return this.damageBodyFloat;
}

Packet_BlockType.prototype.getDamageHeadFloat = function() {
	return this.damageHeadFloat;
}

Packet_BlockType.prototype.getDamageToPlayer = function() {
	return this.damageToPlayer;
}

Packet_BlockType.prototype.getDelayFloat = function() {
	return this.delayFloat;
}

Packet_BlockType.prototype.getDrawType = function() {
	return this.drawType;
}

Packet_BlockType.prototype.getExplosionRangeFloat = function() {
	return this.explosionRangeFloat;
}

Packet_BlockType.prototype.getExplosionTimeFloat = function() {
	return this.explosionTimeFloat;
}

Packet_BlockType.prototype.getHandimage = function() {
	return this.handimage;
}

Packet_BlockType.prototype.getIronSightsAimRadiusFloat = function() {
	return this.ironSightsAimRadiusFloat;
}

Packet_BlockType.prototype.getIronSightsEnabled = function() {
	return this.ironSightsEnabled;
}

Packet_BlockType.prototype.getIronSightsFovFloat = function() {
	return this.ironSightsFovFloat;
}

Packet_BlockType.prototype.getIronSightsImage = function() {
	return this.ironSightsImage;
}

Packet_BlockType.prototype.getIronSightsMoveSpeedFloat = function() {
	return this.ironSightsMoveSpeedFloat;
}

Packet_BlockType.prototype.getIsBuildable = function() {
	return this.isBuildable;
}

Packet_BlockType.prototype.getIsPistol = function() {
	return this.isPistol;
}

Packet_BlockType.prototype.getIsSlipperyWalk = function() {
	return this.isSlipperyWalk;
}

Packet_BlockType.prototype.getIsTool = function() {
	return this.isTool;
}

Packet_BlockType.prototype.getIsUsable = function() {
	return this.isUsable;
}

Packet_BlockType.prototype.getLightRadius = function() {
	return this.lightRadius;
}

Packet_BlockType.prototype.getName = function() {
	return this.name;
}

Packet_BlockType.prototype.getPickDistanceWhenUsedFloat = function() {
	return this.pickDistanceWhenUsedFloat;
}

Packet_BlockType.prototype.getPistolType = function() {
	return this.pistolType;
}

Packet_BlockType.prototype.getProjectileBounce = function() {
	return this.projectileBounce;
}

Packet_BlockType.prototype.getProjectileSpeedFloat = function() {
	return this.projectileSpeedFloat;
}

Packet_BlockType.prototype.getRail = function() {
	return this.rail;
}

Packet_BlockType.prototype.getRecoilFloat = function() {
	return this.recoilFloat;
}

Packet_BlockType.prototype.getReloadDelayFloat = function() {
	return this.reloadDelayFloat;
}

Packet_BlockType.prototype.getSounds = function() {
	return this.sounds;
}

Packet_BlockType.prototype.getStartInventoryAmount = function() {
	return this.startInventoryAmount;
}

Packet_BlockType.prototype.getStrength = function() {
	return this.strength;
}

Packet_BlockType.prototype.getTextureIdBack = function() {
	return this.textureIdBack;
}

Packet_BlockType.prototype.getTextureIdBottom = function() {
	return this.textureIdBottom;
}

Packet_BlockType.prototype.getTextureIdForInventory = function() {
	return this.textureIdForInventory;
}

Packet_BlockType.prototype.getTextureIdFront = function() {
	return this.textureIdFront;
}

Packet_BlockType.prototype.getTextureIdLeft = function() {
	return this.textureIdLeft;
}

Packet_BlockType.prototype.getTextureIdRight = function() {
	return this.textureIdRight;
}

Packet_BlockType.prototype.getTextureIdTop = function() {
	return this.textureIdTop;
}

Packet_BlockType.prototype.getWalkSpeedFloat = function() {
	return this.walkSpeedFloat;
}

Packet_BlockType.prototype.getWalkSpeedWhenUsedFloat = function() {
	return this.walkSpeedWhenUsedFloat;
}

Packet_BlockType.prototype.getWalkableType = function() {
	return this.walkableType;
}

Packet_BlockType.prototype.getWhenPlacedGetsConvertedTo = function() {
	return this.whenPlacedGetsConvertedTo;
}

Packet_BlockType.prototype.setAimRadiusFloat = function(value) {
	this.aimRadiusFloat = value;
}

Packet_BlockType.prototype.setAmmoMagazine = function(value) {
	this.ammoMagazine = value;
}

Packet_BlockType.prototype.setAmmoTotal = function(value) {
	this.ammoTotal = value;
}

Packet_BlockType.prototype.setBulletsPerShotFloat = function(value) {
	this.bulletsPerShotFloat = value;
}

Packet_BlockType.prototype.setDamageBodyFloat = function(value) {
	this.damageBodyFloat = value;
}

Packet_BlockType.prototype.setDamageHeadFloat = function(value) {
	this.damageHeadFloat = value;
}

Packet_BlockType.prototype.setDamageToPlayer = function(value) {
	this.damageToPlayer = value;
}

Packet_BlockType.prototype.setDelayFloat = function(value) {
	this.delayFloat = value;
}

Packet_BlockType.prototype.setDrawType = function(value) {
	this.drawType = value;
}

Packet_BlockType.prototype.setExplosionRangeFloat = function(value) {
	this.explosionRangeFloat = value;
}

Packet_BlockType.prototype.setExplosionTimeFloat = function(value) {
	this.explosionTimeFloat = value;
}

Packet_BlockType.prototype.setHandimage = function(value) {
	this.handimage = value;
}

Packet_BlockType.prototype.setIronSightsAimRadiusFloat = function(value) {
	this.ironSightsAimRadiusFloat = value;
}

Packet_BlockType.prototype.setIronSightsEnabled = function(value) {
	this.ironSightsEnabled = value;
}

Packet_BlockType.prototype.setIronSightsFovFloat = function(value) {
	this.ironSightsFovFloat = value;
}

Packet_BlockType.prototype.setIronSightsImage = function(value) {
	this.ironSightsImage = value;
}

Packet_BlockType.prototype.setIronSightsMoveSpeedFloat = function(value) {
	this.ironSightsMoveSpeedFloat = value;
}

Packet_BlockType.prototype.setIsBuildable = function(value) {
	this.isBuildable = value;
}

Packet_BlockType.prototype.setIsPistol = function(value) {
	this.isPistol = value;
}

Packet_BlockType.prototype.setIsSlipperyWalk = function(value) {
	this.isSlipperyWalk = value;
}

Packet_BlockType.prototype.setIsTool = function(value) {
	this.isTool = value;
}

Packet_BlockType.prototype.setIsUsable = function(value) {
	this.isUsable = value;
}

Packet_BlockType.prototype.setLightRadius = function(value) {
	this.lightRadius = value;
}

Packet_BlockType.prototype.setName = function(value) {
	this.name = value;
}

Packet_BlockType.prototype.setPickDistanceWhenUsedFloat = function(value) {
	this.pickDistanceWhenUsedFloat = value;
}

Packet_BlockType.prototype.setPistolType = function(value) {
	this.pistolType = value;
}

Packet_BlockType.prototype.setProjectileBounce = function(value) {
	this.projectileBounce = value;
}

Packet_BlockType.prototype.setProjectileSpeedFloat = function(value) {
	this.projectileSpeedFloat = value;
}

Packet_BlockType.prototype.setRail = function(value) {
	this.rail = value;
}

Packet_BlockType.prototype.setRecoilFloat = function(value) {
	this.recoilFloat = value;
}

Packet_BlockType.prototype.setReloadDelayFloat = function(value) {
	this.reloadDelayFloat = value;
}

Packet_BlockType.prototype.setSounds = function(value) {
	this.sounds = value;
}

Packet_BlockType.prototype.setStartInventoryAmount = function(value) {
	this.startInventoryAmount = value;
}

Packet_BlockType.prototype.setStrength = function(value) {
	this.strength = value;
}

Packet_BlockType.prototype.setTextureIdBack = function(value) {
	this.textureIdBack = value;
}

Packet_BlockType.prototype.setTextureIdBottom = function(value) {
	this.textureIdBottom = value;
}

Packet_BlockType.prototype.setTextureIdForInventory = function(value) {
	this.textureIdForInventory = value;
}

Packet_BlockType.prototype.setTextureIdFront = function(value) {
	this.textureIdFront = value;
}

Packet_BlockType.prototype.setTextureIdLeft = function(value) {
	this.textureIdLeft = value;
}

Packet_BlockType.prototype.setTextureIdRight = function(value) {
	this.textureIdRight = value;
}

Packet_BlockType.prototype.setTextureIdTop = function(value) {
	this.textureIdTop = value;
}

Packet_BlockType.prototype.setWalkSpeedFloat = function(value) {
	this.walkSpeedFloat = value;
}

Packet_BlockType.prototype.setWalkSpeedWhenUsedFloat = function(value) {
	this.walkSpeedWhenUsedFloat = value;
}

Packet_BlockType.prototype.setWalkableType = function(value) {
	this.walkableType = value;
}

Packet_BlockType.prototype.setWhenPlacedGetsConvertedTo = function(value) {
	this.whenPlacedGetsConvertedTo = value;
}

function Packet_BlockTypeSerializer()
{
}

Packet_BlockTypeSerializer.deserialize = function(stream, instance) {
	instance.drawType = 0;
	instance.walkableType = 0;
	instance.pistolType = 0;
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.textureIdTop = ProtocolParser.readString(stream);
			continue;
		case 18:
			instance.textureIdBottom = ProtocolParser.readString(stream);
			continue;
		case 26:
			instance.textureIdFront = ProtocolParser.readString(stream);
			continue;
		case 34:
			instance.textureIdBack = ProtocolParser.readString(stream);
			continue;
		case 42:
			instance.textureIdLeft = ProtocolParser.readString(stream);
			continue;
		case 50:
			instance.textureIdRight = ProtocolParser.readString(stream);
			continue;
		case 58:
			instance.textureIdForInventory = ProtocolParser.readString(stream);
			continue;
		case 64:
			instance.drawType = ProtocolParser.readUInt64(stream);
			continue;
		case 72:
			instance.walkableType = ProtocolParser.readUInt64(stream);
			continue;
		case 80:
			instance.rail = ProtocolParser.readUInt64(stream);
			continue;
		case 88:
			instance.walkSpeedFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 96:
			instance.isSlipperyWalk = ProtocolParser.readBool(stream);
			continue;
		case 106:
			if (instance.sounds == null)
				instance.sounds = Packet_SoundSetSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_SoundSetSerializer.deserializeLengthDelimited(stream, instance.sounds);
			continue;
		case 112:
			instance.lightRadius = ProtocolParser.readUInt64(stream);
			continue;
		case 120:
			instance.startInventoryAmount = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		case 16:
			if (key.getWireType() != 0)
				break;
			instance.strength = ProtocolParser.readUInt64(stream);
			continue;
		case 17:
			if (key.getWireType() != 2)
				break;
			instance.name = ProtocolParser.readString(stream);
			continue;
		case 18:
			if (key.getWireType() != 0)
				break;
			instance.isBuildable = ProtocolParser.readBool(stream);
			continue;
		case 19:
			if (key.getWireType() != 0)
				break;
			instance.isUsable = ProtocolParser.readBool(stream);
			continue;
		case 20:
			if (key.getWireType() != 0)
				break;
			instance.isTool = ProtocolParser.readBool(stream);
			continue;
		case 21:
			if (key.getWireType() != 2)
				break;
			instance.handimage = ProtocolParser.readString(stream);
			continue;
		case 22:
			if (key.getWireType() != 0)
				break;
			instance.isPistol = ProtocolParser.readBool(stream);
			continue;
		case 23:
			if (key.getWireType() != 0)
				break;
			instance.aimRadiusFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			if (key.getWireType() != 0)
				break;
			instance.recoilFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 25:
			if (key.getWireType() != 0)
				break;
			instance.delayFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 26:
			if (key.getWireType() != 0)
				break;
			instance.bulletsPerShotFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 27:
			if (key.getWireType() != 0)
				break;
			instance.walkSpeedWhenUsedFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 28:
			if (key.getWireType() != 0)
				break;
			instance.ironSightsEnabled = ProtocolParser.readBool(stream);
			continue;
		case 29:
			if (key.getWireType() != 0)
				break;
			instance.ironSightsMoveSpeedFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 30:
			if (key.getWireType() != 2)
				break;
			instance.ironSightsImage = ProtocolParser.readString(stream);
			continue;
		case 31:
			if (key.getWireType() != 0)
				break;
			instance.ironSightsAimRadiusFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			if (key.getWireType() != 0)
				break;
			instance.ironSightsFovFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 33:
			if (key.getWireType() != 0)
				break;
			instance.ammoMagazine = ProtocolParser.readUInt64(stream);
			continue;
		case 34:
			if (key.getWireType() != 0)
				break;
			instance.ammoTotal = ProtocolParser.readUInt64(stream);
			continue;
		case 35:
			if (key.getWireType() != 0)
				break;
			instance.reloadDelayFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 36:
			if (key.getWireType() != 0)
				break;
			instance.explosionRangeFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 37:
			if (key.getWireType() != 0)
				break;
			instance.explosionTimeFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 38:
			if (key.getWireType() != 0)
				break;
			instance.projectileSpeedFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 39:
			if (key.getWireType() != 0)
				break;
			instance.projectileBounce = ProtocolParser.readBool(stream);
			continue;
		case 40:
			if (key.getWireType() != 0)
				break;
			instance.damageBodyFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 41:
			if (key.getWireType() != 0)
				break;
			instance.damageHeadFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 42:
			if (key.getWireType() != 0)
				break;
			instance.pistolType = ProtocolParser.readUInt64(stream);
			continue;
		case 43:
			if (key.getWireType() != 0)
				break;
			instance.damageToPlayer = ProtocolParser.readUInt64(stream);
			continue;
		case 44:
			if (key.getWireType() != 0)
				break;
			instance.whenPlacedGetsConvertedTo = ProtocolParser.readUInt64(stream);
			continue;
		case 45:
			if (key.getWireType() != 0)
				break;
			instance.pickDistanceWhenUsedFloat = ProtocolParser.readUInt64(stream);
			continue;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_BlockTypeSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_BlockTypeSerializer.deserialize(ms, instance);
	return instance;
}

Packet_BlockTypeSerializer.deserializeLength = function(stream, length, instance) {
	instance.drawType = 0;
	instance.walkableType = 0;
	instance.pistolType = 0;
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.textureIdTop = ProtocolParser.readString(stream);
			continue;
		case 18:
			instance.textureIdBottom = ProtocolParser.readString(stream);
			continue;
		case 26:
			instance.textureIdFront = ProtocolParser.readString(stream);
			continue;
		case 34:
			instance.textureIdBack = ProtocolParser.readString(stream);
			continue;
		case 42:
			instance.textureIdLeft = ProtocolParser.readString(stream);
			continue;
		case 50:
			instance.textureIdRight = ProtocolParser.readString(stream);
			continue;
		case 58:
			instance.textureIdForInventory = ProtocolParser.readString(stream);
			continue;
		case 64:
			instance.drawType = ProtocolParser.readUInt64(stream);
			continue;
		case 72:
			instance.walkableType = ProtocolParser.readUInt64(stream);
			continue;
		case 80:
			instance.rail = ProtocolParser.readUInt64(stream);
			continue;
		case 88:
			instance.walkSpeedFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 96:
			instance.isSlipperyWalk = ProtocolParser.readBool(stream);
			continue;
		case 106:
			if (instance.sounds == null)
				instance.sounds = Packet_SoundSetSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_SoundSetSerializer.deserializeLengthDelimited(stream, instance.sounds);
			continue;
		case 112:
			instance.lightRadius = ProtocolParser.readUInt64(stream);
			continue;
		case 120:
			instance.startInventoryAmount = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		case 16:
			if (key.getWireType() != 0)
				break;
			instance.strength = ProtocolParser.readUInt64(stream);
			continue;
		case 17:
			if (key.getWireType() != 2)
				break;
			instance.name = ProtocolParser.readString(stream);
			continue;
		case 18:
			if (key.getWireType() != 0)
				break;
			instance.isBuildable = ProtocolParser.readBool(stream);
			continue;
		case 19:
			if (key.getWireType() != 0)
				break;
			instance.isUsable = ProtocolParser.readBool(stream);
			continue;
		case 20:
			if (key.getWireType() != 0)
				break;
			instance.isTool = ProtocolParser.readBool(stream);
			continue;
		case 21:
			if (key.getWireType() != 2)
				break;
			instance.handimage = ProtocolParser.readString(stream);
			continue;
		case 22:
			if (key.getWireType() != 0)
				break;
			instance.isPistol = ProtocolParser.readBool(stream);
			continue;
		case 23:
			if (key.getWireType() != 0)
				break;
			instance.aimRadiusFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			if (key.getWireType() != 0)
				break;
			instance.recoilFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 25:
			if (key.getWireType() != 0)
				break;
			instance.delayFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 26:
			if (key.getWireType() != 0)
				break;
			instance.bulletsPerShotFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 27:
			if (key.getWireType() != 0)
				break;
			instance.walkSpeedWhenUsedFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 28:
			if (key.getWireType() != 0)
				break;
			instance.ironSightsEnabled = ProtocolParser.readBool(stream);
			continue;
		case 29:
			if (key.getWireType() != 0)
				break;
			instance.ironSightsMoveSpeedFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 30:
			if (key.getWireType() != 2)
				break;
			instance.ironSightsImage = ProtocolParser.readString(stream);
			continue;
		case 31:
			if (key.getWireType() != 0)
				break;
			instance.ironSightsAimRadiusFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			if (key.getWireType() != 0)
				break;
			instance.ironSightsFovFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 33:
			if (key.getWireType() != 0)
				break;
			instance.ammoMagazine = ProtocolParser.readUInt64(stream);
			continue;
		case 34:
			if (key.getWireType() != 0)
				break;
			instance.ammoTotal = ProtocolParser.readUInt64(stream);
			continue;
		case 35:
			if (key.getWireType() != 0)
				break;
			instance.reloadDelayFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 36:
			if (key.getWireType() != 0)
				break;
			instance.explosionRangeFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 37:
			if (key.getWireType() != 0)
				break;
			instance.explosionTimeFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 38:
			if (key.getWireType() != 0)
				break;
			instance.projectileSpeedFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 39:
			if (key.getWireType() != 0)
				break;
			instance.projectileBounce = ProtocolParser.readBool(stream);
			continue;
		case 40:
			if (key.getWireType() != 0)
				break;
			instance.damageBodyFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 41:
			if (key.getWireType() != 0)
				break;
			instance.damageHeadFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 42:
			if (key.getWireType() != 0)
				break;
			instance.pistolType = ProtocolParser.readUInt64(stream);
			continue;
		case 43:
			if (key.getWireType() != 0)
				break;
			instance.damageToPlayer = ProtocolParser.readUInt64(stream);
			continue;
		case 44:
			if (key.getWireType() != 0)
				break;
			instance.whenPlacedGetsConvertedTo = ProtocolParser.readUInt64(stream);
			continue;
		case 45:
			if (key.getWireType() != 0)
				break;
			instance.pickDistanceWhenUsedFloat = ProtocolParser.readUInt64(stream);
			continue;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_BlockTypeSerializer.deserializeLengthDelimited = function(stream, instance) {
	instance.drawType = 0;
	instance.walkableType = 0;
	instance.pistolType = 0;
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.textureIdTop = ProtocolParser.readString(stream);
			continue;
		case 18:
			instance.textureIdBottom = ProtocolParser.readString(stream);
			continue;
		case 26:
			instance.textureIdFront = ProtocolParser.readString(stream);
			continue;
		case 34:
			instance.textureIdBack = ProtocolParser.readString(stream);
			continue;
		case 42:
			instance.textureIdLeft = ProtocolParser.readString(stream);
			continue;
		case 50:
			instance.textureIdRight = ProtocolParser.readString(stream);
			continue;
		case 58:
			instance.textureIdForInventory = ProtocolParser.readString(stream);
			continue;
		case 64:
			instance.drawType = ProtocolParser.readUInt64(stream);
			continue;
		case 72:
			instance.walkableType = ProtocolParser.readUInt64(stream);
			continue;
		case 80:
			instance.rail = ProtocolParser.readUInt64(stream);
			continue;
		case 88:
			instance.walkSpeedFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 96:
			instance.isSlipperyWalk = ProtocolParser.readBool(stream);
			continue;
		case 106:
			if (instance.sounds == null)
				instance.sounds = Packet_SoundSetSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_SoundSetSerializer.deserializeLengthDelimited(stream, instance.sounds);
			continue;
		case 112:
			instance.lightRadius = ProtocolParser.readUInt64(stream);
			continue;
		case 120:
			instance.startInventoryAmount = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		case 16:
			if (key.getWireType() != 0)
				break;
			instance.strength = ProtocolParser.readUInt64(stream);
			continue;
		case 17:
			if (key.getWireType() != 2)
				break;
			instance.name = ProtocolParser.readString(stream);
			continue;
		case 18:
			if (key.getWireType() != 0)
				break;
			instance.isBuildable = ProtocolParser.readBool(stream);
			continue;
		case 19:
			if (key.getWireType() != 0)
				break;
			instance.isUsable = ProtocolParser.readBool(stream);
			continue;
		case 20:
			if (key.getWireType() != 0)
				break;
			instance.isTool = ProtocolParser.readBool(stream);
			continue;
		case 21:
			if (key.getWireType() != 2)
				break;
			instance.handimage = ProtocolParser.readString(stream);
			continue;
		case 22:
			if (key.getWireType() != 0)
				break;
			instance.isPistol = ProtocolParser.readBool(stream);
			continue;
		case 23:
			if (key.getWireType() != 0)
				break;
			instance.aimRadiusFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			if (key.getWireType() != 0)
				break;
			instance.recoilFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 25:
			if (key.getWireType() != 0)
				break;
			instance.delayFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 26:
			if (key.getWireType() != 0)
				break;
			instance.bulletsPerShotFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 27:
			if (key.getWireType() != 0)
				break;
			instance.walkSpeedWhenUsedFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 28:
			if (key.getWireType() != 0)
				break;
			instance.ironSightsEnabled = ProtocolParser.readBool(stream);
			continue;
		case 29:
			if (key.getWireType() != 0)
				break;
			instance.ironSightsMoveSpeedFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 30:
			if (key.getWireType() != 2)
				break;
			instance.ironSightsImage = ProtocolParser.readString(stream);
			continue;
		case 31:
			if (key.getWireType() != 0)
				break;
			instance.ironSightsAimRadiusFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			if (key.getWireType() != 0)
				break;
			instance.ironSightsFovFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 33:
			if (key.getWireType() != 0)
				break;
			instance.ammoMagazine = ProtocolParser.readUInt64(stream);
			continue;
		case 34:
			if (key.getWireType() != 0)
				break;
			instance.ammoTotal = ProtocolParser.readUInt64(stream);
			continue;
		case 35:
			if (key.getWireType() != 0)
				break;
			instance.reloadDelayFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 36:
			if (key.getWireType() != 0)
				break;
			instance.explosionRangeFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 37:
			if (key.getWireType() != 0)
				break;
			instance.explosionTimeFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 38:
			if (key.getWireType() != 0)
				break;
			instance.projectileSpeedFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 39:
			if (key.getWireType() != 0)
				break;
			instance.projectileBounce = ProtocolParser.readBool(stream);
			continue;
		case 40:
			if (key.getWireType() != 0)
				break;
			instance.damageBodyFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 41:
			if (key.getWireType() != 0)
				break;
			instance.damageHeadFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 42:
			if (key.getWireType() != 0)
				break;
			instance.pistolType = ProtocolParser.readUInt64(stream);
			continue;
		case 43:
			if (key.getWireType() != 0)
				break;
			instance.damageToPlayer = ProtocolParser.readUInt64(stream);
			continue;
		case 44:
			if (key.getWireType() != 0)
				break;
			instance.whenPlacedGetsConvertedTo = ProtocolParser.readUInt64(stream);
			continue;
		case 45:
			if (key.getWireType() != 0)
				break;
			instance.pickDistanceWhenUsedFloat = ProtocolParser.readUInt64(stream);
			continue;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_BlockTypeSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_BlockType();
	Packet_BlockTypeSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_BlockTypeSerializer.serialize = function(stream, instance) {
	if (instance.textureIdTop != null) {
		stream.writeByte(ProtoPlatform.intToByte(10));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.textureIdTop));
	}
	if (instance.textureIdBottom != null) {
		stream.writeByte(ProtoPlatform.intToByte(18));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.textureIdBottom));
	}
	if (instance.textureIdFront != null) {
		stream.writeByte(ProtoPlatform.intToByte(26));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.textureIdFront));
	}
	if (instance.textureIdBack != null) {
		stream.writeByte(ProtoPlatform.intToByte(34));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.textureIdBack));
	}
	if (instance.textureIdLeft != null) {
		stream.writeByte(ProtoPlatform.intToByte(42));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.textureIdLeft));
	}
	if (instance.textureIdRight != null) {
		stream.writeByte(ProtoPlatform.intToByte(50));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.textureIdRight));
	}
	if (instance.textureIdForInventory != null) {
		stream.writeByte(ProtoPlatform.intToByte(58));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.textureIdForInventory));
	}
	if (instance.drawType != 0) {
		stream.writeByte(ProtoPlatform.intToByte(64));
		ProtocolParser.writeUInt64(stream, instance.drawType);
	}
	if (instance.walkableType != 0) {
		stream.writeByte(ProtoPlatform.intToByte(72));
		ProtocolParser.writeUInt64(stream, instance.walkableType);
	}
	stream.writeByte(ProtoPlatform.intToByte(80));
	ProtocolParser.writeUInt64(stream, instance.rail);
	stream.writeByte(ProtoPlatform.intToByte(88));
	ProtocolParser.writeUInt64(stream, instance.walkSpeedFloat);
	stream.writeByte(ProtoPlatform.intToByte(96));
	ProtocolParser.writeBool(stream, instance.isSlipperyWalk);
	if (instance.sounds != null) {
		stream.writeByte(ProtoPlatform.intToByte(106));
		var ms13 = new CitoMemoryStream();
		Packet_SoundSetSerializer.serialize(ms13, instance.sounds);
		var ms13Length = ms13.length();
		ProtocolParser.writeUInt32_(stream, ms13Length);
		stream.write(ms13.getBuffer(), 0, ms13Length);
	}
	stream.writeByte(ProtoPlatform.intToByte(112));
	ProtocolParser.writeUInt64(stream, instance.lightRadius);
	stream.writeByte(ProtoPlatform.intToByte(120));
	ProtocolParser.writeUInt64(stream, instance.startInventoryAmount);
	stream.writeByte(ProtoPlatform.intToByte(128));
	stream.writeByte(ProtoPlatform.intToByte(1));
	ProtocolParser.writeUInt64(stream, instance.strength);
	if (instance.name != null) {
		stream.writeByte(ProtoPlatform.intToByte(138));
		stream.writeByte(ProtoPlatform.intToByte(1));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.name));
	}
	stream.writeByte(ProtoPlatform.intToByte(144));
	stream.writeByte(ProtoPlatform.intToByte(1));
	ProtocolParser.writeBool(stream, instance.isBuildable);
	stream.writeByte(ProtoPlatform.intToByte(152));
	stream.writeByte(ProtoPlatform.intToByte(1));
	ProtocolParser.writeBool(stream, instance.isUsable);
	stream.writeByte(ProtoPlatform.intToByte(160));
	stream.writeByte(ProtoPlatform.intToByte(1));
	ProtocolParser.writeBool(stream, instance.isTool);
	if (instance.handimage != null) {
		stream.writeByte(ProtoPlatform.intToByte(170));
		stream.writeByte(ProtoPlatform.intToByte(1));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.handimage));
	}
	stream.writeByte(ProtoPlatform.intToByte(176));
	stream.writeByte(ProtoPlatform.intToByte(1));
	ProtocolParser.writeBool(stream, instance.isPistol);
	stream.writeByte(ProtoPlatform.intToByte(184));
	stream.writeByte(ProtoPlatform.intToByte(1));
	ProtocolParser.writeUInt64(stream, instance.aimRadiusFloat);
	stream.writeByte(ProtoPlatform.intToByte(192));
	stream.writeByte(ProtoPlatform.intToByte(1));
	ProtocolParser.writeUInt64(stream, instance.recoilFloat);
	stream.writeByte(ProtoPlatform.intToByte(200));
	stream.writeByte(ProtoPlatform.intToByte(1));
	ProtocolParser.writeUInt64(stream, instance.delayFloat);
	stream.writeByte(ProtoPlatform.intToByte(208));
	stream.writeByte(ProtoPlatform.intToByte(1));
	ProtocolParser.writeUInt64(stream, instance.bulletsPerShotFloat);
	stream.writeByte(ProtoPlatform.intToByte(216));
	stream.writeByte(ProtoPlatform.intToByte(1));
	ProtocolParser.writeUInt64(stream, instance.walkSpeedWhenUsedFloat);
	stream.writeByte(ProtoPlatform.intToByte(224));
	stream.writeByte(ProtoPlatform.intToByte(1));
	ProtocolParser.writeBool(stream, instance.ironSightsEnabled);
	stream.writeByte(ProtoPlatform.intToByte(232));
	stream.writeByte(ProtoPlatform.intToByte(1));
	ProtocolParser.writeUInt64(stream, instance.ironSightsMoveSpeedFloat);
	if (instance.ironSightsImage != null) {
		stream.writeByte(ProtoPlatform.intToByte(242));
		stream.writeByte(ProtoPlatform.intToByte(1));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.ironSightsImage));
	}
	stream.writeByte(ProtoPlatform.intToByte(248));
	stream.writeByte(ProtoPlatform.intToByte(1));
	ProtocolParser.writeUInt64(stream, instance.ironSightsAimRadiusFloat);
	stream.writeByte(ProtoPlatform.intToByte(128));
	stream.writeByte(ProtoPlatform.intToByte(2));
	ProtocolParser.writeUInt64(stream, instance.ironSightsFovFloat);
	stream.writeByte(ProtoPlatform.intToByte(136));
	stream.writeByte(ProtoPlatform.intToByte(2));
	ProtocolParser.writeUInt64(stream, instance.ammoMagazine);
	stream.writeByte(ProtoPlatform.intToByte(144));
	stream.writeByte(ProtoPlatform.intToByte(2));
	ProtocolParser.writeUInt64(stream, instance.ammoTotal);
	stream.writeByte(ProtoPlatform.intToByte(152));
	stream.writeByte(ProtoPlatform.intToByte(2));
	ProtocolParser.writeUInt64(stream, instance.reloadDelayFloat);
	stream.writeByte(ProtoPlatform.intToByte(160));
	stream.writeByte(ProtoPlatform.intToByte(2));
	ProtocolParser.writeUInt64(stream, instance.explosionRangeFloat);
	stream.writeByte(ProtoPlatform.intToByte(168));
	stream.writeByte(ProtoPlatform.intToByte(2));
	ProtocolParser.writeUInt64(stream, instance.explosionTimeFloat);
	stream.writeByte(ProtoPlatform.intToByte(176));
	stream.writeByte(ProtoPlatform.intToByte(2));
	ProtocolParser.writeUInt64(stream, instance.projectileSpeedFloat);
	stream.writeByte(ProtoPlatform.intToByte(184));
	stream.writeByte(ProtoPlatform.intToByte(2));
	ProtocolParser.writeBool(stream, instance.projectileBounce);
	stream.writeByte(ProtoPlatform.intToByte(192));
	stream.writeByte(ProtoPlatform.intToByte(2));
	ProtocolParser.writeUInt64(stream, instance.damageBodyFloat);
	stream.writeByte(ProtoPlatform.intToByte(200));
	stream.writeByte(ProtoPlatform.intToByte(2));
	ProtocolParser.writeUInt64(stream, instance.damageHeadFloat);
	if (instance.pistolType != 0) {
		stream.writeByte(ProtoPlatform.intToByte(208));
		stream.writeByte(ProtoPlatform.intToByte(2));
		ProtocolParser.writeUInt64(stream, instance.pistolType);
	}
	stream.writeByte(ProtoPlatform.intToByte(216));
	stream.writeByte(ProtoPlatform.intToByte(2));
	ProtocolParser.writeUInt64(stream, instance.damageToPlayer);
	stream.writeByte(ProtoPlatform.intToByte(224));
	stream.writeByte(ProtoPlatform.intToByte(2));
	ProtocolParser.writeUInt64(stream, instance.whenPlacedGetsConvertedTo);
	stream.writeByte(ProtoPlatform.intToByte(232));
	stream.writeByte(ProtoPlatform.intToByte(2));
	ProtocolParser.writeUInt64(stream, instance.pickDistanceWhenUsedFloat);
}

Packet_BlockTypeSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_BlockTypeSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_BlockTypeSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_BlockTypeSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_Client()
{
	this.activeMaterialSlot = null;
	this.craft = null;
	this.death = null;
	this.dialogClick_ = null;
	this.entityInteraction = null;
	this.fillArea = null;
	this.gameResolution = null;
	this.health = null;
	this.id = 0;
	this.identification = null;
	this.inventoryAction = null;
	this.leave = null;
	this.message = null;
	this.oxygen = null;
	this.pingReply = null;
	this.positionAndOrientation = null;
	this.query = null;
	this.reload = null;
	this.requestBlob = null;
	this.setBlock = null;
	this.shot = null;
	this.specialKey_ = null;
}

Packet_Client.prototype.getActiveMaterialSlot = function() {
	return this.activeMaterialSlot;
}

Packet_Client.prototype.getCraft = function() {
	return this.craft;
}

Packet_Client.prototype.getDeath = function() {
	return this.death;
}

Packet_Client.prototype.getDialogClick_ = function() {
	return this.dialogClick_;
}

Packet_Client.prototype.getEntityInteraction = function() {
	return this.entityInteraction;
}

Packet_Client.prototype.getFillArea = function() {
	return this.fillArea;
}

Packet_Client.prototype.getGameResolution = function() {
	return this.gameResolution;
}

Packet_Client.prototype.getHealth = function() {
	return this.health;
}

Packet_Client.prototype.getId = function() {
	return this.id;
}

Packet_Client.prototype.getIdentification = function() {
	return this.identification;
}

Packet_Client.prototype.getInventoryAction = function() {
	return this.inventoryAction;
}

Packet_Client.prototype.getLeave = function() {
	return this.leave;
}

Packet_Client.prototype.getMessage = function() {
	return this.message;
}

Packet_Client.prototype.getOxygen = function() {
	return this.oxygen;
}

Packet_Client.prototype.getPingReply = function() {
	return this.pingReply;
}

Packet_Client.prototype.getPositionAndOrientation = function() {
	return this.positionAndOrientation;
}

Packet_Client.prototype.getQuery = function() {
	return this.query;
}

Packet_Client.prototype.getReload = function() {
	return this.reload;
}

Packet_Client.prototype.getRequestBlob = function() {
	return this.requestBlob;
}

Packet_Client.prototype.getSetBlock = function() {
	return this.setBlock;
}

Packet_Client.prototype.getShot = function() {
	return this.shot;
}

Packet_Client.prototype.getSpecialKey_ = function() {
	return this.specialKey_;
}

Packet_Client.prototype.setActiveMaterialSlot = function(value) {
	this.activeMaterialSlot = value;
}

Packet_Client.prototype.setCraft = function(value) {
	this.craft = value;
}

Packet_Client.prototype.setDeath = function(value) {
	this.death = value;
}

Packet_Client.prototype.setDialogClick_ = function(value) {
	this.dialogClick_ = value;
}

Packet_Client.prototype.setEntityInteraction = function(value) {
	this.entityInteraction = value;
}

Packet_Client.prototype.setFillArea = function(value) {
	this.fillArea = value;
}

Packet_Client.prototype.setGameResolution = function(value) {
	this.gameResolution = value;
}

Packet_Client.prototype.setHealth = function(value) {
	this.health = value;
}

Packet_Client.prototype.setId = function(value) {
	this.id = value;
}

Packet_Client.prototype.setIdentification = function(value) {
	this.identification = value;
}

Packet_Client.prototype.setInventoryAction = function(value) {
	this.inventoryAction = value;
}

Packet_Client.prototype.setLeave = function(value) {
	this.leave = value;
}

Packet_Client.prototype.setMessage = function(value) {
	this.message = value;
}

Packet_Client.prototype.setOxygen = function(value) {
	this.oxygen = value;
}

Packet_Client.prototype.setPingReply = function(value) {
	this.pingReply = value;
}

Packet_Client.prototype.setPositionAndOrientation = function(value) {
	this.positionAndOrientation = value;
}

Packet_Client.prototype.setQuery = function(value) {
	this.query = value;
}

Packet_Client.prototype.setReload = function(value) {
	this.reload = value;
}

Packet_Client.prototype.setRequestBlob = function(value) {
	this.requestBlob = value;
}

Packet_Client.prototype.setSetBlock = function(value) {
	this.setBlock = value;
}

Packet_Client.prototype.setShot = function(value) {
	this.shot = value;
}

Packet_Client.prototype.setSpecialKey_ = function(value) {
	this.specialKey_ = value;
}

function Packet_ClientActiveMaterialSlot()
{
	this.activeMaterialSlot = 0;
}

Packet_ClientActiveMaterialSlot.prototype.getActiveMaterialSlot = function() {
	return this.activeMaterialSlot;
}

Packet_ClientActiveMaterialSlot.prototype.setActiveMaterialSlot = function(value) {
	this.activeMaterialSlot = value;
}

function Packet_ClientActiveMaterialSlotSerializer()
{
}

Packet_ClientActiveMaterialSlotSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.activeMaterialSlot = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientActiveMaterialSlotSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ClientActiveMaterialSlotSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ClientActiveMaterialSlotSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.activeMaterialSlot = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientActiveMaterialSlotSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.activeMaterialSlot = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientActiveMaterialSlotSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ClientActiveMaterialSlot();
	Packet_ClientActiveMaterialSlotSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ClientActiveMaterialSlotSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.activeMaterialSlot);
}

Packet_ClientActiveMaterialSlotSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ClientActiveMaterialSlotSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ClientActiveMaterialSlotSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ClientActiveMaterialSlotSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ClientCraft()
{
	this.recipeId = 0;
	this.x = 0;
	this.y = 0;
	this.z = 0;
}

Packet_ClientCraft.prototype.getRecipeId = function() {
	return this.recipeId;
}

Packet_ClientCraft.prototype.getX = function() {
	return this.x;
}

Packet_ClientCraft.prototype.getY = function() {
	return this.y;
}

Packet_ClientCraft.prototype.getZ = function() {
	return this.z;
}

Packet_ClientCraft.prototype.setRecipeId = function(value) {
	this.recipeId = value;
}

Packet_ClientCraft.prototype.setX = function(value) {
	this.x = value;
}

Packet_ClientCraft.prototype.setY = function(value) {
	this.y = value;
}

Packet_ClientCraft.prototype.setZ = function(value) {
	this.z = value;
}

function Packet_ClientCraftSerializer()
{
}

Packet_ClientCraftSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.recipeId = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientCraftSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ClientCraftSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ClientCraftSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.recipeId = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientCraftSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.recipeId = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientCraftSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ClientCraft();
	Packet_ClientCraftSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ClientCraftSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.x);
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.y);
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.z);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.recipeId);
}

Packet_ClientCraftSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ClientCraftSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ClientCraftSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ClientCraftSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ClientDeath()
{
	this.reason = 0;
	this.sourcePlayer = 0;
}

Packet_ClientDeath.prototype.getReason = function() {
	return this.reason;
}

Packet_ClientDeath.prototype.getSourcePlayer = function() {
	return this.sourcePlayer;
}

Packet_ClientDeath.prototype.setReason = function(value) {
	this.reason = value;
}

Packet_ClientDeath.prototype.setSourcePlayer = function(value) {
	this.sourcePlayer = value;
}

function Packet_ClientDeathSerializer()
{
}

Packet_ClientDeathSerializer.deserialize = function(stream, instance) {
	instance.reason = 0;
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.reason = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.sourcePlayer = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientDeathSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ClientDeathSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ClientDeathSerializer.deserializeLength = function(stream, length, instance) {
	instance.reason = 0;
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.reason = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.sourcePlayer = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientDeathSerializer.deserializeLengthDelimited = function(stream, instance) {
	instance.reason = 0;
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.reason = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.sourcePlayer = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientDeathSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ClientDeath();
	Packet_ClientDeathSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ClientDeathSerializer.serialize = function(stream, instance) {
	if (instance.reason != 0) {
		stream.writeByte(ProtoPlatform.intToByte(8));
		ProtocolParser.writeUInt64(stream, instance.reason);
	}
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.sourcePlayer);
}

Packet_ClientDeathSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ClientDeathSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ClientDeathSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ClientDeathSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ClientDialogClick()
{
	this.textBoxValue = null;
	this.textBoxValueCount = 0;
	this.textBoxValueLength = 0;
	this.widgetId = null;
}

Packet_ClientDialogClick.prototype.getTextBoxValue = function() {
	return this.textBoxValue;
}

Packet_ClientDialogClick.prototype.getTextBoxValueCount = function() {
	return this.textBoxValueCount;
}

Packet_ClientDialogClick.prototype.getTextBoxValueLength = function() {
	return this.textBoxValueLength;
}

Packet_ClientDialogClick.prototype.getWidgetId = function() {
	return this.widgetId;
}

Packet_ClientDialogClick.prototype.setTextBoxValue = function(value, count, length) {
	this.textBoxValue = value;
	this.textBoxValueCount = count;
	this.textBoxValueLength = length;
}

Packet_ClientDialogClick.prototype.setWidgetId = function(value) {
	this.widgetId = value;
}

Packet_ClientDialogClick.prototype.textBoxValueAdd = function(value) {
	if (this.textBoxValueCount >= this.textBoxValueLength) {
		var TextBoxValue2 = new Array(this.textBoxValueLength * 2);
		this.textBoxValueLength = this.textBoxValueLength * 2;
		for (var i = 0; i < this.textBoxValueCount; i++) {
			TextBoxValue2[i] = this.textBoxValue[i];
		}
		this.textBoxValue = TextBoxValue2;
	}
	this.textBoxValue[this.textBoxValueCount] = value;
	this.textBoxValueCount++;
}

function Packet_ClientDialogClickSerializer()
{
}

Packet_ClientDialogClickSerializer.deserialize = function(stream, instance) {
	if (instance.textBoxValue == null) {
		instance.textBoxValue = new Array(1);
		instance.textBoxValueCount = 0;
		instance.textBoxValueLength = 1;
	}
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.widgetId = ProtocolParser.readString(stream);
			continue;
		case 26:
			instance.textBoxValueAdd(ProtocolParser.readString(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientDialogClickSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ClientDialogClickSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ClientDialogClickSerializer.deserializeLength = function(stream, length, instance) {
	if (instance.textBoxValue == null) {
		instance.textBoxValue = new Array(1);
		instance.textBoxValueCount = 0;
		instance.textBoxValueLength = 1;
	}
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.widgetId = ProtocolParser.readString(stream);
			continue;
		case 26:
			instance.textBoxValueAdd(ProtocolParser.readString(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientDialogClickSerializer.deserializeLengthDelimited = function(stream, instance) {
	if (instance.textBoxValue == null) {
		instance.textBoxValue = new Array(1);
		instance.textBoxValueCount = 0;
		instance.textBoxValueLength = 1;
	}
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.widgetId = ProtocolParser.readString(stream);
			continue;
		case 26:
			instance.textBoxValueAdd(ProtocolParser.readString(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientDialogClickSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ClientDialogClick();
	Packet_ClientDialogClickSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ClientDialogClickSerializer.serialize = function(stream, instance) {
	if (instance.widgetId != null) {
		stream.writeByte(ProtoPlatform.intToByte(10));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.widgetId));
	}
	if (instance.textBoxValue != null) {
		for (var k = 0; k < instance.textBoxValueCount; k++) {
			var i3 = instance.textBoxValue[k];
			stream.writeByte(ProtoPlatform.intToByte(26));
			ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(i3));
		}
	}
}

Packet_ClientDialogClickSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ClientDialogClickSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ClientDialogClickSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ClientDialogClickSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ClientEntityInteraction()
{
	this.entityId = 0;
	this.interactionType = 0;
}

Packet_ClientEntityInteraction.prototype.getEntityId = function() {
	return this.entityId;
}

Packet_ClientEntityInteraction.prototype.getInteractionType = function() {
	return this.interactionType;
}

Packet_ClientEntityInteraction.prototype.setEntityId = function(value) {
	this.entityId = value;
}

Packet_ClientEntityInteraction.prototype.setInteractionType = function(value) {
	this.interactionType = value;
}

function Packet_ClientEntityInteractionSerializer()
{
}

Packet_ClientEntityInteractionSerializer.deserialize = function(stream, instance) {
	instance.interactionType = 0;
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.entityId = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.interactionType = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientEntityInteractionSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ClientEntityInteractionSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ClientEntityInteractionSerializer.deserializeLength = function(stream, length, instance) {
	instance.interactionType = 0;
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.entityId = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.interactionType = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientEntityInteractionSerializer.deserializeLengthDelimited = function(stream, instance) {
	instance.interactionType = 0;
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.entityId = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.interactionType = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientEntityInteractionSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ClientEntityInteraction();
	Packet_ClientEntityInteractionSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ClientEntityInteractionSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.entityId);
	if (instance.interactionType != 0) {
		stream.writeByte(ProtoPlatform.intToByte(16));
		ProtocolParser.writeUInt64(stream, instance.interactionType);
	}
}

Packet_ClientEntityInteractionSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ClientEntityInteractionSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ClientEntityInteractionSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ClientEntityInteractionSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ClientFillArea()
{
	this.blockType = 0;
	this.materialSlot = 0;
	this.x1 = 0;
	this.x2 = 0;
	this.y1 = 0;
	this.y2 = 0;
	this.z1 = 0;
	this.z2 = 0;
}

Packet_ClientFillArea.prototype.getBlockType = function() {
	return this.blockType;
}

Packet_ClientFillArea.prototype.getMaterialSlot = function() {
	return this.materialSlot;
}

Packet_ClientFillArea.prototype.getX1 = function() {
	return this.x1;
}

Packet_ClientFillArea.prototype.getX2 = function() {
	return this.x2;
}

Packet_ClientFillArea.prototype.getY1 = function() {
	return this.y1;
}

Packet_ClientFillArea.prototype.getY2 = function() {
	return this.y2;
}

Packet_ClientFillArea.prototype.getZ1 = function() {
	return this.z1;
}

Packet_ClientFillArea.prototype.getZ2 = function() {
	return this.z2;
}

Packet_ClientFillArea.prototype.setBlockType = function(value) {
	this.blockType = value;
}

Packet_ClientFillArea.prototype.setMaterialSlot = function(value) {
	this.materialSlot = value;
}

Packet_ClientFillArea.prototype.setX1 = function(value) {
	this.x1 = value;
}

Packet_ClientFillArea.prototype.setX2 = function(value) {
	this.x2 = value;
}

Packet_ClientFillArea.prototype.setY1 = function(value) {
	this.y1 = value;
}

Packet_ClientFillArea.prototype.setY2 = function(value) {
	this.y2 = value;
}

Packet_ClientFillArea.prototype.setZ1 = function(value) {
	this.z1 = value;
}

Packet_ClientFillArea.prototype.setZ2 = function(value) {
	this.z2 = value;
}

function Packet_ClientFillAreaSerializer()
{
}

Packet_ClientFillAreaSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.x1 = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.x2 = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.y1 = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.y2 = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.z1 = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.z2 = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.blockType = ProtocolParser.readUInt64(stream);
			continue;
		case 64:
			instance.materialSlot = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientFillAreaSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ClientFillAreaSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ClientFillAreaSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.x1 = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.x2 = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.y1 = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.y2 = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.z1 = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.z2 = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.blockType = ProtocolParser.readUInt64(stream);
			continue;
		case 64:
			instance.materialSlot = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientFillAreaSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.x1 = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.x2 = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.y1 = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.y2 = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.z1 = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.z2 = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.blockType = ProtocolParser.readUInt64(stream);
			continue;
		case 64:
			instance.materialSlot = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientFillAreaSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ClientFillArea();
	Packet_ClientFillAreaSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ClientFillAreaSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.x1);
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.x2);
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.y1);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.y2);
	stream.writeByte(ProtoPlatform.intToByte(40));
	ProtocolParser.writeUInt64(stream, instance.z1);
	stream.writeByte(ProtoPlatform.intToByte(48));
	ProtocolParser.writeUInt64(stream, instance.z2);
	stream.writeByte(ProtoPlatform.intToByte(56));
	ProtocolParser.writeUInt64(stream, instance.blockType);
	stream.writeByte(ProtoPlatform.intToByte(64));
	ProtocolParser.writeUInt64(stream, instance.materialSlot);
}

Packet_ClientFillAreaSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ClientFillAreaSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ClientFillAreaSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ClientFillAreaSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ClientGameResolution()
{
	this.height = 0;
	this.width = 0;
}

Packet_ClientGameResolution.prototype.getHeight = function() {
	return this.height;
}

Packet_ClientGameResolution.prototype.getWidth = function() {
	return this.width;
}

Packet_ClientGameResolution.prototype.setHeight = function(value) {
	this.height = value;
}

Packet_ClientGameResolution.prototype.setWidth = function(value) {
	this.width = value;
}

function Packet_ClientGameResolutionSerializer()
{
}

Packet_ClientGameResolutionSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.width = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.height = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientGameResolutionSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ClientGameResolutionSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ClientGameResolutionSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.width = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.height = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientGameResolutionSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.width = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.height = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientGameResolutionSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ClientGameResolution();
	Packet_ClientGameResolutionSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ClientGameResolutionSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.width);
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.height);
}

Packet_ClientGameResolutionSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ClientGameResolutionSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ClientGameResolutionSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ClientGameResolutionSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ClientHealth()
{
	this.currentHealth = 0;
}

Packet_ClientHealth.prototype.getCurrentHealth = function() {
	return this.currentHealth;
}

Packet_ClientHealth.prototype.setCurrentHealth = function(value) {
	this.currentHealth = value;
}

function Packet_ClientHealthSerializer()
{
}

Packet_ClientHealthSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.currentHealth = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientHealthSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ClientHealthSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ClientHealthSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.currentHealth = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientHealthSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.currentHealth = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientHealthSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ClientHealth();
	Packet_ClientHealthSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ClientHealthSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.currentHealth);
}

Packet_ClientHealthSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ClientHealthSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ClientHealthSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ClientHealthSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ClientIdEnum()
{
}
Packet_ClientIdEnum.ACTIVE_MATERIAL_SLOT = 56;
Packet_ClientIdEnum.CRAFT = 9;
Packet_ClientIdEnum.DEATH = 60;
Packet_ClientIdEnum.DIALOG_CLICK = 14;
Packet_ClientIdEnum.ENTITY_INTERACTION = 61;
Packet_ClientIdEnum.EXTENDED_PACKET_COMMAND = 100;
Packet_ClientIdEnum.FILL_AREA = 510;
Packet_ClientIdEnum.GAME_RESOLUTION = 10;
Packet_ClientIdEnum.HEALTH = 52;
Packet_ClientIdEnum.INVENTORY_ACTION = 51;
Packet_ClientIdEnum.LEAVE = 57;
Packet_ClientIdEnum.MESSAGE = 13;
Packet_ClientIdEnum.MONSTER_HIT = 53;
Packet_ClientIdEnum.OXYGEN = 59;
Packet_ClientIdEnum.PING_REPLY = 1;
Packet_ClientIdEnum.PLAYER_IDENTIFICATION = 0;
Packet_ClientIdEnum.POSITIONAND_ORIENTATION = 8;
Packet_ClientIdEnum.RELOAD = 58;
Packet_ClientIdEnum.REQUEST_BLOB = 50;
Packet_ClientIdEnum.SERVER_QUERY = 64;
Packet_ClientIdEnum.SET_BLOCK = 5;
Packet_ClientIdEnum.SHOT = 54;
Packet_ClientIdEnum.SPECIAL_KEY = 55;

function Packet_ClientIdentification()
{
	this.mdProtocolVersion = null;
	this.requestPosition = null;
	this.serverPassword = null;
	this.username = null;
	this.verificationKey = null;
}

Packet_ClientIdentification.prototype.getMdProtocolVersion = function() {
	return this.mdProtocolVersion;
}

Packet_ClientIdentification.prototype.getRequestPosition = function() {
	return this.requestPosition;
}

Packet_ClientIdentification.prototype.getServerPassword = function() {
	return this.serverPassword;
}

Packet_ClientIdentification.prototype.getUsername = function() {
	return this.username;
}

Packet_ClientIdentification.prototype.getVerificationKey = function() {
	return this.verificationKey;
}

Packet_ClientIdentification.prototype.setMdProtocolVersion = function(value) {
	this.mdProtocolVersion = value;
}

Packet_ClientIdentification.prototype.setRequestPosition = function(value) {
	this.requestPosition = value;
}

Packet_ClientIdentification.prototype.setServerPassword = function(value) {
	this.serverPassword = value;
}

Packet_ClientIdentification.prototype.setUsername = function(value) {
	this.username = value;
}

Packet_ClientIdentification.prototype.setVerificationKey = function(value) {
	this.verificationKey = value;
}

function Packet_ClientIdentificationSerializer()
{
}

Packet_ClientIdentificationSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.mdProtocolVersion = ProtocolParser.readString(stream);
			continue;
		case 18:
			instance.username = ProtocolParser.readString(stream);
			continue;
		case 26:
			instance.verificationKey = ProtocolParser.readString(stream);
			continue;
		case 34:
			instance.serverPassword = ProtocolParser.readString(stream);
			continue;
		case 42:
			if (instance.requestPosition == null)
				instance.requestPosition = Packet_PositionAndOrientationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer.deserializeLengthDelimited(stream, instance.requestPosition);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientIdentificationSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ClientIdentificationSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ClientIdentificationSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.mdProtocolVersion = ProtocolParser.readString(stream);
			continue;
		case 18:
			instance.username = ProtocolParser.readString(stream);
			continue;
		case 26:
			instance.verificationKey = ProtocolParser.readString(stream);
			continue;
		case 34:
			instance.serverPassword = ProtocolParser.readString(stream);
			continue;
		case 42:
			if (instance.requestPosition == null)
				instance.requestPosition = Packet_PositionAndOrientationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer.deserializeLengthDelimited(stream, instance.requestPosition);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientIdentificationSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.mdProtocolVersion = ProtocolParser.readString(stream);
			continue;
		case 18:
			instance.username = ProtocolParser.readString(stream);
			continue;
		case 26:
			instance.verificationKey = ProtocolParser.readString(stream);
			continue;
		case 34:
			instance.serverPassword = ProtocolParser.readString(stream);
			continue;
		case 42:
			if (instance.requestPosition == null)
				instance.requestPosition = Packet_PositionAndOrientationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer.deserializeLengthDelimited(stream, instance.requestPosition);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientIdentificationSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ClientIdentification();
	Packet_ClientIdentificationSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ClientIdentificationSerializer.serialize = function(stream, instance) {
	if (instance.mdProtocolVersion != null) {
		stream.writeByte(ProtoPlatform.intToByte(10));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.mdProtocolVersion));
	}
	if (instance.username != null) {
		stream.writeByte(ProtoPlatform.intToByte(18));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.username));
	}
	if (instance.verificationKey != null) {
		stream.writeByte(ProtoPlatform.intToByte(26));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.verificationKey));
	}
	if (instance.serverPassword != null) {
		stream.writeByte(ProtoPlatform.intToByte(34));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.serverPassword));
	}
	if (instance.requestPosition != null) {
		stream.writeByte(ProtoPlatform.intToByte(42));
		var ms5 = new CitoMemoryStream();
		Packet_PositionAndOrientationSerializer.serialize(ms5, instance.requestPosition);
		var ms5Length = ms5.length();
		ProtocolParser.writeUInt32_(stream, ms5Length);
		stream.write(ms5.getBuffer(), 0, ms5Length);
	}
}

Packet_ClientIdentificationSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ClientIdentificationSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ClientIdentificationSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ClientIdentificationSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ClientInventoryAction()
{
	this.a = null;
	this.action = 0;
	this.b = null;
}

Packet_ClientInventoryAction.prototype.getA = function() {
	return this.a;
}

Packet_ClientInventoryAction.prototype.getAction = function() {
	return this.action;
}

Packet_ClientInventoryAction.prototype.getB = function() {
	return this.b;
}

Packet_ClientInventoryAction.prototype.setA = function(value) {
	this.a = value;
}

Packet_ClientInventoryAction.prototype.setAction = function(value) {
	this.action = value;
}

Packet_ClientInventoryAction.prototype.setB = function(value) {
	this.b = value;
}

function Packet_ClientInventoryActionSerializer()
{
}

Packet_ClientInventoryActionSerializer.deserialize = function(stream, instance) {
	instance.action = 0;
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.action = ProtocolParser.readUInt64(stream);
			continue;
		case 18:
			if (instance.a == null)
				instance.a = Packet_InventoryPositionSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_InventoryPositionSerializer.deserializeLengthDelimited(stream, instance.a);
			continue;
		case 26:
			if (instance.b == null)
				instance.b = Packet_InventoryPositionSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_InventoryPositionSerializer.deserializeLengthDelimited(stream, instance.b);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientInventoryActionSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ClientInventoryActionSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ClientInventoryActionSerializer.deserializeLength = function(stream, length, instance) {
	instance.action = 0;
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.action = ProtocolParser.readUInt64(stream);
			continue;
		case 18:
			if (instance.a == null)
				instance.a = Packet_InventoryPositionSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_InventoryPositionSerializer.deserializeLengthDelimited(stream, instance.a);
			continue;
		case 26:
			if (instance.b == null)
				instance.b = Packet_InventoryPositionSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_InventoryPositionSerializer.deserializeLengthDelimited(stream, instance.b);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientInventoryActionSerializer.deserializeLengthDelimited = function(stream, instance) {
	instance.action = 0;
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.action = ProtocolParser.readUInt64(stream);
			continue;
		case 18:
			if (instance.a == null)
				instance.a = Packet_InventoryPositionSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_InventoryPositionSerializer.deserializeLengthDelimited(stream, instance.a);
			continue;
		case 26:
			if (instance.b == null)
				instance.b = Packet_InventoryPositionSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_InventoryPositionSerializer.deserializeLengthDelimited(stream, instance.b);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientInventoryActionSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ClientInventoryAction();
	Packet_ClientInventoryActionSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ClientInventoryActionSerializer.serialize = function(stream, instance) {
	if (instance.action != 0) {
		stream.writeByte(ProtoPlatform.intToByte(8));
		ProtocolParser.writeUInt64(stream, instance.action);
	}
	if (instance.a != null) {
		stream.writeByte(ProtoPlatform.intToByte(18));
		var ms2 = new CitoMemoryStream();
		Packet_InventoryPositionSerializer.serialize(ms2, instance.a);
		var ms2Length = ms2.length();
		ProtocolParser.writeUInt32_(stream, ms2Length);
		stream.write(ms2.getBuffer(), 0, ms2Length);
	}
	if (instance.b != null) {
		stream.writeByte(ProtoPlatform.intToByte(26));
		var ms3 = new CitoMemoryStream();
		Packet_InventoryPositionSerializer.serialize(ms3, instance.b);
		var ms3Length = ms3.length();
		ProtocolParser.writeUInt32_(stream, ms3Length);
		stream.write(ms3.getBuffer(), 0, ms3Length);
	}
}

Packet_ClientInventoryActionSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ClientInventoryActionSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ClientInventoryActionSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ClientInventoryActionSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ClientLeave()
{
	this.reason = 0;
}

Packet_ClientLeave.prototype.getReason = function() {
	return this.reason;
}

Packet_ClientLeave.prototype.setReason = function(value) {
	this.reason = value;
}

function Packet_ClientLeaveSerializer()
{
}

Packet_ClientLeaveSerializer.deserialize = function(stream, instance) {
	instance.reason = 0;
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.reason = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientLeaveSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ClientLeaveSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ClientLeaveSerializer.deserializeLength = function(stream, length, instance) {
	instance.reason = 0;
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.reason = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientLeaveSerializer.deserializeLengthDelimited = function(stream, instance) {
	instance.reason = 0;
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.reason = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientLeaveSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ClientLeave();
	Packet_ClientLeaveSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ClientLeaveSerializer.serialize = function(stream, instance) {
	if (instance.reason != 0) {
		stream.writeByte(ProtoPlatform.intToByte(8));
		ProtocolParser.writeUInt64(stream, instance.reason);
	}
}

Packet_ClientLeaveSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ClientLeaveSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ClientLeaveSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ClientLeaveSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ClientMessage()
{
	this.isTeamchat = 0;
	this.message = null;
}

Packet_ClientMessage.prototype.getIsTeamchat = function() {
	return this.isTeamchat;
}

Packet_ClientMessage.prototype.getMessage = function() {
	return this.message;
}

Packet_ClientMessage.prototype.setIsTeamchat = function(value) {
	this.isTeamchat = value;
}

Packet_ClientMessage.prototype.setMessage = function(value) {
	this.message = value;
}

function Packet_ClientMessageSerializer()
{
}

Packet_ClientMessageSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.message = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.isTeamchat = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientMessageSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ClientMessageSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ClientMessageSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.message = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.isTeamchat = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientMessageSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.message = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.isTeamchat = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientMessageSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ClientMessage();
	Packet_ClientMessageSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ClientMessageSerializer.serialize = function(stream, instance) {
	if (instance.message != null) {
		stream.writeByte(ProtoPlatform.intToByte(10));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.message));
	}
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.isTeamchat);
}

Packet_ClientMessageSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ClientMessageSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ClientMessageSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ClientMessageSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ClientOxygen()
{
	this.currentOxygen = 0;
}

Packet_ClientOxygen.prototype.getCurrentOxygen = function() {
	return this.currentOxygen;
}

Packet_ClientOxygen.prototype.setCurrentOxygen = function(value) {
	this.currentOxygen = value;
}

function Packet_ClientOxygenSerializer()
{
}

Packet_ClientOxygenSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.currentOxygen = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientOxygenSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ClientOxygenSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ClientOxygenSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.currentOxygen = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientOxygenSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.currentOxygen = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientOxygenSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ClientOxygen();
	Packet_ClientOxygenSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ClientOxygenSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.currentOxygen);
}

Packet_ClientOxygenSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ClientOxygenSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ClientOxygenSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ClientOxygenSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ClientPingReply()
{
}

function Packet_ClientPingReplySerializer()
{
}

Packet_ClientPingReplySerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientPingReplySerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ClientPingReplySerializer.deserialize(ms, instance);
	return instance;
}

Packet_ClientPingReplySerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientPingReplySerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientPingReplySerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ClientPingReply();
	Packet_ClientPingReplySerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ClientPingReplySerializer.serialize = function(stream, instance) {
}

Packet_ClientPingReplySerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ClientPingReplySerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ClientPingReplySerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ClientPingReplySerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ClientPositionAndOrientation()
{
	this.heading = 0;
	this.pitch = 0;
	this.playerId = 0;
	this.stance = 0;
	this.x = 0;
	this.y = 0;
	this.z = 0;
}

Packet_ClientPositionAndOrientation.prototype.getHeading = function() {
	return this.heading;
}

Packet_ClientPositionAndOrientation.prototype.getPitch = function() {
	return this.pitch;
}

Packet_ClientPositionAndOrientation.prototype.getPlayerId = function() {
	return this.playerId;
}

Packet_ClientPositionAndOrientation.prototype.getStance = function() {
	return this.stance;
}

Packet_ClientPositionAndOrientation.prototype.getX = function() {
	return this.x;
}

Packet_ClientPositionAndOrientation.prototype.getY = function() {
	return this.y;
}

Packet_ClientPositionAndOrientation.prototype.getZ = function() {
	return this.z;
}

Packet_ClientPositionAndOrientation.prototype.setHeading = function(value) {
	this.heading = value;
}

Packet_ClientPositionAndOrientation.prototype.setPitch = function(value) {
	this.pitch = value;
}

Packet_ClientPositionAndOrientation.prototype.setPlayerId = function(value) {
	this.playerId = value;
}

Packet_ClientPositionAndOrientation.prototype.setStance = function(value) {
	this.stance = value;
}

Packet_ClientPositionAndOrientation.prototype.setX = function(value) {
	this.x = value;
}

Packet_ClientPositionAndOrientation.prototype.setY = function(value) {
	this.y = value;
}

Packet_ClientPositionAndOrientation.prototype.setZ = function(value) {
	this.z = value;
}

function Packet_ClientPositionAndOrientationSerializer()
{
}

Packet_ClientPositionAndOrientationSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.playerId = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.heading = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.pitch = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.stance = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientPositionAndOrientationSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ClientPositionAndOrientationSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ClientPositionAndOrientationSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.playerId = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.heading = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.pitch = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.stance = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientPositionAndOrientationSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.playerId = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.heading = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.pitch = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.stance = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientPositionAndOrientationSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ClientPositionAndOrientation();
	Packet_ClientPositionAndOrientationSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ClientPositionAndOrientationSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.playerId);
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.x);
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.y);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.z);
	stream.writeByte(ProtoPlatform.intToByte(40));
	ProtocolParser.writeUInt64(stream, instance.heading);
	stream.writeByte(ProtoPlatform.intToByte(48));
	ProtocolParser.writeUInt64(stream, instance.pitch);
	stream.writeByte(ProtoPlatform.intToByte(56));
	ProtocolParser.writeUInt64(stream, instance.stance);
}

Packet_ClientPositionAndOrientationSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ClientPositionAndOrientationSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ClientPositionAndOrientationSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ClientPositionAndOrientationSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ClientReload()
{
}

function Packet_ClientReloadSerializer()
{
}

Packet_ClientReloadSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientReloadSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ClientReloadSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ClientReloadSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientReloadSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientReloadSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ClientReload();
	Packet_ClientReloadSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ClientReloadSerializer.serialize = function(stream, instance) {
}

Packet_ClientReloadSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ClientReloadSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ClientReloadSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ClientReloadSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ClientRequestBlob()
{
	this.requestedMd5 = null;
}

Packet_ClientRequestBlob.prototype.getRequestedMd5 = function() {
	return this.requestedMd5;
}

Packet_ClientRequestBlob.prototype.setRequestedMd5 = function(value) {
	this.requestedMd5 = value;
}

function Packet_ClientRequestBlobSerializer()
{
}

Packet_ClientRequestBlobSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			if (instance.requestedMd5 == null)
				instance.requestedMd5 = Packet_StringListSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_StringListSerializer.deserializeLengthDelimited(stream, instance.requestedMd5);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientRequestBlobSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ClientRequestBlobSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ClientRequestBlobSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			if (instance.requestedMd5 == null)
				instance.requestedMd5 = Packet_StringListSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_StringListSerializer.deserializeLengthDelimited(stream, instance.requestedMd5);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientRequestBlobSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			if (instance.requestedMd5 == null)
				instance.requestedMd5 = Packet_StringListSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_StringListSerializer.deserializeLengthDelimited(stream, instance.requestedMd5);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientRequestBlobSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ClientRequestBlob();
	Packet_ClientRequestBlobSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ClientRequestBlobSerializer.serialize = function(stream, instance) {
	if (instance.requestedMd5 != null) {
		stream.writeByte(ProtoPlatform.intToByte(10));
		var ms1 = new CitoMemoryStream();
		Packet_StringListSerializer.serialize(ms1, instance.requestedMd5);
		var ms1Length = ms1.length();
		ProtocolParser.writeUInt32_(stream, ms1Length);
		stream.write(ms1.getBuffer(), 0, ms1Length);
	}
}

Packet_ClientRequestBlobSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ClientRequestBlobSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ClientRequestBlobSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ClientRequestBlobSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ClientSerializer()
{
}

Packet_ClientSerializer.deserialize = function(stream, instance) {
	instance.id = 0;
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.id = ProtocolParser.readUInt64(stream);
			continue;
		case 18:
			if (instance.identification == null)
				instance.identification = Packet_ClientIdentificationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientIdentificationSerializer.deserializeLengthDelimited(stream, instance.identification);
			continue;
		case 26:
			if (instance.setBlock == null)
				instance.setBlock = Packet_ClientSetBlockSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientSetBlockSerializer.deserializeLengthDelimited(stream, instance.setBlock);
			continue;
		case 34:
			if (instance.positionAndOrientation == null)
				instance.positionAndOrientation = Packet_ClientPositionAndOrientationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientPositionAndOrientationSerializer.deserializeLengthDelimited(stream, instance.positionAndOrientation);
			continue;
		case 42:
			if (instance.message == null)
				instance.message = Packet_ClientMessageSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientMessageSerializer.deserializeLengthDelimited(stream, instance.message);
			continue;
		case 50:
			if (instance.craft == null)
				instance.craft = Packet_ClientCraftSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientCraftSerializer.deserializeLengthDelimited(stream, instance.craft);
			continue;
		case 58:
			if (instance.requestBlob == null)
				instance.requestBlob = Packet_ClientRequestBlobSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientRequestBlobSerializer.deserializeLengthDelimited(stream, instance.requestBlob);
			continue;
		case 66:
			if (instance.inventoryAction == null)
				instance.inventoryAction = Packet_ClientInventoryActionSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientInventoryActionSerializer.deserializeLengthDelimited(stream, instance.inventoryAction);
			continue;
		case 74:
			if (instance.health == null)
				instance.health = Packet_ClientHealthSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientHealthSerializer.deserializeLengthDelimited(stream, instance.health);
			continue;
		case 82:
			if (instance.pingReply == null)
				instance.pingReply = Packet_ClientPingReplySerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientPingReplySerializer.deserializeLengthDelimited(stream, instance.pingReply);
			continue;
		case 90:
			if (instance.dialogClick_ == null)
				instance.dialogClick_ = Packet_ClientDialogClickSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientDialogClickSerializer.deserializeLengthDelimited(stream, instance.dialogClick_);
			continue;
		case 98:
			if (instance.shot == null)
				instance.shot = Packet_ClientShotSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientShotSerializer.deserializeLengthDelimited(stream, instance.shot);
			continue;
		case 106:
			if (instance.specialKey_ == null)
				instance.specialKey_ = Packet_ClientSpecialKeySerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientSpecialKeySerializer.deserializeLengthDelimited(stream, instance.specialKey_);
			continue;
		case 114:
			if (instance.activeMaterialSlot == null)
				instance.activeMaterialSlot = Packet_ClientActiveMaterialSlotSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientActiveMaterialSlotSerializer.deserializeLengthDelimited(stream, instance.activeMaterialSlot);
			continue;
		case 122:
			if (instance.leave == null)
				instance.leave = Packet_ClientLeaveSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientLeaveSerializer.deserializeLengthDelimited(stream, instance.leave);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		case 31:
			if (key.getWireType() != 2)
				break;
			if (instance.fillArea == null)
				instance.fillArea = Packet_ClientFillAreaSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientFillAreaSerializer.deserializeLengthDelimited(stream, instance.fillArea);
			continue;
		case 16:
			if (key.getWireType() != 2)
				break;
			if (instance.reload == null)
				instance.reload = Packet_ClientReloadSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientReloadSerializer.deserializeLengthDelimited(stream, instance.reload);
			continue;
		case 17:
			if (key.getWireType() != 2)
				break;
			if (instance.oxygen == null)
				instance.oxygen = Packet_ClientOxygenSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientOxygenSerializer.deserializeLengthDelimited(stream, instance.oxygen);
			continue;
		case 18:
			if (key.getWireType() != 2)
				break;
			if (instance.death == null)
				instance.death = Packet_ClientDeathSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientDeathSerializer.deserializeLengthDelimited(stream, instance.death);
			continue;
		case 19:
			if (key.getWireType() != 2)
				break;
			if (instance.query == null)
				instance.query = Packet_ClientServerQuerySerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientServerQuerySerializer.deserializeLengthDelimited(stream, instance.query);
			continue;
		case 20:
			if (key.getWireType() != 2)
				break;
			if (instance.gameResolution == null)
				instance.gameResolution = Packet_ClientGameResolutionSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientGameResolutionSerializer.deserializeLengthDelimited(stream, instance.gameResolution);
			continue;
		case 21:
			if (key.getWireType() != 2)
				break;
			if (instance.entityInteraction == null)
				instance.entityInteraction = Packet_ClientEntityInteractionSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientEntityInteractionSerializer.deserializeLengthDelimited(stream, instance.entityInteraction);
			continue;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ClientSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ClientSerializer.deserializeLength = function(stream, length, instance) {
	instance.id = 0;
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.id = ProtocolParser.readUInt64(stream);
			continue;
		case 18:
			if (instance.identification == null)
				instance.identification = Packet_ClientIdentificationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientIdentificationSerializer.deserializeLengthDelimited(stream, instance.identification);
			continue;
		case 26:
			if (instance.setBlock == null)
				instance.setBlock = Packet_ClientSetBlockSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientSetBlockSerializer.deserializeLengthDelimited(stream, instance.setBlock);
			continue;
		case 34:
			if (instance.positionAndOrientation == null)
				instance.positionAndOrientation = Packet_ClientPositionAndOrientationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientPositionAndOrientationSerializer.deserializeLengthDelimited(stream, instance.positionAndOrientation);
			continue;
		case 42:
			if (instance.message == null)
				instance.message = Packet_ClientMessageSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientMessageSerializer.deserializeLengthDelimited(stream, instance.message);
			continue;
		case 50:
			if (instance.craft == null)
				instance.craft = Packet_ClientCraftSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientCraftSerializer.deserializeLengthDelimited(stream, instance.craft);
			continue;
		case 58:
			if (instance.requestBlob == null)
				instance.requestBlob = Packet_ClientRequestBlobSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientRequestBlobSerializer.deserializeLengthDelimited(stream, instance.requestBlob);
			continue;
		case 66:
			if (instance.inventoryAction == null)
				instance.inventoryAction = Packet_ClientInventoryActionSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientInventoryActionSerializer.deserializeLengthDelimited(stream, instance.inventoryAction);
			continue;
		case 74:
			if (instance.health == null)
				instance.health = Packet_ClientHealthSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientHealthSerializer.deserializeLengthDelimited(stream, instance.health);
			continue;
		case 82:
			if (instance.pingReply == null)
				instance.pingReply = Packet_ClientPingReplySerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientPingReplySerializer.deserializeLengthDelimited(stream, instance.pingReply);
			continue;
		case 90:
			if (instance.dialogClick_ == null)
				instance.dialogClick_ = Packet_ClientDialogClickSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientDialogClickSerializer.deserializeLengthDelimited(stream, instance.dialogClick_);
			continue;
		case 98:
			if (instance.shot == null)
				instance.shot = Packet_ClientShotSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientShotSerializer.deserializeLengthDelimited(stream, instance.shot);
			continue;
		case 106:
			if (instance.specialKey_ == null)
				instance.specialKey_ = Packet_ClientSpecialKeySerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientSpecialKeySerializer.deserializeLengthDelimited(stream, instance.specialKey_);
			continue;
		case 114:
			if (instance.activeMaterialSlot == null)
				instance.activeMaterialSlot = Packet_ClientActiveMaterialSlotSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientActiveMaterialSlotSerializer.deserializeLengthDelimited(stream, instance.activeMaterialSlot);
			continue;
		case 122:
			if (instance.leave == null)
				instance.leave = Packet_ClientLeaveSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientLeaveSerializer.deserializeLengthDelimited(stream, instance.leave);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		case 31:
			if (key.getWireType() != 2)
				break;
			if (instance.fillArea == null)
				instance.fillArea = Packet_ClientFillAreaSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientFillAreaSerializer.deserializeLengthDelimited(stream, instance.fillArea);
			continue;
		case 16:
			if (key.getWireType() != 2)
				break;
			if (instance.reload == null)
				instance.reload = Packet_ClientReloadSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientReloadSerializer.deserializeLengthDelimited(stream, instance.reload);
			continue;
		case 17:
			if (key.getWireType() != 2)
				break;
			if (instance.oxygen == null)
				instance.oxygen = Packet_ClientOxygenSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientOxygenSerializer.deserializeLengthDelimited(stream, instance.oxygen);
			continue;
		case 18:
			if (key.getWireType() != 2)
				break;
			if (instance.death == null)
				instance.death = Packet_ClientDeathSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientDeathSerializer.deserializeLengthDelimited(stream, instance.death);
			continue;
		case 19:
			if (key.getWireType() != 2)
				break;
			if (instance.query == null)
				instance.query = Packet_ClientServerQuerySerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientServerQuerySerializer.deserializeLengthDelimited(stream, instance.query);
			continue;
		case 20:
			if (key.getWireType() != 2)
				break;
			if (instance.gameResolution == null)
				instance.gameResolution = Packet_ClientGameResolutionSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientGameResolutionSerializer.deserializeLengthDelimited(stream, instance.gameResolution);
			continue;
		case 21:
			if (key.getWireType() != 2)
				break;
			if (instance.entityInteraction == null)
				instance.entityInteraction = Packet_ClientEntityInteractionSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientEntityInteractionSerializer.deserializeLengthDelimited(stream, instance.entityInteraction);
			continue;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientSerializer.deserializeLengthDelimited = function(stream, instance) {
	instance.id = 0;
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.id = ProtocolParser.readUInt64(stream);
			continue;
		case 18:
			if (instance.identification == null)
				instance.identification = Packet_ClientIdentificationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientIdentificationSerializer.deserializeLengthDelimited(stream, instance.identification);
			continue;
		case 26:
			if (instance.setBlock == null)
				instance.setBlock = Packet_ClientSetBlockSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientSetBlockSerializer.deserializeLengthDelimited(stream, instance.setBlock);
			continue;
		case 34:
			if (instance.positionAndOrientation == null)
				instance.positionAndOrientation = Packet_ClientPositionAndOrientationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientPositionAndOrientationSerializer.deserializeLengthDelimited(stream, instance.positionAndOrientation);
			continue;
		case 42:
			if (instance.message == null)
				instance.message = Packet_ClientMessageSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientMessageSerializer.deserializeLengthDelimited(stream, instance.message);
			continue;
		case 50:
			if (instance.craft == null)
				instance.craft = Packet_ClientCraftSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientCraftSerializer.deserializeLengthDelimited(stream, instance.craft);
			continue;
		case 58:
			if (instance.requestBlob == null)
				instance.requestBlob = Packet_ClientRequestBlobSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientRequestBlobSerializer.deserializeLengthDelimited(stream, instance.requestBlob);
			continue;
		case 66:
			if (instance.inventoryAction == null)
				instance.inventoryAction = Packet_ClientInventoryActionSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientInventoryActionSerializer.deserializeLengthDelimited(stream, instance.inventoryAction);
			continue;
		case 74:
			if (instance.health == null)
				instance.health = Packet_ClientHealthSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientHealthSerializer.deserializeLengthDelimited(stream, instance.health);
			continue;
		case 82:
			if (instance.pingReply == null)
				instance.pingReply = Packet_ClientPingReplySerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientPingReplySerializer.deserializeLengthDelimited(stream, instance.pingReply);
			continue;
		case 90:
			if (instance.dialogClick_ == null)
				instance.dialogClick_ = Packet_ClientDialogClickSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientDialogClickSerializer.deserializeLengthDelimited(stream, instance.dialogClick_);
			continue;
		case 98:
			if (instance.shot == null)
				instance.shot = Packet_ClientShotSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientShotSerializer.deserializeLengthDelimited(stream, instance.shot);
			continue;
		case 106:
			if (instance.specialKey_ == null)
				instance.specialKey_ = Packet_ClientSpecialKeySerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientSpecialKeySerializer.deserializeLengthDelimited(stream, instance.specialKey_);
			continue;
		case 114:
			if (instance.activeMaterialSlot == null)
				instance.activeMaterialSlot = Packet_ClientActiveMaterialSlotSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientActiveMaterialSlotSerializer.deserializeLengthDelimited(stream, instance.activeMaterialSlot);
			continue;
		case 122:
			if (instance.leave == null)
				instance.leave = Packet_ClientLeaveSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientLeaveSerializer.deserializeLengthDelimited(stream, instance.leave);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		case 31:
			if (key.getWireType() != 2)
				break;
			if (instance.fillArea == null)
				instance.fillArea = Packet_ClientFillAreaSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientFillAreaSerializer.deserializeLengthDelimited(stream, instance.fillArea);
			continue;
		case 16:
			if (key.getWireType() != 2)
				break;
			if (instance.reload == null)
				instance.reload = Packet_ClientReloadSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientReloadSerializer.deserializeLengthDelimited(stream, instance.reload);
			continue;
		case 17:
			if (key.getWireType() != 2)
				break;
			if (instance.oxygen == null)
				instance.oxygen = Packet_ClientOxygenSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientOxygenSerializer.deserializeLengthDelimited(stream, instance.oxygen);
			continue;
		case 18:
			if (key.getWireType() != 2)
				break;
			if (instance.death == null)
				instance.death = Packet_ClientDeathSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientDeathSerializer.deserializeLengthDelimited(stream, instance.death);
			continue;
		case 19:
			if (key.getWireType() != 2)
				break;
			if (instance.query == null)
				instance.query = Packet_ClientServerQuerySerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientServerQuerySerializer.deserializeLengthDelimited(stream, instance.query);
			continue;
		case 20:
			if (key.getWireType() != 2)
				break;
			if (instance.gameResolution == null)
				instance.gameResolution = Packet_ClientGameResolutionSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientGameResolutionSerializer.deserializeLengthDelimited(stream, instance.gameResolution);
			continue;
		case 21:
			if (key.getWireType() != 2)
				break;
			if (instance.entityInteraction == null)
				instance.entityInteraction = Packet_ClientEntityInteractionSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ClientEntityInteractionSerializer.deserializeLengthDelimited(stream, instance.entityInteraction);
			continue;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_Client();
	Packet_ClientSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ClientSerializer.serialize = function(stream, instance) {
	if (instance.id != 0) {
		stream.writeByte(ProtoPlatform.intToByte(8));
		ProtocolParser.writeUInt64(stream, instance.id);
	}
	if (instance.identification != null) {
		stream.writeByte(ProtoPlatform.intToByte(18));
		var ms2 = new CitoMemoryStream();
		Packet_ClientIdentificationSerializer.serialize(ms2, instance.identification);
		var ms2Length = ms2.length();
		ProtocolParser.writeUInt32_(stream, ms2Length);
		stream.write(ms2.getBuffer(), 0, ms2Length);
	}
	if (instance.setBlock != null) {
		stream.writeByte(ProtoPlatform.intToByte(26));
		var ms3 = new CitoMemoryStream();
		Packet_ClientSetBlockSerializer.serialize(ms3, instance.setBlock);
		var ms3Length = ms3.length();
		ProtocolParser.writeUInt32_(stream, ms3Length);
		stream.write(ms3.getBuffer(), 0, ms3Length);
	}
	if (instance.fillArea != null) {
		stream.writeByte(ProtoPlatform.intToByte(250));
		stream.writeByte(ProtoPlatform.intToByte(1));
		var ms31 = new CitoMemoryStream();
		Packet_ClientFillAreaSerializer.serialize(ms31, instance.fillArea);
		var ms31Length = ms31.length();
		ProtocolParser.writeUInt32_(stream, ms31Length);
		stream.write(ms31.getBuffer(), 0, ms31Length);
	}
	if (instance.positionAndOrientation != null) {
		stream.writeByte(ProtoPlatform.intToByte(34));
		var ms4 = new CitoMemoryStream();
		Packet_ClientPositionAndOrientationSerializer.serialize(ms4, instance.positionAndOrientation);
		var ms4Length = ms4.length();
		ProtocolParser.writeUInt32_(stream, ms4Length);
		stream.write(ms4.getBuffer(), 0, ms4Length);
	}
	if (instance.message != null) {
		stream.writeByte(ProtoPlatform.intToByte(42));
		var ms5 = new CitoMemoryStream();
		Packet_ClientMessageSerializer.serialize(ms5, instance.message);
		var ms5Length = ms5.length();
		ProtocolParser.writeUInt32_(stream, ms5Length);
		stream.write(ms5.getBuffer(), 0, ms5Length);
	}
	if (instance.craft != null) {
		stream.writeByte(ProtoPlatform.intToByte(50));
		var ms6 = new CitoMemoryStream();
		Packet_ClientCraftSerializer.serialize(ms6, instance.craft);
		var ms6Length = ms6.length();
		ProtocolParser.writeUInt32_(stream, ms6Length);
		stream.write(ms6.getBuffer(), 0, ms6Length);
	}
	if (instance.requestBlob != null) {
		stream.writeByte(ProtoPlatform.intToByte(58));
		var ms7 = new CitoMemoryStream();
		Packet_ClientRequestBlobSerializer.serialize(ms7, instance.requestBlob);
		var ms7Length = ms7.length();
		ProtocolParser.writeUInt32_(stream, ms7Length);
		stream.write(ms7.getBuffer(), 0, ms7Length);
	}
	if (instance.inventoryAction != null) {
		stream.writeByte(ProtoPlatform.intToByte(66));
		var ms8 = new CitoMemoryStream();
		Packet_ClientInventoryActionSerializer.serialize(ms8, instance.inventoryAction);
		var ms8Length = ms8.length();
		ProtocolParser.writeUInt32_(stream, ms8Length);
		stream.write(ms8.getBuffer(), 0, ms8Length);
	}
	if (instance.health != null) {
		stream.writeByte(ProtoPlatform.intToByte(74));
		var ms9 = new CitoMemoryStream();
		Packet_ClientHealthSerializer.serialize(ms9, instance.health);
		var ms9Length = ms9.length();
		ProtocolParser.writeUInt32_(stream, ms9Length);
		stream.write(ms9.getBuffer(), 0, ms9Length);
	}
	if (instance.pingReply != null) {
		stream.writeByte(ProtoPlatform.intToByte(82));
		var ms10 = new CitoMemoryStream();
		Packet_ClientPingReplySerializer.serialize(ms10, instance.pingReply);
		var ms10Length = ms10.length();
		ProtocolParser.writeUInt32_(stream, ms10Length);
		stream.write(ms10.getBuffer(), 0, ms10Length);
	}
	if (instance.dialogClick_ != null) {
		stream.writeByte(ProtoPlatform.intToByte(90));
		var ms11 = new CitoMemoryStream();
		Packet_ClientDialogClickSerializer.serialize(ms11, instance.dialogClick_);
		var ms11Length = ms11.length();
		ProtocolParser.writeUInt32_(stream, ms11Length);
		stream.write(ms11.getBuffer(), 0, ms11Length);
	}
	if (instance.shot != null) {
		stream.writeByte(ProtoPlatform.intToByte(98));
		var ms12 = new CitoMemoryStream();
		Packet_ClientShotSerializer.serialize(ms12, instance.shot);
		var ms12Length = ms12.length();
		ProtocolParser.writeUInt32_(stream, ms12Length);
		stream.write(ms12.getBuffer(), 0, ms12Length);
	}
	if (instance.specialKey_ != null) {
		stream.writeByte(ProtoPlatform.intToByte(106));
		var ms13 = new CitoMemoryStream();
		Packet_ClientSpecialKeySerializer.serialize(ms13, instance.specialKey_);
		var ms13Length = ms13.length();
		ProtocolParser.writeUInt32_(stream, ms13Length);
		stream.write(ms13.getBuffer(), 0, ms13Length);
	}
	if (instance.activeMaterialSlot != null) {
		stream.writeByte(ProtoPlatform.intToByte(114));
		var ms14 = new CitoMemoryStream();
		Packet_ClientActiveMaterialSlotSerializer.serialize(ms14, instance.activeMaterialSlot);
		var ms14Length = ms14.length();
		ProtocolParser.writeUInt32_(stream, ms14Length);
		stream.write(ms14.getBuffer(), 0, ms14Length);
	}
	if (instance.leave != null) {
		stream.writeByte(ProtoPlatform.intToByte(122));
		var ms15 = new CitoMemoryStream();
		Packet_ClientLeaveSerializer.serialize(ms15, instance.leave);
		var ms15Length = ms15.length();
		ProtocolParser.writeUInt32_(stream, ms15Length);
		stream.write(ms15.getBuffer(), 0, ms15Length);
	}
	if (instance.reload != null) {
		stream.writeByte(ProtoPlatform.intToByte(130));
		stream.writeByte(ProtoPlatform.intToByte(1));
		var ms16 = new CitoMemoryStream();
		Packet_ClientReloadSerializer.serialize(ms16, instance.reload);
		var ms16Length = ms16.length();
		ProtocolParser.writeUInt32_(stream, ms16Length);
		stream.write(ms16.getBuffer(), 0, ms16Length);
	}
	if (instance.oxygen != null) {
		stream.writeByte(ProtoPlatform.intToByte(138));
		stream.writeByte(ProtoPlatform.intToByte(1));
		var ms17 = new CitoMemoryStream();
		Packet_ClientOxygenSerializer.serialize(ms17, instance.oxygen);
		var ms17Length = ms17.length();
		ProtocolParser.writeUInt32_(stream, ms17Length);
		stream.write(ms17.getBuffer(), 0, ms17Length);
	}
	if (instance.death != null) {
		stream.writeByte(ProtoPlatform.intToByte(146));
		stream.writeByte(ProtoPlatform.intToByte(1));
		var ms18 = new CitoMemoryStream();
		Packet_ClientDeathSerializer.serialize(ms18, instance.death);
		var ms18Length = ms18.length();
		ProtocolParser.writeUInt32_(stream, ms18Length);
		stream.write(ms18.getBuffer(), 0, ms18Length);
	}
	if (instance.query != null) {
		stream.writeByte(ProtoPlatform.intToByte(154));
		stream.writeByte(ProtoPlatform.intToByte(1));
		var ms19 = new CitoMemoryStream();
		Packet_ClientServerQuerySerializer.serialize(ms19, instance.query);
		var ms19Length = ms19.length();
		ProtocolParser.writeUInt32_(stream, ms19Length);
		stream.write(ms19.getBuffer(), 0, ms19Length);
	}
	if (instance.gameResolution != null) {
		stream.writeByte(ProtoPlatform.intToByte(162));
		stream.writeByte(ProtoPlatform.intToByte(1));
		var ms20 = new CitoMemoryStream();
		Packet_ClientGameResolutionSerializer.serialize(ms20, instance.gameResolution);
		var ms20Length = ms20.length();
		ProtocolParser.writeUInt32_(stream, ms20Length);
		stream.write(ms20.getBuffer(), 0, ms20Length);
	}
	if (instance.entityInteraction != null) {
		stream.writeByte(ProtoPlatform.intToByte(170));
		stream.writeByte(ProtoPlatform.intToByte(1));
		var ms21 = new CitoMemoryStream();
		Packet_ClientEntityInteractionSerializer.serialize(ms21, instance.entityInteraction);
		var ms21Length = ms21.length();
		ProtocolParser.writeUInt32_(stream, ms21Length);
		stream.write(ms21.getBuffer(), 0, ms21Length);
	}
}

Packet_ClientSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ClientSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ClientSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ClientSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ClientServerQuery()
{
}

function Packet_ClientServerQuerySerializer()
{
}

Packet_ClientServerQuerySerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientServerQuerySerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ClientServerQuerySerializer.deserialize(ms, instance);
	return instance;
}

Packet_ClientServerQuerySerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientServerQuerySerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientServerQuerySerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ClientServerQuery();
	Packet_ClientServerQuerySerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ClientServerQuerySerializer.serialize = function(stream, instance) {
}

Packet_ClientServerQuerySerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ClientServerQuerySerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ClientServerQuerySerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ClientServerQuerySerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ClientSetBlock()
{
	this.blockType = 0;
	this.materialSlot = 0;
	this.mode = 0;
	this.x = 0;
	this.y = 0;
	this.z = 0;
}

Packet_ClientSetBlock.prototype.getBlockType = function() {
	return this.blockType;
}

Packet_ClientSetBlock.prototype.getMaterialSlot = function() {
	return this.materialSlot;
}

Packet_ClientSetBlock.prototype.getMode = function() {
	return this.mode;
}

Packet_ClientSetBlock.prototype.getX = function() {
	return this.x;
}

Packet_ClientSetBlock.prototype.getY = function() {
	return this.y;
}

Packet_ClientSetBlock.prototype.getZ = function() {
	return this.z;
}

Packet_ClientSetBlock.prototype.setBlockType = function(value) {
	this.blockType = value;
}

Packet_ClientSetBlock.prototype.setMaterialSlot = function(value) {
	this.materialSlot = value;
}

Packet_ClientSetBlock.prototype.setMode = function(value) {
	this.mode = value;
}

Packet_ClientSetBlock.prototype.setX = function(value) {
	this.x = value;
}

Packet_ClientSetBlock.prototype.setY = function(value) {
	this.y = value;
}

Packet_ClientSetBlock.prototype.setZ = function(value) {
	this.z = value;
}

function Packet_ClientSetBlockSerializer()
{
}

Packet_ClientSetBlockSerializer.deserialize = function(stream, instance) {
	instance.mode = 0;
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.mode = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.blockType = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.materialSlot = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientSetBlockSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ClientSetBlockSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ClientSetBlockSerializer.deserializeLength = function(stream, length, instance) {
	instance.mode = 0;
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.mode = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.blockType = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.materialSlot = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientSetBlockSerializer.deserializeLengthDelimited = function(stream, instance) {
	instance.mode = 0;
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.mode = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.blockType = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.materialSlot = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientSetBlockSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ClientSetBlock();
	Packet_ClientSetBlockSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ClientSetBlockSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.x);
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.y);
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.z);
	if (instance.mode != 0) {
		stream.writeByte(ProtoPlatform.intToByte(32));
		ProtocolParser.writeUInt64(stream, instance.mode);
	}
	stream.writeByte(ProtoPlatform.intToByte(40));
	ProtocolParser.writeUInt64(stream, instance.blockType);
	stream.writeByte(ProtoPlatform.intToByte(48));
	ProtocolParser.writeUInt64(stream, instance.materialSlot);
}

Packet_ClientSetBlockSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ClientSetBlockSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ClientSetBlockSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ClientSetBlockSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ClientShot()
{
	this.explodesAfter = 0;
	this.fromX = 0;
	this.fromY = 0;
	this.fromZ = 0;
	this.hitPlayer = 0;
	this.isHitHead = 0;
	this.toX = 0;
	this.toY = 0;
	this.toZ = 0;
	this.weaponBlock = 0;
}

Packet_ClientShot.prototype.getExplodesAfter = function() {
	return this.explodesAfter;
}

Packet_ClientShot.prototype.getFromX = function() {
	return this.fromX;
}

Packet_ClientShot.prototype.getFromY = function() {
	return this.fromY;
}

Packet_ClientShot.prototype.getFromZ = function() {
	return this.fromZ;
}

Packet_ClientShot.prototype.getHitPlayer = function() {
	return this.hitPlayer;
}

Packet_ClientShot.prototype.getIsHitHead = function() {
	return this.isHitHead;
}

Packet_ClientShot.prototype.getToX = function() {
	return this.toX;
}

Packet_ClientShot.prototype.getToY = function() {
	return this.toY;
}

Packet_ClientShot.prototype.getToZ = function() {
	return this.toZ;
}

Packet_ClientShot.prototype.getWeaponBlock = function() {
	return this.weaponBlock;
}

Packet_ClientShot.prototype.setExplodesAfter = function(value) {
	this.explodesAfter = value;
}

Packet_ClientShot.prototype.setFromX = function(value) {
	this.fromX = value;
}

Packet_ClientShot.prototype.setFromY = function(value) {
	this.fromY = value;
}

Packet_ClientShot.prototype.setFromZ = function(value) {
	this.fromZ = value;
}

Packet_ClientShot.prototype.setHitPlayer = function(value) {
	this.hitPlayer = value;
}

Packet_ClientShot.prototype.setIsHitHead = function(value) {
	this.isHitHead = value;
}

Packet_ClientShot.prototype.setToX = function(value) {
	this.toX = value;
}

Packet_ClientShot.prototype.setToY = function(value) {
	this.toY = value;
}

Packet_ClientShot.prototype.setToZ = function(value) {
	this.toZ = value;
}

Packet_ClientShot.prototype.setWeaponBlock = function(value) {
	this.weaponBlock = value;
}

function Packet_ClientShotSerializer()
{
}

Packet_ClientShotSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.fromX = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.fromY = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.fromZ = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.toX = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.toY = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.toZ = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.weaponBlock = ProtocolParser.readUInt64(stream);
			continue;
		case 64:
			instance.hitPlayer = ProtocolParser.readUInt64(stream);
			continue;
		case 72:
			instance.isHitHead = ProtocolParser.readUInt64(stream);
			continue;
		case 80:
			instance.explodesAfter = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientShotSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ClientShotSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ClientShotSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.fromX = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.fromY = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.fromZ = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.toX = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.toY = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.toZ = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.weaponBlock = ProtocolParser.readUInt64(stream);
			continue;
		case 64:
			instance.hitPlayer = ProtocolParser.readUInt64(stream);
			continue;
		case 72:
			instance.isHitHead = ProtocolParser.readUInt64(stream);
			continue;
		case 80:
			instance.explodesAfter = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientShotSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.fromX = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.fromY = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.fromZ = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.toX = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.toY = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.toZ = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.weaponBlock = ProtocolParser.readUInt64(stream);
			continue;
		case 64:
			instance.hitPlayer = ProtocolParser.readUInt64(stream);
			continue;
		case 72:
			instance.isHitHead = ProtocolParser.readUInt64(stream);
			continue;
		case 80:
			instance.explodesAfter = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientShotSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ClientShot();
	Packet_ClientShotSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ClientShotSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.fromX);
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.fromY);
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.fromZ);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.toX);
	stream.writeByte(ProtoPlatform.intToByte(40));
	ProtocolParser.writeUInt64(stream, instance.toY);
	stream.writeByte(ProtoPlatform.intToByte(48));
	ProtocolParser.writeUInt64(stream, instance.toZ);
	stream.writeByte(ProtoPlatform.intToByte(56));
	ProtocolParser.writeUInt64(stream, instance.weaponBlock);
	stream.writeByte(ProtoPlatform.intToByte(64));
	ProtocolParser.writeUInt64(stream, instance.hitPlayer);
	stream.writeByte(ProtoPlatform.intToByte(72));
	ProtocolParser.writeUInt64(stream, instance.isHitHead);
	stream.writeByte(ProtoPlatform.intToByte(80));
	ProtocolParser.writeUInt64(stream, instance.explodesAfter);
}

Packet_ClientShotSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ClientShotSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ClientShotSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ClientShotSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ClientSpecialKey()
{
	this.key_ = 0;
}

Packet_ClientSpecialKey.prototype.getKey_ = function() {
	return this.key_;
}

Packet_ClientSpecialKey.prototype.setKey_ = function(value) {
	this.key_ = value;
}

function Packet_ClientSpecialKeySerializer()
{
}

Packet_ClientSpecialKeySerializer.deserialize = function(stream, instance) {
	instance.key_ = 0;
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.key_ = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientSpecialKeySerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ClientSpecialKeySerializer.deserialize(ms, instance);
	return instance;
}

Packet_ClientSpecialKeySerializer.deserializeLength = function(stream, length, instance) {
	instance.key_ = 0;
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.key_ = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientSpecialKeySerializer.deserializeLengthDelimited = function(stream, instance) {
	instance.key_ = 0;
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.key_ = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientSpecialKeySerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ClientSpecialKey();
	Packet_ClientSpecialKeySerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ClientSpecialKeySerializer.serialize = function(stream, instance) {
	if (instance.key_ != 0) {
		stream.writeByte(ProtoPlatform.intToByte(8));
		ProtocolParser.writeUInt64(stream, instance.key_);
	}
}

Packet_ClientSpecialKeySerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ClientSpecialKeySerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ClientSpecialKeySerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ClientSpecialKeySerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_CraftingRecipe()
{
	this.ingredients = null;
	this.ingredientsCount = 0;
	this.ingredientsLength = 0;
	this.output = null;
}

Packet_CraftingRecipe.prototype.getIngredients = function() {
	return this.ingredients;
}

Packet_CraftingRecipe.prototype.getIngredientsCount = function() {
	return this.ingredientsCount;
}

Packet_CraftingRecipe.prototype.getIngredientsLength = function() {
	return this.ingredientsLength;
}

Packet_CraftingRecipe.prototype.getOutput = function() {
	return this.output;
}

Packet_CraftingRecipe.prototype.ingredientsAdd = function(value) {
	if (this.ingredientsCount >= this.ingredientsLength) {
		var Ingredients2 = new Array(this.ingredientsLength * 2);
		this.ingredientsLength = this.ingredientsLength * 2;
		for (var i = 0; i < this.ingredientsCount; i++) {
			Ingredients2[i] = this.ingredients[i];
		}
		this.ingredients = Ingredients2;
	}
	this.ingredients[this.ingredientsCount] = value;
	this.ingredientsCount++;
}

Packet_CraftingRecipe.prototype.setIngredients = function(value, count, length) {
	this.ingredients = value;
	this.ingredientsCount = count;
	this.ingredientsLength = length;
}

Packet_CraftingRecipe.prototype.setOutput = function(value) {
	this.output = value;
}

function Packet_CraftingRecipeSerializer()
{
}

Packet_CraftingRecipeSerializer.deserialize = function(stream, instance) {
	if (instance.ingredients == null) {
		instance.ingredients = new Array(1);
		instance.ingredientsCount = 0;
		instance.ingredientsLength = 1;
	}
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.ingredientsAdd(Packet_IngredientSerializer.deserializeLengthDelimitedNew(stream));
			continue;
		case 18:
			if (instance.output == null)
				instance.output = Packet_IngredientSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_IngredientSerializer.deserializeLengthDelimited(stream, instance.output);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_CraftingRecipeSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_CraftingRecipeSerializer.deserialize(ms, instance);
	return instance;
}

Packet_CraftingRecipeSerializer.deserializeLength = function(stream, length, instance) {
	if (instance.ingredients == null) {
		instance.ingredients = new Array(1);
		instance.ingredientsCount = 0;
		instance.ingredientsLength = 1;
	}
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.ingredientsAdd(Packet_IngredientSerializer.deserializeLengthDelimitedNew(stream));
			continue;
		case 18:
			if (instance.output == null)
				instance.output = Packet_IngredientSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_IngredientSerializer.deserializeLengthDelimited(stream, instance.output);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_CraftingRecipeSerializer.deserializeLengthDelimited = function(stream, instance) {
	if (instance.ingredients == null) {
		instance.ingredients = new Array(1);
		instance.ingredientsCount = 0;
		instance.ingredientsLength = 1;
	}
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.ingredientsAdd(Packet_IngredientSerializer.deserializeLengthDelimitedNew(stream));
			continue;
		case 18:
			if (instance.output == null)
				instance.output = Packet_IngredientSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_IngredientSerializer.deserializeLengthDelimited(stream, instance.output);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_CraftingRecipeSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_CraftingRecipe();
	Packet_CraftingRecipeSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_CraftingRecipeSerializer.serialize = function(stream, instance) {
	if (instance.ingredients != null) {
		for (var k = 0; k < instance.ingredientsCount; k++) {
			var i1 = instance.ingredients[k];
			stream.writeByte(ProtoPlatform.intToByte(10));
			var ms1 = new CitoMemoryStream();
			Packet_IngredientSerializer.serialize(ms1, i1);
			var ms1Length = ms1.length();
			ProtocolParser.writeUInt32_(stream, ms1Length);
			stream.write(ms1.getBuffer(), 0, ms1Length);
		}
	}
	if (instance.output != null) {
		stream.writeByte(ProtoPlatform.intToByte(18));
		var ms2 = new CitoMemoryStream();
		Packet_IngredientSerializer.serialize(ms2, instance.output);
		var ms2Length = ms2.length();
		ProtocolParser.writeUInt32_(stream, ms2Length);
		stream.write(ms2.getBuffer(), 0, ms2Length);
	}
}

Packet_CraftingRecipeSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_CraftingRecipeSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_CraftingRecipeSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_CraftingRecipeSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_DeathReasonEnum()
{
}
Packet_DeathReasonEnum.BLOCK_DAMAGE = 1;
Packet_DeathReasonEnum.DROWNING = 2;
Packet_DeathReasonEnum.EXPLOSION = 3;
Packet_DeathReasonEnum.FALL_DAMAGE = 0;

function Packet_Dialog()
{
	this.height_ = 0;
	this.isModal = 0;
	this.widgets = null;
	this.widgetsCount = 0;
	this.widgetsLength = 0;
	this.width = 0;
}

Packet_Dialog.prototype.getHeight_ = function() {
	return this.height_;
}

Packet_Dialog.prototype.getIsModal = function() {
	return this.isModal;
}

Packet_Dialog.prototype.getWidgets = function() {
	return this.widgets;
}

Packet_Dialog.prototype.getWidgetsCount = function() {
	return this.widgetsCount;
}

Packet_Dialog.prototype.getWidgetsLength = function() {
	return this.widgetsLength;
}

Packet_Dialog.prototype.getWidth = function() {
	return this.width;
}

Packet_Dialog.prototype.setHeight_ = function(value) {
	this.height_ = value;
}

Packet_Dialog.prototype.setIsModal = function(value) {
	this.isModal = value;
}

Packet_Dialog.prototype.setWidgets = function(value, count, length) {
	this.widgets = value;
	this.widgetsCount = count;
	this.widgetsLength = length;
}

Packet_Dialog.prototype.setWidth = function(value) {
	this.width = value;
}

Packet_Dialog.prototype.widgetsAdd = function(value) {
	if (this.widgetsCount >= this.widgetsLength) {
		var Widgets2 = new Array(this.widgetsLength * 2);
		this.widgetsLength = this.widgetsLength * 2;
		for (var i = 0; i < this.widgetsCount; i++) {
			Widgets2[i] = this.widgets[i];
		}
		this.widgets = Widgets2;
	}
	this.widgets[this.widgetsCount] = value;
	this.widgetsCount++;
}

function Packet_DialogFont()
{
	this.familyName = null;
	this.fontStyle = 0;
	this.sizeFloat = 0;
}

Packet_DialogFont.prototype.getFamilyName = function() {
	return this.familyName;
}

Packet_DialogFont.prototype.getFontStyle = function() {
	return this.fontStyle;
}

Packet_DialogFont.prototype.getSizeFloat = function() {
	return this.sizeFloat;
}

Packet_DialogFont.prototype.setFamilyName = function(value) {
	this.familyName = value;
}

Packet_DialogFont.prototype.setFontStyle = function(value) {
	this.fontStyle = value;
}

Packet_DialogFont.prototype.setSizeFloat = function(value) {
	this.sizeFloat = value;
}

function Packet_DialogFontSerializer()
{
}

Packet_DialogFontSerializer.deserialize = function(stream, instance) {
	instance.fontStyle = 0;
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.familyName = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.sizeFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.fontStyle = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_DialogFontSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_DialogFontSerializer.deserialize(ms, instance);
	return instance;
}

Packet_DialogFontSerializer.deserializeLength = function(stream, length, instance) {
	instance.fontStyle = 0;
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.familyName = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.sizeFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.fontStyle = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_DialogFontSerializer.deserializeLengthDelimited = function(stream, instance) {
	instance.fontStyle = 0;
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.familyName = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.sizeFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.fontStyle = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_DialogFontSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_DialogFont();
	Packet_DialogFontSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_DialogFontSerializer.serialize = function(stream, instance) {
	if (instance.familyName != null) {
		stream.writeByte(ProtoPlatform.intToByte(10));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.familyName));
	}
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.sizeFloat);
	if (instance.fontStyle != 0) {
		stream.writeByte(ProtoPlatform.intToByte(24));
		ProtocolParser.writeUInt64(stream, instance.fontStyle);
	}
}

Packet_DialogFontSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_DialogFontSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_DialogFontSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_DialogFontSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_DialogFontStyleEnum()
{
}
Packet_DialogFontStyleEnum.BOLD = 1;
Packet_DialogFontStyleEnum.ITALIC = 2;
Packet_DialogFontStyleEnum.REGULAR = 0;
Packet_DialogFontStyleEnum.STRIKEOUT = 8;
Packet_DialogFontStyleEnum.UNDERLINE = 4;

function Packet_DialogSerializer()
{
}

Packet_DialogSerializer.deserialize = function(stream, instance) {
	if (instance.widgets == null) {
		instance.widgets = new Array(1);
		instance.widgetsCount = 0;
		instance.widgetsLength = 1;
	}
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.widgetsAdd(Packet_WidgetSerializer.deserializeLengthDelimitedNew(stream));
			continue;
		case 16:
			instance.width = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.height_ = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.isModal = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_DialogSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_DialogSerializer.deserialize(ms, instance);
	return instance;
}

Packet_DialogSerializer.deserializeLength = function(stream, length, instance) {
	if (instance.widgets == null) {
		instance.widgets = new Array(1);
		instance.widgetsCount = 0;
		instance.widgetsLength = 1;
	}
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.widgetsAdd(Packet_WidgetSerializer.deserializeLengthDelimitedNew(stream));
			continue;
		case 16:
			instance.width = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.height_ = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.isModal = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_DialogSerializer.deserializeLengthDelimited = function(stream, instance) {
	if (instance.widgets == null) {
		instance.widgets = new Array(1);
		instance.widgetsCount = 0;
		instance.widgetsLength = 1;
	}
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.widgetsAdd(Packet_WidgetSerializer.deserializeLengthDelimitedNew(stream));
			continue;
		case 16:
			instance.width = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.height_ = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.isModal = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_DialogSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_Dialog();
	Packet_DialogSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_DialogSerializer.serialize = function(stream, instance) {
	if (instance.widgets != null) {
		for (var k = 0; k < instance.widgetsCount; k++) {
			var i1 = instance.widgets[k];
			stream.writeByte(ProtoPlatform.intToByte(10));
			var ms1 = new CitoMemoryStream();
			Packet_WidgetSerializer.serialize(ms1, i1);
			var ms1Length = ms1.length();
			ProtocolParser.writeUInt32_(stream, ms1Length);
			stream.write(ms1.getBuffer(), 0, ms1Length);
		}
	}
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.width);
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.height_);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.isModal);
}

Packet_DialogSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_DialogSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_DialogSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_DialogSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_DrawTypeEnum()
{
}
Packet_DrawTypeEnum.CACTUS = 13;
Packet_DrawTypeEnum.CLOSED_DOOR = 8;
Packet_DrawTypeEnum.EMPTY = 0;
Packet_DrawTypeEnum.FENCE = 10;
Packet_DrawTypeEnum.FLAT = 12;
Packet_DrawTypeEnum.FLUID = 3;
Packet_DrawTypeEnum.HALF_HEIGHT = 11;
Packet_DrawTypeEnum.LADDER = 9;
Packet_DrawTypeEnum.OPEN_DOOR_LEFT = 6;
Packet_DrawTypeEnum.OPEN_DOOR_RIGHT = 7;
Packet_DrawTypeEnum.PLANT = 5;
Packet_DrawTypeEnum.SOLID = 1;
Packet_DrawTypeEnum.TORCH = 4;
Packet_DrawTypeEnum.TRANSPARENT = 2;

function Packet_EntityInteractionTypeEnum()
{
}
Packet_EntityInteractionTypeEnum.HIT = 1;
Packet_EntityInteractionTypeEnum.USE = 0;

function Packet_Ingredient()
{
	this.amount = 0;
	this.type = 0;
}

Packet_Ingredient.prototype.getAmount = function() {
	return this.amount;
}

Packet_Ingredient.prototype.getType = function() {
	return this.type;
}

Packet_Ingredient.prototype.setAmount = function(value) {
	this.amount = value;
}

Packet_Ingredient.prototype.setType = function(value) {
	this.type = value;
}

function Packet_IngredientSerializer()
{
}

Packet_IngredientSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.type = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.amount = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_IngredientSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_IngredientSerializer.deserialize(ms, instance);
	return instance;
}

Packet_IngredientSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.type = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.amount = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_IngredientSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.type = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.amount = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_IngredientSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_Ingredient();
	Packet_IngredientSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_IngredientSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.type);
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.amount);
}

Packet_IngredientSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_IngredientSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_IngredientSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_IngredientSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_IntInt()
{
	this.key_ = 0;
	this.value_ = 0;
}

Packet_IntInt.prototype.getKey_ = function() {
	return this.key_;
}

Packet_IntInt.prototype.getValue_ = function() {
	return this.value_;
}

Packet_IntInt.prototype.setKey_ = function(value) {
	this.key_ = value;
}

Packet_IntInt.prototype.setValue_ = function(value) {
	this.value_ = value;
}

function Packet_IntIntSerializer()
{
}

Packet_IntIntSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.key_ = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.value_ = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_IntIntSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_IntIntSerializer.deserialize(ms, instance);
	return instance;
}

Packet_IntIntSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.key_ = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.value_ = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_IntIntSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.key_ = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.value_ = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_IntIntSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_IntInt();
	Packet_IntIntSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_IntIntSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.key_);
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.value_);
}

Packet_IntIntSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_IntIntSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_IntIntSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_IntIntSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_IntString()
{
	this.key_ = 0;
	this.value_ = null;
}

Packet_IntString.prototype.getKey_ = function() {
	return this.key_;
}

Packet_IntString.prototype.getValue_ = function() {
	return this.value_;
}

Packet_IntString.prototype.setKey_ = function(value) {
	this.key_ = value;
}

Packet_IntString.prototype.setValue_ = function(value) {
	this.value_ = value;
}

function Packet_IntStringSerializer()
{
}

Packet_IntStringSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.key_ = ProtocolParser.readUInt64(stream);
			continue;
		case 18:
			instance.value_ = ProtocolParser.readString(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_IntStringSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_IntStringSerializer.deserialize(ms, instance);
	return instance;
}

Packet_IntStringSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.key_ = ProtocolParser.readUInt64(stream);
			continue;
		case 18:
			instance.value_ = ProtocolParser.readString(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_IntStringSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.key_ = ProtocolParser.readUInt64(stream);
			continue;
		case 18:
			instance.value_ = ProtocolParser.readString(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_IntStringSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_IntString();
	Packet_IntStringSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_IntStringSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.key_);
	if (instance.value_ != null) {
		stream.writeByte(ProtoPlatform.intToByte(18));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.value_));
	}
}

Packet_IntStringSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_IntStringSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_IntStringSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_IntStringSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_Inventory()
{
	this.boots = null;
	this.dragDropItem = null;
	this.gauntlet = null;
	this.helmet = null;
	this.items = null;
	this.itemsCount = 0;
	this.itemsLength = 0;
	this.mainArmor = null;
	this.rightHand = null;
	this.rightHandCount = 0;
	this.rightHandLength = 0;
}

Packet_Inventory.prototype.getBoots = function() {
	return this.boots;
}

Packet_Inventory.prototype.getDragDropItem = function() {
	return this.dragDropItem;
}

Packet_Inventory.prototype.getGauntlet = function() {
	return this.gauntlet;
}

Packet_Inventory.prototype.getHelmet = function() {
	return this.helmet;
}

Packet_Inventory.prototype.getItems = function() {
	return this.items;
}

Packet_Inventory.prototype.getItemsCount = function() {
	return this.itemsCount;
}

Packet_Inventory.prototype.getItemsLength = function() {
	return this.itemsLength;
}

Packet_Inventory.prototype.getMainArmor = function() {
	return this.mainArmor;
}

Packet_Inventory.prototype.getRightHand = function() {
	return this.rightHand;
}

Packet_Inventory.prototype.getRightHandCount = function() {
	return this.rightHandCount;
}

Packet_Inventory.prototype.getRightHandLength = function() {
	return this.rightHandLength;
}

Packet_Inventory.prototype.itemsAdd = function(value) {
	if (this.itemsCount >= this.itemsLength) {
		var Items2 = new Array(this.itemsLength * 2);
		this.itemsLength = this.itemsLength * 2;
		for (var i = 0; i < this.itemsCount; i++) {
			Items2[i] = this.items[i];
		}
		this.items = Items2;
	}
	this.items[this.itemsCount] = value;
	this.itemsCount++;
}

Packet_Inventory.prototype.rightHandAdd = function(value) {
	if (this.rightHandCount >= this.rightHandLength) {
		var RightHand2 = new Array(this.rightHandLength * 2);
		this.rightHandLength = this.rightHandLength * 2;
		for (var i = 0; i < this.rightHandCount; i++) {
			RightHand2[i] = this.rightHand[i];
		}
		this.rightHand = RightHand2;
	}
	this.rightHand[this.rightHandCount] = value;
	this.rightHandCount++;
}

Packet_Inventory.prototype.setBoots = function(value) {
	this.boots = value;
}

Packet_Inventory.prototype.setDragDropItem = function(value) {
	this.dragDropItem = value;
}

Packet_Inventory.prototype.setGauntlet = function(value) {
	this.gauntlet = value;
}

Packet_Inventory.prototype.setHelmet = function(value) {
	this.helmet = value;
}

Packet_Inventory.prototype.setItems = function(value, count, length) {
	this.items = value;
	this.itemsCount = count;
	this.itemsLength = length;
}

Packet_Inventory.prototype.setMainArmor = function(value) {
	this.mainArmor = value;
}

Packet_Inventory.prototype.setRightHand = function(value, count, length) {
	this.rightHand = value;
	this.rightHandCount = count;
	this.rightHandLength = length;
}

function Packet_InventoryActionTypeEnum()
{
}
Packet_InventoryActionTypeEnum.CLICK = 0;
Packet_InventoryActionTypeEnum.MOVE_TO_INVENTORY = 2;
Packet_InventoryActionTypeEnum.WEAR_ITEM = 1;

function Packet_InventoryPosition()
{
	this.activeMaterial = 0;
	this.areaX = 0;
	this.areaY = 0;
	this.groundPositionX = 0;
	this.groundPositionY = 0;
	this.groundPositionZ = 0;
	this.materialId = 0;
	this.type = 0;
	this.wearPlace = 0;
}

Packet_InventoryPosition.prototype.getActiveMaterial = function() {
	return this.activeMaterial;
}

Packet_InventoryPosition.prototype.getAreaX = function() {
	return this.areaX;
}

Packet_InventoryPosition.prototype.getAreaY = function() {
	return this.areaY;
}

Packet_InventoryPosition.prototype.getGroundPositionX = function() {
	return this.groundPositionX;
}

Packet_InventoryPosition.prototype.getGroundPositionY = function() {
	return this.groundPositionY;
}

Packet_InventoryPosition.prototype.getGroundPositionZ = function() {
	return this.groundPositionZ;
}

Packet_InventoryPosition.prototype.getMaterialId = function() {
	return this.materialId;
}

Packet_InventoryPosition.prototype.getType = function() {
	return this.type;
}

Packet_InventoryPosition.prototype.getWearPlace = function() {
	return this.wearPlace;
}

Packet_InventoryPosition.prototype.setActiveMaterial = function(value) {
	this.activeMaterial = value;
}

Packet_InventoryPosition.prototype.setAreaX = function(value) {
	this.areaX = value;
}

Packet_InventoryPosition.prototype.setAreaY = function(value) {
	this.areaY = value;
}

Packet_InventoryPosition.prototype.setGroundPositionX = function(value) {
	this.groundPositionX = value;
}

Packet_InventoryPosition.prototype.setGroundPositionY = function(value) {
	this.groundPositionY = value;
}

Packet_InventoryPosition.prototype.setGroundPositionZ = function(value) {
	this.groundPositionZ = value;
}

Packet_InventoryPosition.prototype.setMaterialId = function(value) {
	this.materialId = value;
}

Packet_InventoryPosition.prototype.setType = function(value) {
	this.type = value;
}

Packet_InventoryPosition.prototype.setWearPlace = function(value) {
	this.wearPlace = value;
}

function Packet_InventoryPositionSerializer()
{
}

Packet_InventoryPositionSerializer.deserialize = function(stream, instance) {
	instance.type = 0;
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.type = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.areaX = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.areaY = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.materialId = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.wearPlace = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.activeMaterial = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.groundPositionX = ProtocolParser.readUInt64(stream);
			continue;
		case 64:
			instance.groundPositionY = ProtocolParser.readUInt64(stream);
			continue;
		case 72:
			instance.groundPositionZ = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_InventoryPositionSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_InventoryPositionSerializer.deserialize(ms, instance);
	return instance;
}

Packet_InventoryPositionSerializer.deserializeLength = function(stream, length, instance) {
	instance.type = 0;
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.type = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.areaX = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.areaY = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.materialId = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.wearPlace = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.activeMaterial = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.groundPositionX = ProtocolParser.readUInt64(stream);
			continue;
		case 64:
			instance.groundPositionY = ProtocolParser.readUInt64(stream);
			continue;
		case 72:
			instance.groundPositionZ = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_InventoryPositionSerializer.deserializeLengthDelimited = function(stream, instance) {
	instance.type = 0;
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.type = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.areaX = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.areaY = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.materialId = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.wearPlace = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.activeMaterial = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.groundPositionX = ProtocolParser.readUInt64(stream);
			continue;
		case 64:
			instance.groundPositionY = ProtocolParser.readUInt64(stream);
			continue;
		case 72:
			instance.groundPositionZ = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_InventoryPositionSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_InventoryPosition();
	Packet_InventoryPositionSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_InventoryPositionSerializer.serialize = function(stream, instance) {
	if (instance.type != 0) {
		stream.writeByte(ProtoPlatform.intToByte(8));
		ProtocolParser.writeUInt64(stream, instance.type);
	}
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.areaX);
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.areaY);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.materialId);
	stream.writeByte(ProtoPlatform.intToByte(40));
	ProtocolParser.writeUInt64(stream, instance.wearPlace);
	stream.writeByte(ProtoPlatform.intToByte(48));
	ProtocolParser.writeUInt64(stream, instance.activeMaterial);
	stream.writeByte(ProtoPlatform.intToByte(56));
	ProtocolParser.writeUInt64(stream, instance.groundPositionX);
	stream.writeByte(ProtoPlatform.intToByte(64));
	ProtocolParser.writeUInt64(stream, instance.groundPositionY);
	stream.writeByte(ProtoPlatform.intToByte(72));
	ProtocolParser.writeUInt64(stream, instance.groundPositionZ);
}

Packet_InventoryPositionSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_InventoryPositionSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_InventoryPositionSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_InventoryPositionSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_InventoryPositionTypeEnum()
{
}
Packet_InventoryPositionTypeEnum.GROUND = 1;
Packet_InventoryPositionTypeEnum.MAIN_AREA = 0;
Packet_InventoryPositionTypeEnum.MATERIAL_SELECTOR = 2;
Packet_InventoryPositionTypeEnum.WEAR_PLACE = 3;

function Packet_InventorySerializer()
{
}

Packet_InventorySerializer.deserialize = function(stream, instance) {
	if (instance.items == null) {
		instance.items = new Array(1);
		instance.itemsCount = 0;
		instance.itemsLength = 1;
	}
	if (instance.rightHand == null) {
		instance.rightHand = new Array(1);
		instance.rightHandCount = 0;
		instance.rightHandLength = 1;
	}
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 26:
			if (instance.mainArmor == null)
				instance.mainArmor = Packet_ItemSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer.deserializeLengthDelimited(stream, instance.mainArmor);
			continue;
		case 34:
			if (instance.boots == null)
				instance.boots = Packet_ItemSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer.deserializeLengthDelimited(stream, instance.boots);
			continue;
		case 42:
			if (instance.helmet == null)
				instance.helmet = Packet_ItemSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer.deserializeLengthDelimited(stream, instance.helmet);
			continue;
		case 50:
			if (instance.gauntlet == null)
				instance.gauntlet = Packet_ItemSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer.deserializeLengthDelimited(stream, instance.gauntlet);
			continue;
		case 58:
			instance.itemsAdd(Packet_PositionItemSerializer.deserializeLengthDelimitedNew(stream));
			continue;
		case 66:
			if (instance.dragDropItem == null)
				instance.dragDropItem = Packet_ItemSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer.deserializeLengthDelimited(stream, instance.dragDropItem);
			continue;
		case 74:
			instance.rightHandAdd(Packet_ItemSerializer.deserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_InventorySerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_InventorySerializer.deserialize(ms, instance);
	return instance;
}

Packet_InventorySerializer.deserializeLength = function(stream, length, instance) {
	if (instance.items == null) {
		instance.items = new Array(1);
		instance.itemsCount = 0;
		instance.itemsLength = 1;
	}
	if (instance.rightHand == null) {
		instance.rightHand = new Array(1);
		instance.rightHandCount = 0;
		instance.rightHandLength = 1;
	}
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 26:
			if (instance.mainArmor == null)
				instance.mainArmor = Packet_ItemSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer.deserializeLengthDelimited(stream, instance.mainArmor);
			continue;
		case 34:
			if (instance.boots == null)
				instance.boots = Packet_ItemSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer.deserializeLengthDelimited(stream, instance.boots);
			continue;
		case 42:
			if (instance.helmet == null)
				instance.helmet = Packet_ItemSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer.deserializeLengthDelimited(stream, instance.helmet);
			continue;
		case 50:
			if (instance.gauntlet == null)
				instance.gauntlet = Packet_ItemSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer.deserializeLengthDelimited(stream, instance.gauntlet);
			continue;
		case 58:
			instance.itemsAdd(Packet_PositionItemSerializer.deserializeLengthDelimitedNew(stream));
			continue;
		case 66:
			if (instance.dragDropItem == null)
				instance.dragDropItem = Packet_ItemSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer.deserializeLengthDelimited(stream, instance.dragDropItem);
			continue;
		case 74:
			instance.rightHandAdd(Packet_ItemSerializer.deserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_InventorySerializer.deserializeLengthDelimited = function(stream, instance) {
	if (instance.items == null) {
		instance.items = new Array(1);
		instance.itemsCount = 0;
		instance.itemsLength = 1;
	}
	if (instance.rightHand == null) {
		instance.rightHand = new Array(1);
		instance.rightHandCount = 0;
		instance.rightHandLength = 1;
	}
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 26:
			if (instance.mainArmor == null)
				instance.mainArmor = Packet_ItemSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer.deserializeLengthDelimited(stream, instance.mainArmor);
			continue;
		case 34:
			if (instance.boots == null)
				instance.boots = Packet_ItemSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer.deserializeLengthDelimited(stream, instance.boots);
			continue;
		case 42:
			if (instance.helmet == null)
				instance.helmet = Packet_ItemSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer.deserializeLengthDelimited(stream, instance.helmet);
			continue;
		case 50:
			if (instance.gauntlet == null)
				instance.gauntlet = Packet_ItemSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer.deserializeLengthDelimited(stream, instance.gauntlet);
			continue;
		case 58:
			instance.itemsAdd(Packet_PositionItemSerializer.deserializeLengthDelimitedNew(stream));
			continue;
		case 66:
			if (instance.dragDropItem == null)
				instance.dragDropItem = Packet_ItemSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer.deserializeLengthDelimited(stream, instance.dragDropItem);
			continue;
		case 74:
			instance.rightHandAdd(Packet_ItemSerializer.deserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_InventorySerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_Inventory();
	Packet_InventorySerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_InventorySerializer.serialize = function(stream, instance) {
	if (instance.mainArmor != null) {
		stream.writeByte(ProtoPlatform.intToByte(26));
		var ms3 = new CitoMemoryStream();
		Packet_ItemSerializer.serialize(ms3, instance.mainArmor);
		var ms3Length = ms3.length();
		ProtocolParser.writeUInt32_(stream, ms3Length);
		stream.write(ms3.getBuffer(), 0, ms3Length);
	}
	if (instance.boots != null) {
		stream.writeByte(ProtoPlatform.intToByte(34));
		var ms4 = new CitoMemoryStream();
		Packet_ItemSerializer.serialize(ms4, instance.boots);
		var ms4Length = ms4.length();
		ProtocolParser.writeUInt32_(stream, ms4Length);
		stream.write(ms4.getBuffer(), 0, ms4Length);
	}
	if (instance.helmet != null) {
		stream.writeByte(ProtoPlatform.intToByte(42));
		var ms5 = new CitoMemoryStream();
		Packet_ItemSerializer.serialize(ms5, instance.helmet);
		var ms5Length = ms5.length();
		ProtocolParser.writeUInt32_(stream, ms5Length);
		stream.write(ms5.getBuffer(), 0, ms5Length);
	}
	if (instance.gauntlet != null) {
		stream.writeByte(ProtoPlatform.intToByte(50));
		var ms6 = new CitoMemoryStream();
		Packet_ItemSerializer.serialize(ms6, instance.gauntlet);
		var ms6Length = ms6.length();
		ProtocolParser.writeUInt32_(stream, ms6Length);
		stream.write(ms6.getBuffer(), 0, ms6Length);
	}
	if (instance.items != null) {
		for (var k = 0; k < instance.itemsCount; k++) {
			var i7 = instance.items[k];
			stream.writeByte(ProtoPlatform.intToByte(58));
			var ms7 = new CitoMemoryStream();
			Packet_PositionItemSerializer.serialize(ms7, i7);
			var ms7Length = ms7.length();
			ProtocolParser.writeUInt32_(stream, ms7Length);
			stream.write(ms7.getBuffer(), 0, ms7Length);
		}
	}
	if (instance.dragDropItem != null) {
		stream.writeByte(ProtoPlatform.intToByte(66));
		var ms8 = new CitoMemoryStream();
		Packet_ItemSerializer.serialize(ms8, instance.dragDropItem);
		var ms8Length = ms8.length();
		ProtocolParser.writeUInt32_(stream, ms8Length);
		stream.write(ms8.getBuffer(), 0, ms8Length);
	}
	if (instance.rightHand != null) {
		for (var k = 0; k < instance.rightHandCount; k++) {
			var i9 = instance.rightHand[k];
			stream.writeByte(ProtoPlatform.intToByte(74));
			var ms9 = new CitoMemoryStream();
			Packet_ItemSerializer.serialize(ms9, i9);
			var ms9Length = ms9.length();
			ProtocolParser.writeUInt32_(stream, ms9Length);
			stream.write(ms9.getBuffer(), 0, ms9Length);
		}
	}
}

Packet_InventorySerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_InventorySerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_InventorySerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_InventorySerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_Item()
{
	this.blockCount = 0;
	this.blockId = 0;
	this.itemClass = 0;
	this.itemId = null;
}

Packet_Item.prototype.getBlockCount = function() {
	return this.blockCount;
}

Packet_Item.prototype.getBlockId = function() {
	return this.blockId;
}

Packet_Item.prototype.getItemClass = function() {
	return this.itemClass;
}

Packet_Item.prototype.getItemId = function() {
	return this.itemId;
}

Packet_Item.prototype.setBlockCount = function(value) {
	this.blockCount = value;
}

Packet_Item.prototype.setBlockId = function(value) {
	this.blockId = value;
}

Packet_Item.prototype.setItemClass = function(value) {
	this.itemClass = value;
}

Packet_Item.prototype.setItemId = function(value) {
	this.itemId = value;
}

function Packet_ItemClassEnum()
{
}
Packet_ItemClassEnum.BLOCK = 0;
Packet_ItemClassEnum.BOOTS = 3;
Packet_ItemClassEnum.GAUNTLET = 5;
Packet_ItemClassEnum.HELMET = 4;
Packet_ItemClassEnum.MAIN_ARMOR = 2;
Packet_ItemClassEnum.OTHER = 7;
Packet_ItemClassEnum.SHIELD = 6;
Packet_ItemClassEnum.WEAPON = 1;

function Packet_ItemSerializer()
{
}

Packet_ItemSerializer.deserialize = function(stream, instance) {
	instance.itemClass = 0;
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.itemClass = ProtocolParser.readUInt64(stream);
			continue;
		case 18:
			instance.itemId = ProtocolParser.readString(stream);
			continue;
		case 24:
			instance.blockId = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.blockCount = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ItemSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ItemSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ItemSerializer.deserializeLength = function(stream, length, instance) {
	instance.itemClass = 0;
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.itemClass = ProtocolParser.readUInt64(stream);
			continue;
		case 18:
			instance.itemId = ProtocolParser.readString(stream);
			continue;
		case 24:
			instance.blockId = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.blockCount = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ItemSerializer.deserializeLengthDelimited = function(stream, instance) {
	instance.itemClass = 0;
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.itemClass = ProtocolParser.readUInt64(stream);
			continue;
		case 18:
			instance.itemId = ProtocolParser.readString(stream);
			continue;
		case 24:
			instance.blockId = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.blockCount = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ItemSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_Item();
	Packet_ItemSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ItemSerializer.serialize = function(stream, instance) {
	if (instance.itemClass != 0) {
		stream.writeByte(ProtoPlatform.intToByte(8));
		ProtocolParser.writeUInt64(stream, instance.itemClass);
	}
	if (instance.itemId != null) {
		stream.writeByte(ProtoPlatform.intToByte(18));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.itemId));
	}
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.blockId);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.blockCount);
}

Packet_ItemSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ItemSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ItemSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ItemSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_LeaveReasonEnum()
{
}
Packet_LeaveReasonEnum.CRASH = 1;
Packet_LeaveReasonEnum.LEAVE = 0;

function Packet_PistolTypeEnum()
{
}
Packet_PistolTypeEnum.GRENADE = 1;
Packet_PistolTypeEnum.NORMAL = 0;

function Packet_PositionAndOrientation()
{
	this.heading = 0;
	this.pitch = 0;
	this.stance = 0;
	this.x = 0;
	this.y = 0;
	this.z = 0;
}

Packet_PositionAndOrientation.prototype.getHeading = function() {
	return this.heading;
}

Packet_PositionAndOrientation.prototype.getPitch = function() {
	return this.pitch;
}

Packet_PositionAndOrientation.prototype.getStance = function() {
	return this.stance;
}

Packet_PositionAndOrientation.prototype.getX = function() {
	return this.x;
}

Packet_PositionAndOrientation.prototype.getY = function() {
	return this.y;
}

Packet_PositionAndOrientation.prototype.getZ = function() {
	return this.z;
}

Packet_PositionAndOrientation.prototype.setHeading = function(value) {
	this.heading = value;
}

Packet_PositionAndOrientation.prototype.setPitch = function(value) {
	this.pitch = value;
}

Packet_PositionAndOrientation.prototype.setStance = function(value) {
	this.stance = value;
}

Packet_PositionAndOrientation.prototype.setX = function(value) {
	this.x = value;
}

Packet_PositionAndOrientation.prototype.setY = function(value) {
	this.y = value;
}

Packet_PositionAndOrientation.prototype.setZ = function(value) {
	this.z = value;
}

function Packet_PositionAndOrientationSerializer()
{
}

Packet_PositionAndOrientationSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.heading = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.pitch = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.stance = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_PositionAndOrientationSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_PositionAndOrientationSerializer.deserialize(ms, instance);
	return instance;
}

Packet_PositionAndOrientationSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.heading = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.pitch = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.stance = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_PositionAndOrientationSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.heading = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.pitch = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.stance = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_PositionAndOrientationSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_PositionAndOrientation();
	Packet_PositionAndOrientationSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_PositionAndOrientationSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.x);
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.y);
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.z);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.heading);
	stream.writeByte(ProtoPlatform.intToByte(40));
	ProtocolParser.writeUInt64(stream, instance.pitch);
	stream.writeByte(ProtoPlatform.intToByte(48));
	ProtocolParser.writeUInt64(stream, instance.stance);
}

Packet_PositionAndOrientationSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_PositionAndOrientationSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_PositionAndOrientationSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_PositionAndOrientationSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_PositionItem()
{
	this.key_ = null;
	this.value_ = null;
	this.x = 0;
	this.y = 0;
}

Packet_PositionItem.prototype.getKey_ = function() {
	return this.key_;
}

Packet_PositionItem.prototype.getValue_ = function() {
	return this.value_;
}

Packet_PositionItem.prototype.getX = function() {
	return this.x;
}

Packet_PositionItem.prototype.getY = function() {
	return this.y;
}

Packet_PositionItem.prototype.setKey_ = function(value) {
	this.key_ = value;
}

Packet_PositionItem.prototype.setValue_ = function(value) {
	this.value_ = value;
}

Packet_PositionItem.prototype.setX = function(value) {
	this.x = value;
}

Packet_PositionItem.prototype.setY = function(value) {
	this.y = value;
}

function Packet_PositionItemSerializer()
{
}

Packet_PositionItemSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.key_ = ProtocolParser.readString(stream);
			continue;
		case 18:
			if (instance.value_ == null)
				instance.value_ = Packet_ItemSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer.deserializeLengthDelimited(stream, instance.value_);
			continue;
		case 24:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_PositionItemSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_PositionItemSerializer.deserialize(ms, instance);
	return instance;
}

Packet_PositionItemSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.key_ = ProtocolParser.readString(stream);
			continue;
		case 18:
			if (instance.value_ == null)
				instance.value_ = Packet_ItemSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer.deserializeLengthDelimited(stream, instance.value_);
			continue;
		case 24:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_PositionItemSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.key_ = ProtocolParser.readString(stream);
			continue;
		case 18:
			if (instance.value_ == null)
				instance.value_ = Packet_ItemSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer.deserializeLengthDelimited(stream, instance.value_);
			continue;
		case 24:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_PositionItemSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_PositionItem();
	Packet_PositionItemSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_PositionItemSerializer.serialize = function(stream, instance) {
	if (instance.key_ != null) {
		stream.writeByte(ProtoPlatform.intToByte(10));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.key_));
	}
	if (instance.value_ != null) {
		stream.writeByte(ProtoPlatform.intToByte(18));
		var ms2 = new CitoMemoryStream();
		Packet_ItemSerializer.serialize(ms2, instance.value_);
		var ms2Length = ms2.length();
		ProtocolParser.writeUInt32_(stream, ms2Length);
		stream.write(ms2.getBuffer(), 0, ms2Length);
	}
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.x);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.y);
}

Packet_PositionItemSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_PositionItemSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_PositionItemSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_PositionItemSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_Server()
{
	this.ammo = null;
	this.blobFinalize = null;
	this.blobInitialize = null;
	this.blobPart = null;
	this.blockType = null;
	this.blockTypes = null;
	this.bullet = null;
	this.chunkPart = null;
	this.chunk_ = null;
	this.craftingRecipes = null;
	this.dialog = null;
	this.disconnectPlayer = null;
	this.entityDespawn = null;
	this.entityPosition = null;
	this.entitySpawn = null;
	this.explosion = null;
	this.fillArea = null;
	this.fillAreaLimit = null;
	this.follow = null;
	this.freemove = null;
	this.heightmapChunk = null;
	this.id = 0;
	this.identification = null;
	this.inventory = null;
	this.levelDataChunk = null;
	this.levelFinalize = null;
	this.levelInitialize = null;
	this.lightLevels = null;
	this.message = null;
	this.monster = null;
	this.ping = null;
	this.playerPing = null;
	this.playerSpawnPosition = null;
	this.playerStats = null;
	this.projectile = null;
	this.queryAnswer = null;
	this.redirect = null;
	this.season = null;
	this.setBlock = null;
	this.sound = null;
	this.sunLevels = null;
	this.translation = null;
}

Packet_Server.prototype.getAmmo = function() {
	return this.ammo;
}

Packet_Server.prototype.getBlobFinalize = function() {
	return this.blobFinalize;
}

Packet_Server.prototype.getBlobInitialize = function() {
	return this.blobInitialize;
}

Packet_Server.prototype.getBlobPart = function() {
	return this.blobPart;
}

Packet_Server.prototype.getBlockType = function() {
	return this.blockType;
}

Packet_Server.prototype.getBlockTypes = function() {
	return this.blockTypes;
}

Packet_Server.prototype.getBullet = function() {
	return this.bullet;
}

Packet_Server.prototype.getChunkPart = function() {
	return this.chunkPart;
}

Packet_Server.prototype.getChunk_ = function() {
	return this.chunk_;
}

Packet_Server.prototype.getCraftingRecipes = function() {
	return this.craftingRecipes;
}

Packet_Server.prototype.getDialog = function() {
	return this.dialog;
}

Packet_Server.prototype.getDisconnectPlayer = function() {
	return this.disconnectPlayer;
}

Packet_Server.prototype.getEntityDespawn = function() {
	return this.entityDespawn;
}

Packet_Server.prototype.getEntityPosition = function() {
	return this.entityPosition;
}

Packet_Server.prototype.getEntitySpawn = function() {
	return this.entitySpawn;
}

Packet_Server.prototype.getExplosion = function() {
	return this.explosion;
}

Packet_Server.prototype.getFillArea = function() {
	return this.fillArea;
}

Packet_Server.prototype.getFillAreaLimit = function() {
	return this.fillAreaLimit;
}

Packet_Server.prototype.getFollow = function() {
	return this.follow;
}

Packet_Server.prototype.getFreemove = function() {
	return this.freemove;
}

Packet_Server.prototype.getHeightmapChunk = function() {
	return this.heightmapChunk;
}

Packet_Server.prototype.getId = function() {
	return this.id;
}

Packet_Server.prototype.getIdentification = function() {
	return this.identification;
}

Packet_Server.prototype.getInventory = function() {
	return this.inventory;
}

Packet_Server.prototype.getLevelDataChunk = function() {
	return this.levelDataChunk;
}

Packet_Server.prototype.getLevelFinalize = function() {
	return this.levelFinalize;
}

Packet_Server.prototype.getLevelInitialize = function() {
	return this.levelInitialize;
}

Packet_Server.prototype.getLightLevels = function() {
	return this.lightLevels;
}

Packet_Server.prototype.getMessage = function() {
	return this.message;
}

Packet_Server.prototype.getMonster = function() {
	return this.monster;
}

Packet_Server.prototype.getPing = function() {
	return this.ping;
}

Packet_Server.prototype.getPlayerPing = function() {
	return this.playerPing;
}

Packet_Server.prototype.getPlayerSpawnPosition = function() {
	return this.playerSpawnPosition;
}

Packet_Server.prototype.getPlayerStats = function() {
	return this.playerStats;
}

Packet_Server.prototype.getProjectile = function() {
	return this.projectile;
}

Packet_Server.prototype.getQueryAnswer = function() {
	return this.queryAnswer;
}

Packet_Server.prototype.getRedirect = function() {
	return this.redirect;
}

Packet_Server.prototype.getSeason = function() {
	return this.season;
}

Packet_Server.prototype.getSetBlock = function() {
	return this.setBlock;
}

Packet_Server.prototype.getSound = function() {
	return this.sound;
}

Packet_Server.prototype.getSunLevels = function() {
	return this.sunLevels;
}

Packet_Server.prototype.getTranslation = function() {
	return this.translation;
}

Packet_Server.prototype.setAmmo = function(value) {
	this.ammo = value;
}

Packet_Server.prototype.setBlobFinalize = function(value) {
	this.blobFinalize = value;
}

Packet_Server.prototype.setBlobInitialize = function(value) {
	this.blobInitialize = value;
}

Packet_Server.prototype.setBlobPart = function(value) {
	this.blobPart = value;
}

Packet_Server.prototype.setBlockType = function(value) {
	this.blockType = value;
}

Packet_Server.prototype.setBlockTypes = function(value) {
	this.blockTypes = value;
}

Packet_Server.prototype.setBullet = function(value) {
	this.bullet = value;
}

Packet_Server.prototype.setChunkPart = function(value) {
	this.chunkPart = value;
}

Packet_Server.prototype.setChunk_ = function(value) {
	this.chunk_ = value;
}

Packet_Server.prototype.setCraftingRecipes = function(value) {
	this.craftingRecipes = value;
}

Packet_Server.prototype.setDialog = function(value) {
	this.dialog = value;
}

Packet_Server.prototype.setDisconnectPlayer = function(value) {
	this.disconnectPlayer = value;
}

Packet_Server.prototype.setEntityDespawn = function(value) {
	this.entityDespawn = value;
}

Packet_Server.prototype.setEntityPosition = function(value) {
	this.entityPosition = value;
}

Packet_Server.prototype.setEntitySpawn = function(value) {
	this.entitySpawn = value;
}

Packet_Server.prototype.setExplosion = function(value) {
	this.explosion = value;
}

Packet_Server.prototype.setFillArea = function(value) {
	this.fillArea = value;
}

Packet_Server.prototype.setFillAreaLimit = function(value) {
	this.fillAreaLimit = value;
}

Packet_Server.prototype.setFollow = function(value) {
	this.follow = value;
}

Packet_Server.prototype.setFreemove = function(value) {
	this.freemove = value;
}

Packet_Server.prototype.setHeightmapChunk = function(value) {
	this.heightmapChunk = value;
}

Packet_Server.prototype.setId = function(value) {
	this.id = value;
}

Packet_Server.prototype.setIdentification = function(value) {
	this.identification = value;
}

Packet_Server.prototype.setInventory = function(value) {
	this.inventory = value;
}

Packet_Server.prototype.setLevelDataChunk = function(value) {
	this.levelDataChunk = value;
}

Packet_Server.prototype.setLevelFinalize = function(value) {
	this.levelFinalize = value;
}

Packet_Server.prototype.setLevelInitialize = function(value) {
	this.levelInitialize = value;
}

Packet_Server.prototype.setLightLevels = function(value) {
	this.lightLevels = value;
}

Packet_Server.prototype.setMessage = function(value) {
	this.message = value;
}

Packet_Server.prototype.setMonster = function(value) {
	this.monster = value;
}

Packet_Server.prototype.setPing = function(value) {
	this.ping = value;
}

Packet_Server.prototype.setPlayerPing = function(value) {
	this.playerPing = value;
}

Packet_Server.prototype.setPlayerSpawnPosition = function(value) {
	this.playerSpawnPosition = value;
}

Packet_Server.prototype.setPlayerStats = function(value) {
	this.playerStats = value;
}

Packet_Server.prototype.setProjectile = function(value) {
	this.projectile = value;
}

Packet_Server.prototype.setQueryAnswer = function(value) {
	this.queryAnswer = value;
}

Packet_Server.prototype.setRedirect = function(value) {
	this.redirect = value;
}

Packet_Server.prototype.setSeason = function(value) {
	this.season = value;
}

Packet_Server.prototype.setSetBlock = function(value) {
	this.setBlock = value;
}

Packet_Server.prototype.setSound = function(value) {
	this.sound = value;
}

Packet_Server.prototype.setSunLevels = function(value) {
	this.sunLevels = value;
}

Packet_Server.prototype.setTranslation = function(value) {
	this.translation = value;
}

function Packet_ServerAmmo()
{
	this.totalAmmo = null;
	this.totalAmmoCount = 0;
	this.totalAmmoLength = 0;
}

Packet_ServerAmmo.prototype.getTotalAmmo = function() {
	return this.totalAmmo;
}

Packet_ServerAmmo.prototype.getTotalAmmoCount = function() {
	return this.totalAmmoCount;
}

Packet_ServerAmmo.prototype.getTotalAmmoLength = function() {
	return this.totalAmmoLength;
}

Packet_ServerAmmo.prototype.setTotalAmmo = function(value, count, length) {
	this.totalAmmo = value;
	this.totalAmmoCount = count;
	this.totalAmmoLength = length;
}

Packet_ServerAmmo.prototype.totalAmmoAdd = function(value) {
	if (this.totalAmmoCount >= this.totalAmmoLength) {
		var TotalAmmo2 = new Array(this.totalAmmoLength * 2);
		this.totalAmmoLength = this.totalAmmoLength * 2;
		for (var i = 0; i < this.totalAmmoCount; i++) {
			TotalAmmo2[i] = this.totalAmmo[i];
		}
		this.totalAmmo = TotalAmmo2;
	}
	this.totalAmmo[this.totalAmmoCount] = value;
	this.totalAmmoCount++;
}

function Packet_ServerAmmoSerializer()
{
}

Packet_ServerAmmoSerializer.deserialize = function(stream, instance) {
	if (instance.totalAmmo == null) {
		instance.totalAmmo = new Array(1);
		instance.totalAmmoCount = 0;
		instance.totalAmmoLength = 1;
	}
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.totalAmmoAdd(Packet_IntIntSerializer.deserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerAmmoSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerAmmoSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerAmmoSerializer.deserializeLength = function(stream, length, instance) {
	if (instance.totalAmmo == null) {
		instance.totalAmmo = new Array(1);
		instance.totalAmmoCount = 0;
		instance.totalAmmoLength = 1;
	}
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.totalAmmoAdd(Packet_IntIntSerializer.deserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerAmmoSerializer.deserializeLengthDelimited = function(stream, instance) {
	if (instance.totalAmmo == null) {
		instance.totalAmmo = new Array(1);
		instance.totalAmmoCount = 0;
		instance.totalAmmoLength = 1;
	}
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.totalAmmoAdd(Packet_IntIntSerializer.deserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerAmmoSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerAmmo();
	Packet_ServerAmmoSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerAmmoSerializer.serialize = function(stream, instance) {
	if (instance.totalAmmo != null) {
		for (var k = 0; k < instance.totalAmmoCount; k++) {
			var i1 = instance.totalAmmo[k];
			stream.writeByte(ProtoPlatform.intToByte(10));
			var ms1 = new CitoMemoryStream();
			Packet_IntIntSerializer.serialize(ms1, i1);
			var ms1Length = ms1.length();
			ProtocolParser.writeUInt32_(stream, ms1Length);
			stream.write(ms1.getBuffer(), 0, ms1Length);
		}
	}
}

Packet_ServerAmmoSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerAmmoSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerAmmoSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerAmmoSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerBlobFinalize()
{
}

function Packet_ServerBlobFinalizeSerializer()
{
}

Packet_ServerBlobFinalizeSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlobFinalizeSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerBlobFinalizeSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerBlobFinalizeSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlobFinalizeSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlobFinalizeSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerBlobFinalize();
	Packet_ServerBlobFinalizeSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerBlobFinalizeSerializer.serialize = function(stream, instance) {
}

Packet_ServerBlobFinalizeSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerBlobFinalizeSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerBlobFinalizeSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerBlobFinalizeSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerBlobInitialize()
{
	this.md5 = null;
	this.name = null;
}

Packet_ServerBlobInitialize.prototype.getMd5 = function() {
	return this.md5;
}

Packet_ServerBlobInitialize.prototype.getName = function() {
	return this.name;
}

Packet_ServerBlobInitialize.prototype.setMd5 = function(value) {
	this.md5 = value;
}

Packet_ServerBlobInitialize.prototype.setName = function(value) {
	this.name = value;
}

function Packet_ServerBlobInitializeSerializer()
{
}

Packet_ServerBlobInitializeSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 18:
			instance.name = ProtocolParser.readString(stream);
			continue;
		case 26:
			instance.md5 = ProtocolParser.readString(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlobInitializeSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerBlobInitializeSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerBlobInitializeSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 18:
			instance.name = ProtocolParser.readString(stream);
			continue;
		case 26:
			instance.md5 = ProtocolParser.readString(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlobInitializeSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 18:
			instance.name = ProtocolParser.readString(stream);
			continue;
		case 26:
			instance.md5 = ProtocolParser.readString(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlobInitializeSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerBlobInitialize();
	Packet_ServerBlobInitializeSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerBlobInitializeSerializer.serialize = function(stream, instance) {
	if (instance.name != null) {
		stream.writeByte(ProtoPlatform.intToByte(18));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.name));
	}
	if (instance.md5 != null) {
		stream.writeByte(ProtoPlatform.intToByte(26));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.md5));
	}
}

Packet_ServerBlobInitializeSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerBlobInitializeSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerBlobInitializeSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerBlobInitializeSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerBlobPart()
{
	this.data = null;
	this.islastpart = 0;
}

Packet_ServerBlobPart.prototype.getData = function() {
	return this.data;
}

Packet_ServerBlobPart.prototype.getIslastpart = function() {
	return this.islastpart;
}

Packet_ServerBlobPart.prototype.setData = function(value) {
	this.data = value;
}

Packet_ServerBlobPart.prototype.setIslastpart = function(value) {
	this.islastpart = value;
}

function Packet_ServerBlobPartSerializer()
{
}

Packet_ServerBlobPartSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.data = ProtocolParser.readBytes(stream);
			continue;
		case 16:
			instance.islastpart = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlobPartSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerBlobPartSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerBlobPartSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.data = ProtocolParser.readBytes(stream);
			continue;
		case 16:
			instance.islastpart = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlobPartSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.data = ProtocolParser.readBytes(stream);
			continue;
		case 16:
			instance.islastpart = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlobPartSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerBlobPart();
	Packet_ServerBlobPartSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerBlobPartSerializer.serialize = function(stream, instance) {
	if (instance.data != null) {
		stream.writeByte(ProtoPlatform.intToByte(10));
		ProtocolParser.writeBytes(stream, instance.data);
	}
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.islastpart);
}

Packet_ServerBlobPartSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerBlobPartSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerBlobPartSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerBlobPartSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerBlockType()
{
	this.blocktype = null;
	this.id = 0;
}

Packet_ServerBlockType.prototype.getBlocktype = function() {
	return this.blocktype;
}

Packet_ServerBlockType.prototype.getId = function() {
	return this.id;
}

Packet_ServerBlockType.prototype.setBlocktype = function(value) {
	this.blocktype = value;
}

Packet_ServerBlockType.prototype.setId = function(value) {
	this.id = value;
}

function Packet_ServerBlockTypeSerializer()
{
}

Packet_ServerBlockTypeSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.id = ProtocolParser.readUInt64(stream);
			continue;
		case 18:
			if (instance.blocktype == null)
				instance.blocktype = Packet_BlockTypeSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_BlockTypeSerializer.deserializeLengthDelimited(stream, instance.blocktype);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlockTypeSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerBlockTypeSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerBlockTypeSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.id = ProtocolParser.readUInt64(stream);
			continue;
		case 18:
			if (instance.blocktype == null)
				instance.blocktype = Packet_BlockTypeSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_BlockTypeSerializer.deserializeLengthDelimited(stream, instance.blocktype);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlockTypeSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.id = ProtocolParser.readUInt64(stream);
			continue;
		case 18:
			if (instance.blocktype == null)
				instance.blocktype = Packet_BlockTypeSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_BlockTypeSerializer.deserializeLengthDelimited(stream, instance.blocktype);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlockTypeSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerBlockType();
	Packet_ServerBlockTypeSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerBlockTypeSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.id);
	if (instance.blocktype != null) {
		stream.writeByte(ProtoPlatform.intToByte(18));
		var ms2 = new CitoMemoryStream();
		Packet_BlockTypeSerializer.serialize(ms2, instance.blocktype);
		var ms2Length = ms2.length();
		ProtocolParser.writeUInt32_(stream, ms2Length);
		stream.write(ms2.getBuffer(), 0, ms2Length);
	}
}

Packet_ServerBlockTypeSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerBlockTypeSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerBlockTypeSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerBlockTypeSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerBlockTypes()
{
}

function Packet_ServerBlockTypesSerializer()
{
}

Packet_ServerBlockTypesSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlockTypesSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerBlockTypesSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerBlockTypesSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlockTypesSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlockTypesSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerBlockTypes();
	Packet_ServerBlockTypesSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerBlockTypesSerializer.serialize = function(stream, instance) {
}

Packet_ServerBlockTypesSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerBlockTypesSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerBlockTypesSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerBlockTypesSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerBullet()
{
	this.fromXFloat = 0;
	this.fromYFloat = 0;
	this.fromZFloat = 0;
	this.speedFloat = 0;
	this.toXFloat = 0;
	this.toYFloat = 0;
	this.toZFloat = 0;
}

Packet_ServerBullet.prototype.getFromXFloat = function() {
	return this.fromXFloat;
}

Packet_ServerBullet.prototype.getFromYFloat = function() {
	return this.fromYFloat;
}

Packet_ServerBullet.prototype.getFromZFloat = function() {
	return this.fromZFloat;
}

Packet_ServerBullet.prototype.getSpeedFloat = function() {
	return this.speedFloat;
}

Packet_ServerBullet.prototype.getToXFloat = function() {
	return this.toXFloat;
}

Packet_ServerBullet.prototype.getToYFloat = function() {
	return this.toYFloat;
}

Packet_ServerBullet.prototype.getToZFloat = function() {
	return this.toZFloat;
}

Packet_ServerBullet.prototype.setFromXFloat = function(value) {
	this.fromXFloat = value;
}

Packet_ServerBullet.prototype.setFromYFloat = function(value) {
	this.fromYFloat = value;
}

Packet_ServerBullet.prototype.setFromZFloat = function(value) {
	this.fromZFloat = value;
}

Packet_ServerBullet.prototype.setSpeedFloat = function(value) {
	this.speedFloat = value;
}

Packet_ServerBullet.prototype.setToXFloat = function(value) {
	this.toXFloat = value;
}

Packet_ServerBullet.prototype.setToYFloat = function(value) {
	this.toYFloat = value;
}

Packet_ServerBullet.prototype.setToZFloat = function(value) {
	this.toZFloat = value;
}

function Packet_ServerBulletSerializer()
{
}

Packet_ServerBulletSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.fromXFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.fromYFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.fromZFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.toXFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.toYFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.toZFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.speedFloat = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBulletSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerBulletSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerBulletSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.fromXFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.fromYFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.fromZFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.toXFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.toYFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.toZFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.speedFloat = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBulletSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.fromXFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.fromYFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.fromZFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.toXFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.toYFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.toZFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.speedFloat = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBulletSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerBullet();
	Packet_ServerBulletSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerBulletSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.fromXFloat);
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.fromYFloat);
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.fromZFloat);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.toXFloat);
	stream.writeByte(ProtoPlatform.intToByte(40));
	ProtocolParser.writeUInt64(stream, instance.toYFloat);
	stream.writeByte(ProtoPlatform.intToByte(48));
	ProtocolParser.writeUInt64(stream, instance.toZFloat);
	stream.writeByte(ProtoPlatform.intToByte(56));
	ProtocolParser.writeUInt64(stream, instance.speedFloat);
}

Packet_ServerBulletSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerBulletSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerBulletSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerBulletSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerChunk()
{
	this.sizeX = 0;
	this.sizeY = 0;
	this.sizeZ = 0;
	this.x = 0;
	this.y = 0;
	this.z = 0;
}

Packet_ServerChunk.prototype.getSizeX = function() {
	return this.sizeX;
}

Packet_ServerChunk.prototype.getSizeY = function() {
	return this.sizeY;
}

Packet_ServerChunk.prototype.getSizeZ = function() {
	return this.sizeZ;
}

Packet_ServerChunk.prototype.getX = function() {
	return this.x;
}

Packet_ServerChunk.prototype.getY = function() {
	return this.y;
}

Packet_ServerChunk.prototype.getZ = function() {
	return this.z;
}

Packet_ServerChunk.prototype.setSizeX = function(value) {
	this.sizeX = value;
}

Packet_ServerChunk.prototype.setSizeY = function(value) {
	this.sizeY = value;
}

Packet_ServerChunk.prototype.setSizeZ = function(value) {
	this.sizeZ = value;
}

Packet_ServerChunk.prototype.setX = function(value) {
	this.x = value;
}

Packet_ServerChunk.prototype.setY = function(value) {
	this.y = value;
}

Packet_ServerChunk.prototype.setZ = function(value) {
	this.z = value;
}

function Packet_ServerChunkPart()
{
	this.compressedChunkPart = null;
}

Packet_ServerChunkPart.prototype.getCompressedChunkPart = function() {
	return this.compressedChunkPart;
}

Packet_ServerChunkPart.prototype.setCompressedChunkPart = function(value) {
	this.compressedChunkPart = value;
}

function Packet_ServerChunkPartSerializer()
{
}

Packet_ServerChunkPartSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.compressedChunkPart = ProtocolParser.readBytes(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerChunkPartSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerChunkPartSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerChunkPartSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.compressedChunkPart = ProtocolParser.readBytes(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerChunkPartSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.compressedChunkPart = ProtocolParser.readBytes(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerChunkPartSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerChunkPart();
	Packet_ServerChunkPartSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerChunkPartSerializer.serialize = function(stream, instance) {
	if (instance.compressedChunkPart != null) {
		stream.writeByte(ProtoPlatform.intToByte(10));
		ProtocolParser.writeBytes(stream, instance.compressedChunkPart);
	}
}

Packet_ServerChunkPartSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerChunkPartSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerChunkPartSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerChunkPartSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerChunkSerializer()
{
}

Packet_ServerChunkSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.sizeX = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.sizeY = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.sizeZ = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerChunkSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerChunkSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerChunkSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.sizeX = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.sizeY = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.sizeZ = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerChunkSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.sizeX = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.sizeY = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.sizeZ = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerChunkSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerChunk();
	Packet_ServerChunkSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerChunkSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.x);
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.y);
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.z);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.sizeX);
	stream.writeByte(ProtoPlatform.intToByte(40));
	ProtocolParser.writeUInt64(stream, instance.sizeY);
	stream.writeByte(ProtoPlatform.intToByte(48));
	ProtocolParser.writeUInt64(stream, instance.sizeZ);
}

Packet_ServerChunkSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerChunkSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerChunkSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerChunkSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerCraftingRecipes()
{
	this.craftingRecipes = null;
	this.craftingRecipesCount = 0;
	this.craftingRecipesLength = 0;
}

Packet_ServerCraftingRecipes.prototype.craftingRecipesAdd = function(value) {
	if (this.craftingRecipesCount >= this.craftingRecipesLength) {
		var CraftingRecipes2 = new Array(this.craftingRecipesLength * 2);
		this.craftingRecipesLength = this.craftingRecipesLength * 2;
		for (var i = 0; i < this.craftingRecipesCount; i++) {
			CraftingRecipes2[i] = this.craftingRecipes[i];
		}
		this.craftingRecipes = CraftingRecipes2;
	}
	this.craftingRecipes[this.craftingRecipesCount] = value;
	this.craftingRecipesCount++;
}

Packet_ServerCraftingRecipes.prototype.getCraftingRecipes = function() {
	return this.craftingRecipes;
}

Packet_ServerCraftingRecipes.prototype.getCraftingRecipesCount = function() {
	return this.craftingRecipesCount;
}

Packet_ServerCraftingRecipes.prototype.getCraftingRecipesLength = function() {
	return this.craftingRecipesLength;
}

Packet_ServerCraftingRecipes.prototype.setCraftingRecipes = function(value, count, length) {
	this.craftingRecipes = value;
	this.craftingRecipesCount = count;
	this.craftingRecipesLength = length;
}

function Packet_ServerCraftingRecipesSerializer()
{
}

Packet_ServerCraftingRecipesSerializer.deserialize = function(stream, instance) {
	if (instance.craftingRecipes == null) {
		instance.craftingRecipes = new Array(1);
		instance.craftingRecipesCount = 0;
		instance.craftingRecipesLength = 1;
	}
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.craftingRecipesAdd(Packet_CraftingRecipeSerializer.deserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerCraftingRecipesSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerCraftingRecipesSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerCraftingRecipesSerializer.deserializeLength = function(stream, length, instance) {
	if (instance.craftingRecipes == null) {
		instance.craftingRecipes = new Array(1);
		instance.craftingRecipesCount = 0;
		instance.craftingRecipesLength = 1;
	}
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.craftingRecipesAdd(Packet_CraftingRecipeSerializer.deserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerCraftingRecipesSerializer.deserializeLengthDelimited = function(stream, instance) {
	if (instance.craftingRecipes == null) {
		instance.craftingRecipes = new Array(1);
		instance.craftingRecipesCount = 0;
		instance.craftingRecipesLength = 1;
	}
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.craftingRecipesAdd(Packet_CraftingRecipeSerializer.deserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerCraftingRecipesSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerCraftingRecipes();
	Packet_ServerCraftingRecipesSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerCraftingRecipesSerializer.serialize = function(stream, instance) {
	if (instance.craftingRecipes != null) {
		for (var k = 0; k < instance.craftingRecipesCount; k++) {
			var i1 = instance.craftingRecipes[k];
			stream.writeByte(ProtoPlatform.intToByte(10));
			var ms1 = new CitoMemoryStream();
			Packet_CraftingRecipeSerializer.serialize(ms1, i1);
			var ms1Length = ms1.length();
			ProtocolParser.writeUInt32_(stream, ms1Length);
			stream.write(ms1.getBuffer(), 0, ms1Length);
		}
	}
}

Packet_ServerCraftingRecipesSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerCraftingRecipesSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerCraftingRecipesSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerCraftingRecipesSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerDialog()
{
	this.dialog = null;
	this.dialogId = null;
}

Packet_ServerDialog.prototype.getDialog = function() {
	return this.dialog;
}

Packet_ServerDialog.prototype.getDialogId = function() {
	return this.dialogId;
}

Packet_ServerDialog.prototype.setDialog = function(value) {
	this.dialog = value;
}

Packet_ServerDialog.prototype.setDialogId = function(value) {
	this.dialogId = value;
}

function Packet_ServerDialogSerializer()
{
}

Packet_ServerDialogSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.dialogId = ProtocolParser.readString(stream);
			continue;
		case 18:
			if (instance.dialog == null)
				instance.dialog = Packet_DialogSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_DialogSerializer.deserializeLengthDelimited(stream, instance.dialog);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerDialogSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerDialogSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerDialogSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.dialogId = ProtocolParser.readString(stream);
			continue;
		case 18:
			if (instance.dialog == null)
				instance.dialog = Packet_DialogSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_DialogSerializer.deserializeLengthDelimited(stream, instance.dialog);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerDialogSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.dialogId = ProtocolParser.readString(stream);
			continue;
		case 18:
			if (instance.dialog == null)
				instance.dialog = Packet_DialogSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_DialogSerializer.deserializeLengthDelimited(stream, instance.dialog);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerDialogSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerDialog();
	Packet_ServerDialogSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerDialogSerializer.serialize = function(stream, instance) {
	if (instance.dialogId != null) {
		stream.writeByte(ProtoPlatform.intToByte(10));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.dialogId));
	}
	if (instance.dialog != null) {
		stream.writeByte(ProtoPlatform.intToByte(18));
		var ms2 = new CitoMemoryStream();
		Packet_DialogSerializer.serialize(ms2, instance.dialog);
		var ms2Length = ms2.length();
		ProtocolParser.writeUInt32_(stream, ms2Length);
		stream.write(ms2.getBuffer(), 0, ms2Length);
	}
}

Packet_ServerDialogSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerDialogSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerDialogSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerDialogSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerDisconnectPlayer()
{
	this.disconnectReason = null;
}

Packet_ServerDisconnectPlayer.prototype.getDisconnectReason = function() {
	return this.disconnectReason;
}

Packet_ServerDisconnectPlayer.prototype.setDisconnectReason = function(value) {
	this.disconnectReason = value;
}

function Packet_ServerDisconnectPlayerSerializer()
{
}

Packet_ServerDisconnectPlayerSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.disconnectReason = ProtocolParser.readString(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerDisconnectPlayerSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerDisconnectPlayerSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerDisconnectPlayerSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.disconnectReason = ProtocolParser.readString(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerDisconnectPlayerSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.disconnectReason = ProtocolParser.readString(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerDisconnectPlayerSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerDisconnectPlayer();
	Packet_ServerDisconnectPlayerSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerDisconnectPlayerSerializer.serialize = function(stream, instance) {
	if (instance.disconnectReason != null) {
		stream.writeByte(ProtoPlatform.intToByte(10));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.disconnectReason));
	}
}

Packet_ServerDisconnectPlayerSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerDisconnectPlayerSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerDisconnectPlayerSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerDisconnectPlayerSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerEntity()
{
	this.drawArea = null;
	this.drawBlock = null;
	this.drawModel = null;
	this.drawName_ = null;
	this.drawText = null;
	this.playerStats = null;
	this.position = null;
	this.push = null;
	this.usable = false;
}

Packet_ServerEntity.prototype.getDrawArea = function() {
	return this.drawArea;
}

Packet_ServerEntity.prototype.getDrawBlock = function() {
	return this.drawBlock;
}

Packet_ServerEntity.prototype.getDrawModel = function() {
	return this.drawModel;
}

Packet_ServerEntity.prototype.getDrawName_ = function() {
	return this.drawName_;
}

Packet_ServerEntity.prototype.getDrawText = function() {
	return this.drawText;
}

Packet_ServerEntity.prototype.getPlayerStats = function() {
	return this.playerStats;
}

Packet_ServerEntity.prototype.getPosition = function() {
	return this.position;
}

Packet_ServerEntity.prototype.getPush = function() {
	return this.push;
}

Packet_ServerEntity.prototype.getUsable = function() {
	return this.usable;
}

Packet_ServerEntity.prototype.setDrawArea = function(value) {
	this.drawArea = value;
}

Packet_ServerEntity.prototype.setDrawBlock = function(value) {
	this.drawBlock = value;
}

Packet_ServerEntity.prototype.setDrawModel = function(value) {
	this.drawModel = value;
}

Packet_ServerEntity.prototype.setDrawName_ = function(value) {
	this.drawName_ = value;
}

Packet_ServerEntity.prototype.setDrawText = function(value) {
	this.drawText = value;
}

Packet_ServerEntity.prototype.setPlayerStats = function(value) {
	this.playerStats = value;
}

Packet_ServerEntity.prototype.setPosition = function(value) {
	this.position = value;
}

Packet_ServerEntity.prototype.setPush = function(value) {
	this.push = value;
}

Packet_ServerEntity.prototype.setUsable = function(value) {
	this.usable = value;
}

function Packet_ServerEntityAnimatedModel()
{
	this.downloadSkin = 0;
	this.eyeHeight = 0;
	this.modelHeight = 0;
	this.model_ = null;
	this.texture_ = null;
}

Packet_ServerEntityAnimatedModel.prototype.getDownloadSkin = function() {
	return this.downloadSkin;
}

Packet_ServerEntityAnimatedModel.prototype.getEyeHeight = function() {
	return this.eyeHeight;
}

Packet_ServerEntityAnimatedModel.prototype.getModelHeight = function() {
	return this.modelHeight;
}

Packet_ServerEntityAnimatedModel.prototype.getModel_ = function() {
	return this.model_;
}

Packet_ServerEntityAnimatedModel.prototype.getTexture_ = function() {
	return this.texture_;
}

Packet_ServerEntityAnimatedModel.prototype.setDownloadSkin = function(value) {
	this.downloadSkin = value;
}

Packet_ServerEntityAnimatedModel.prototype.setEyeHeight = function(value) {
	this.eyeHeight = value;
}

Packet_ServerEntityAnimatedModel.prototype.setModelHeight = function(value) {
	this.modelHeight = value;
}

Packet_ServerEntityAnimatedModel.prototype.setModel_ = function(value) {
	this.model_ = value;
}

Packet_ServerEntityAnimatedModel.prototype.setTexture_ = function(value) {
	this.texture_ = value;
}

function Packet_ServerEntityAnimatedModelSerializer()
{
}

Packet_ServerEntityAnimatedModelSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.model_ = ProtocolParser.readString(stream);
			continue;
		case 18:
			instance.texture_ = ProtocolParser.readString(stream);
			continue;
		case 24:
			instance.eyeHeight = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.modelHeight = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.downloadSkin = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityAnimatedModelSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerEntityAnimatedModelSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerEntityAnimatedModelSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.model_ = ProtocolParser.readString(stream);
			continue;
		case 18:
			instance.texture_ = ProtocolParser.readString(stream);
			continue;
		case 24:
			instance.eyeHeight = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.modelHeight = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.downloadSkin = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityAnimatedModelSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.model_ = ProtocolParser.readString(stream);
			continue;
		case 18:
			instance.texture_ = ProtocolParser.readString(stream);
			continue;
		case 24:
			instance.eyeHeight = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.modelHeight = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.downloadSkin = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityAnimatedModelSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerEntityAnimatedModel();
	Packet_ServerEntityAnimatedModelSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerEntityAnimatedModelSerializer.serialize = function(stream, instance) {
	if (instance.model_ != null) {
		stream.writeByte(ProtoPlatform.intToByte(10));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.model_));
	}
	if (instance.texture_ != null) {
		stream.writeByte(ProtoPlatform.intToByte(18));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.texture_));
	}
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.eyeHeight);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.modelHeight);
	stream.writeByte(ProtoPlatform.intToByte(40));
	ProtocolParser.writeUInt64(stream, instance.downloadSkin);
}

Packet_ServerEntityAnimatedModelSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerEntityAnimatedModelSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerEntityAnimatedModelSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerEntityAnimatedModelSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerEntityDespawn()
{
	this.id = 0;
}

Packet_ServerEntityDespawn.prototype.getId = function() {
	return this.id;
}

Packet_ServerEntityDespawn.prototype.setId = function(value) {
	this.id = value;
}

function Packet_ServerEntityDespawnSerializer()
{
}

Packet_ServerEntityDespawnSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.id = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDespawnSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerEntityDespawnSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerEntityDespawnSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.id = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDespawnSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.id = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDespawnSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerEntityDespawn();
	Packet_ServerEntityDespawnSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerEntityDespawnSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.id);
}

Packet_ServerEntityDespawnSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerEntityDespawnSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerEntityDespawnSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerEntityDespawnSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerEntityDrawArea()
{
	this.sizex = 0;
	this.sizey = 0;
	this.sizez = 0;
	this.visibleToClientId = 0;
	this.x = 0;
	this.y = 0;
	this.z = 0;
}

Packet_ServerEntityDrawArea.prototype.getSizex = function() {
	return this.sizex;
}

Packet_ServerEntityDrawArea.prototype.getSizey = function() {
	return this.sizey;
}

Packet_ServerEntityDrawArea.prototype.getSizez = function() {
	return this.sizez;
}

Packet_ServerEntityDrawArea.prototype.getVisibleToClientId = function() {
	return this.visibleToClientId;
}

Packet_ServerEntityDrawArea.prototype.getX = function() {
	return this.x;
}

Packet_ServerEntityDrawArea.prototype.getY = function() {
	return this.y;
}

Packet_ServerEntityDrawArea.prototype.getZ = function() {
	return this.z;
}

Packet_ServerEntityDrawArea.prototype.setSizex = function(value) {
	this.sizex = value;
}

Packet_ServerEntityDrawArea.prototype.setSizey = function(value) {
	this.sizey = value;
}

Packet_ServerEntityDrawArea.prototype.setSizez = function(value) {
	this.sizez = value;
}

Packet_ServerEntityDrawArea.prototype.setVisibleToClientId = function(value) {
	this.visibleToClientId = value;
}

Packet_ServerEntityDrawArea.prototype.setX = function(value) {
	this.x = value;
}

Packet_ServerEntityDrawArea.prototype.setY = function(value) {
	this.y = value;
}

Packet_ServerEntityDrawArea.prototype.setZ = function(value) {
	this.z = value;
}

function Packet_ServerEntityDrawAreaSerializer()
{
}

Packet_ServerEntityDrawAreaSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.sizex = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.sizey = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.sizez = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.visibleToClientId = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawAreaSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerEntityDrawAreaSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerEntityDrawAreaSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.sizex = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.sizey = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.sizez = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.visibleToClientId = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawAreaSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.sizex = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.sizey = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.sizez = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.visibleToClientId = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawAreaSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerEntityDrawArea();
	Packet_ServerEntityDrawAreaSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerEntityDrawAreaSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.x);
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.y);
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.z);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.sizex);
	stream.writeByte(ProtoPlatform.intToByte(40));
	ProtocolParser.writeUInt64(stream, instance.sizey);
	stream.writeByte(ProtoPlatform.intToByte(48));
	ProtocolParser.writeUInt64(stream, instance.sizez);
	stream.writeByte(ProtoPlatform.intToByte(56));
	ProtocolParser.writeUInt64(stream, instance.visibleToClientId);
}

Packet_ServerEntityDrawAreaSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerEntityDrawAreaSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerEntityDrawAreaSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerEntityDrawAreaSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerEntityDrawBlock()
{
	this.blockType = 0;
}

Packet_ServerEntityDrawBlock.prototype.getBlockType = function() {
	return this.blockType;
}

Packet_ServerEntityDrawBlock.prototype.setBlockType = function(value) {
	this.blockType = value;
}

function Packet_ServerEntityDrawBlockSerializer()
{
}

Packet_ServerEntityDrawBlockSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.blockType = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawBlockSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerEntityDrawBlockSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerEntityDrawBlockSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.blockType = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawBlockSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.blockType = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawBlockSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerEntityDrawBlock();
	Packet_ServerEntityDrawBlockSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerEntityDrawBlockSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.blockType);
}

Packet_ServerEntityDrawBlockSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerEntityDrawBlockSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerEntityDrawBlockSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerEntityDrawBlockSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerEntityDrawName()
{
	this.clientAutoComplete = false;
	this.color = null;
	this.name = null;
	this.onlyWhenSelected = false;
}

Packet_ServerEntityDrawName.prototype.getClientAutoComplete = function() {
	return this.clientAutoComplete;
}

Packet_ServerEntityDrawName.prototype.getColor = function() {
	return this.color;
}

Packet_ServerEntityDrawName.prototype.getName = function() {
	return this.name;
}

Packet_ServerEntityDrawName.prototype.getOnlyWhenSelected = function() {
	return this.onlyWhenSelected;
}

Packet_ServerEntityDrawName.prototype.setClientAutoComplete = function(value) {
	this.clientAutoComplete = value;
}

Packet_ServerEntityDrawName.prototype.setColor = function(value) {
	this.color = value;
}

Packet_ServerEntityDrawName.prototype.setName = function(value) {
	this.name = value;
}

Packet_ServerEntityDrawName.prototype.setOnlyWhenSelected = function(value) {
	this.onlyWhenSelected = value;
}

function Packet_ServerEntityDrawNameSerializer()
{
}

Packet_ServerEntityDrawNameSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.name = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.onlyWhenSelected = ProtocolParser.readBool(stream);
			continue;
		case 24:
			instance.clientAutoComplete = ProtocolParser.readBool(stream);
			continue;
		case 34:
			instance.color = ProtocolParser.readString(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawNameSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerEntityDrawNameSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerEntityDrawNameSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.name = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.onlyWhenSelected = ProtocolParser.readBool(stream);
			continue;
		case 24:
			instance.clientAutoComplete = ProtocolParser.readBool(stream);
			continue;
		case 34:
			instance.color = ProtocolParser.readString(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawNameSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.name = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.onlyWhenSelected = ProtocolParser.readBool(stream);
			continue;
		case 24:
			instance.clientAutoComplete = ProtocolParser.readBool(stream);
			continue;
		case 34:
			instance.color = ProtocolParser.readString(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawNameSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerEntityDrawName();
	Packet_ServerEntityDrawNameSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerEntityDrawNameSerializer.serialize = function(stream, instance) {
	if (instance.name != null) {
		stream.writeByte(ProtoPlatform.intToByte(10));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.name));
	}
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeBool(stream, instance.onlyWhenSelected);
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeBool(stream, instance.clientAutoComplete);
	if (instance.color != null) {
		stream.writeByte(ProtoPlatform.intToByte(34));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.color));
	}
}

Packet_ServerEntityDrawNameSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerEntityDrawNameSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerEntityDrawNameSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerEntityDrawNameSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerEntityDrawText()
{
	this.dx = 0;
	this.dy = 0;
	this.dz = 0;
	this.rotx = 0;
	this.roty = 0;
	this.rotz = 0;
	this.text = null;
}

Packet_ServerEntityDrawText.prototype.getDx = function() {
	return this.dx;
}

Packet_ServerEntityDrawText.prototype.getDy = function() {
	return this.dy;
}

Packet_ServerEntityDrawText.prototype.getDz = function() {
	return this.dz;
}

Packet_ServerEntityDrawText.prototype.getRotx = function() {
	return this.rotx;
}

Packet_ServerEntityDrawText.prototype.getRoty = function() {
	return this.roty;
}

Packet_ServerEntityDrawText.prototype.getRotz = function() {
	return this.rotz;
}

Packet_ServerEntityDrawText.prototype.getText = function() {
	return this.text;
}

Packet_ServerEntityDrawText.prototype.setDx = function(value) {
	this.dx = value;
}

Packet_ServerEntityDrawText.prototype.setDy = function(value) {
	this.dy = value;
}

Packet_ServerEntityDrawText.prototype.setDz = function(value) {
	this.dz = value;
}

Packet_ServerEntityDrawText.prototype.setRotx = function(value) {
	this.rotx = value;
}

Packet_ServerEntityDrawText.prototype.setRoty = function(value) {
	this.roty = value;
}

Packet_ServerEntityDrawText.prototype.setRotz = function(value) {
	this.rotz = value;
}

Packet_ServerEntityDrawText.prototype.setText = function(value) {
	this.text = value;
}

function Packet_ServerEntityDrawTextSerializer()
{
}

Packet_ServerEntityDrawTextSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.text = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.dx = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.dy = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.dz = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.rotx = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.roty = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.rotz = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawTextSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerEntityDrawTextSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerEntityDrawTextSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.text = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.dx = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.dy = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.dz = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.rotx = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.roty = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.rotz = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawTextSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.text = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.dx = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.dy = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.dz = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.rotx = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.roty = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.rotz = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawTextSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerEntityDrawText();
	Packet_ServerEntityDrawTextSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerEntityDrawTextSerializer.serialize = function(stream, instance) {
	if (instance.text != null) {
		stream.writeByte(ProtoPlatform.intToByte(10));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.text));
	}
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.dx);
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.dy);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.dz);
	stream.writeByte(ProtoPlatform.intToByte(40));
	ProtocolParser.writeUInt64(stream, instance.rotx);
	stream.writeByte(ProtoPlatform.intToByte(48));
	ProtocolParser.writeUInt64(stream, instance.roty);
	stream.writeByte(ProtoPlatform.intToByte(56));
	ProtocolParser.writeUInt64(stream, instance.rotz);
}

Packet_ServerEntityDrawTextSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerEntityDrawTextSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerEntityDrawTextSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerEntityDrawTextSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerEntityPositionAndOrientation()
{
	this.id = 0;
	this.positionAndOrientation = null;
}

Packet_ServerEntityPositionAndOrientation.prototype.getId = function() {
	return this.id;
}

Packet_ServerEntityPositionAndOrientation.prototype.getPositionAndOrientation = function() {
	return this.positionAndOrientation;
}

Packet_ServerEntityPositionAndOrientation.prototype.setId = function(value) {
	this.id = value;
}

Packet_ServerEntityPositionAndOrientation.prototype.setPositionAndOrientation = function(value) {
	this.positionAndOrientation = value;
}

function Packet_ServerEntityPositionAndOrientationSerializer()
{
}

Packet_ServerEntityPositionAndOrientationSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.id = ProtocolParser.readUInt64(stream);
			continue;
		case 18:
			if (instance.positionAndOrientation == null)
				instance.positionAndOrientation = Packet_PositionAndOrientationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer.deserializeLengthDelimited(stream, instance.positionAndOrientation);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityPositionAndOrientationSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerEntityPositionAndOrientationSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerEntityPositionAndOrientationSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.id = ProtocolParser.readUInt64(stream);
			continue;
		case 18:
			if (instance.positionAndOrientation == null)
				instance.positionAndOrientation = Packet_PositionAndOrientationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer.deserializeLengthDelimited(stream, instance.positionAndOrientation);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityPositionAndOrientationSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.id = ProtocolParser.readUInt64(stream);
			continue;
		case 18:
			if (instance.positionAndOrientation == null)
				instance.positionAndOrientation = Packet_PositionAndOrientationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer.deserializeLengthDelimited(stream, instance.positionAndOrientation);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityPositionAndOrientationSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerEntityPositionAndOrientation();
	Packet_ServerEntityPositionAndOrientationSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerEntityPositionAndOrientationSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.id);
	if (instance.positionAndOrientation != null) {
		stream.writeByte(ProtoPlatform.intToByte(18));
		var ms2 = new CitoMemoryStream();
		Packet_PositionAndOrientationSerializer.serialize(ms2, instance.positionAndOrientation);
		var ms2Length = ms2.length();
		ProtocolParser.writeUInt32_(stream, ms2Length);
		stream.write(ms2.getBuffer(), 0, ms2Length);
	}
}

Packet_ServerEntityPositionAndOrientationSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerEntityPositionAndOrientationSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerEntityPositionAndOrientationSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerEntityPositionAndOrientationSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerEntityPush()
{
	this.rangeFloat = 0;
}

Packet_ServerEntityPush.prototype.getRangeFloat = function() {
	return this.rangeFloat;
}

Packet_ServerEntityPush.prototype.setRangeFloat = function(value) {
	this.rangeFloat = value;
}

function Packet_ServerEntityPushSerializer()
{
}

Packet_ServerEntityPushSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.rangeFloat = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityPushSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerEntityPushSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerEntityPushSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.rangeFloat = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityPushSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.rangeFloat = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityPushSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerEntityPush();
	Packet_ServerEntityPushSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerEntityPushSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.rangeFloat);
}

Packet_ServerEntityPushSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerEntityPushSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerEntityPushSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerEntityPushSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerEntitySerializer()
{
}

Packet_ServerEntitySerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			if (instance.position == null)
				instance.position = Packet_PositionAndOrientationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer.deserializeLengthDelimited(stream, instance.position);
			continue;
		case 18:
			if (instance.drawModel == null)
				instance.drawModel = Packet_ServerEntityAnimatedModelSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityAnimatedModelSerializer.deserializeLengthDelimited(stream, instance.drawModel);
			continue;
		case 26:
			if (instance.drawName_ == null)
				instance.drawName_ = Packet_ServerEntityDrawNameSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawNameSerializer.deserializeLengthDelimited(stream, instance.drawName_);
			continue;
		case 34:
			if (instance.drawText == null)
				instance.drawText = Packet_ServerEntityDrawTextSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawTextSerializer.deserializeLengthDelimited(stream, instance.drawText);
			continue;
		case 42:
			if (instance.drawBlock == null)
				instance.drawBlock = Packet_ServerEntityDrawBlockSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawBlockSerializer.deserializeLengthDelimited(stream, instance.drawBlock);
			continue;
		case 50:
			if (instance.push == null)
				instance.push = Packet_ServerEntityPushSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityPushSerializer.deserializeLengthDelimited(stream, instance.push);
			continue;
		case 56:
			instance.usable = ProtocolParser.readBool(stream);
			continue;
		case 66:
			if (instance.playerStats == null)
				instance.playerStats = Packet_ServerPlayerStatsSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerStatsSerializer.deserializeLengthDelimited(stream, instance.playerStats);
			continue;
		case 74:
			if (instance.drawArea == null)
				instance.drawArea = Packet_ServerEntityDrawAreaSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawAreaSerializer.deserializeLengthDelimited(stream, instance.drawArea);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntitySerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerEntitySerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerEntitySerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			if (instance.position == null)
				instance.position = Packet_PositionAndOrientationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer.deserializeLengthDelimited(stream, instance.position);
			continue;
		case 18:
			if (instance.drawModel == null)
				instance.drawModel = Packet_ServerEntityAnimatedModelSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityAnimatedModelSerializer.deserializeLengthDelimited(stream, instance.drawModel);
			continue;
		case 26:
			if (instance.drawName_ == null)
				instance.drawName_ = Packet_ServerEntityDrawNameSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawNameSerializer.deserializeLengthDelimited(stream, instance.drawName_);
			continue;
		case 34:
			if (instance.drawText == null)
				instance.drawText = Packet_ServerEntityDrawTextSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawTextSerializer.deserializeLengthDelimited(stream, instance.drawText);
			continue;
		case 42:
			if (instance.drawBlock == null)
				instance.drawBlock = Packet_ServerEntityDrawBlockSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawBlockSerializer.deserializeLengthDelimited(stream, instance.drawBlock);
			continue;
		case 50:
			if (instance.push == null)
				instance.push = Packet_ServerEntityPushSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityPushSerializer.deserializeLengthDelimited(stream, instance.push);
			continue;
		case 56:
			instance.usable = ProtocolParser.readBool(stream);
			continue;
		case 66:
			if (instance.playerStats == null)
				instance.playerStats = Packet_ServerPlayerStatsSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerStatsSerializer.deserializeLengthDelimited(stream, instance.playerStats);
			continue;
		case 74:
			if (instance.drawArea == null)
				instance.drawArea = Packet_ServerEntityDrawAreaSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawAreaSerializer.deserializeLengthDelimited(stream, instance.drawArea);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntitySerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			if (instance.position == null)
				instance.position = Packet_PositionAndOrientationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer.deserializeLengthDelimited(stream, instance.position);
			continue;
		case 18:
			if (instance.drawModel == null)
				instance.drawModel = Packet_ServerEntityAnimatedModelSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityAnimatedModelSerializer.deserializeLengthDelimited(stream, instance.drawModel);
			continue;
		case 26:
			if (instance.drawName_ == null)
				instance.drawName_ = Packet_ServerEntityDrawNameSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawNameSerializer.deserializeLengthDelimited(stream, instance.drawName_);
			continue;
		case 34:
			if (instance.drawText == null)
				instance.drawText = Packet_ServerEntityDrawTextSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawTextSerializer.deserializeLengthDelimited(stream, instance.drawText);
			continue;
		case 42:
			if (instance.drawBlock == null)
				instance.drawBlock = Packet_ServerEntityDrawBlockSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawBlockSerializer.deserializeLengthDelimited(stream, instance.drawBlock);
			continue;
		case 50:
			if (instance.push == null)
				instance.push = Packet_ServerEntityPushSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityPushSerializer.deserializeLengthDelimited(stream, instance.push);
			continue;
		case 56:
			instance.usable = ProtocolParser.readBool(stream);
			continue;
		case 66:
			if (instance.playerStats == null)
				instance.playerStats = Packet_ServerPlayerStatsSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerStatsSerializer.deserializeLengthDelimited(stream, instance.playerStats);
			continue;
		case 74:
			if (instance.drawArea == null)
				instance.drawArea = Packet_ServerEntityDrawAreaSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawAreaSerializer.deserializeLengthDelimited(stream, instance.drawArea);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntitySerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerEntity();
	Packet_ServerEntitySerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerEntitySerializer.serialize = function(stream, instance) {
	if (instance.position != null) {
		stream.writeByte(ProtoPlatform.intToByte(10));
		var ms1 = new CitoMemoryStream();
		Packet_PositionAndOrientationSerializer.serialize(ms1, instance.position);
		var ms1Length = ms1.length();
		ProtocolParser.writeUInt32_(stream, ms1Length);
		stream.write(ms1.getBuffer(), 0, ms1Length);
	}
	if (instance.drawModel != null) {
		stream.writeByte(ProtoPlatform.intToByte(18));
		var ms2 = new CitoMemoryStream();
		Packet_ServerEntityAnimatedModelSerializer.serialize(ms2, instance.drawModel);
		var ms2Length = ms2.length();
		ProtocolParser.writeUInt32_(stream, ms2Length);
		stream.write(ms2.getBuffer(), 0, ms2Length);
	}
	if (instance.drawName_ != null) {
		stream.writeByte(ProtoPlatform.intToByte(26));
		var ms3 = new CitoMemoryStream();
		Packet_ServerEntityDrawNameSerializer.serialize(ms3, instance.drawName_);
		var ms3Length = ms3.length();
		ProtocolParser.writeUInt32_(stream, ms3Length);
		stream.write(ms3.getBuffer(), 0, ms3Length);
	}
	if (instance.drawText != null) {
		stream.writeByte(ProtoPlatform.intToByte(34));
		var ms4 = new CitoMemoryStream();
		Packet_ServerEntityDrawTextSerializer.serialize(ms4, instance.drawText);
		var ms4Length = ms4.length();
		ProtocolParser.writeUInt32_(stream, ms4Length);
		stream.write(ms4.getBuffer(), 0, ms4Length);
	}
	if (instance.drawBlock != null) {
		stream.writeByte(ProtoPlatform.intToByte(42));
		var ms5 = new CitoMemoryStream();
		Packet_ServerEntityDrawBlockSerializer.serialize(ms5, instance.drawBlock);
		var ms5Length = ms5.length();
		ProtocolParser.writeUInt32_(stream, ms5Length);
		stream.write(ms5.getBuffer(), 0, ms5Length);
	}
	if (instance.push != null) {
		stream.writeByte(ProtoPlatform.intToByte(50));
		var ms6 = new CitoMemoryStream();
		Packet_ServerEntityPushSerializer.serialize(ms6, instance.push);
		var ms6Length = ms6.length();
		ProtocolParser.writeUInt32_(stream, ms6Length);
		stream.write(ms6.getBuffer(), 0, ms6Length);
	}
	stream.writeByte(ProtoPlatform.intToByte(56));
	ProtocolParser.writeBool(stream, instance.usable);
	if (instance.playerStats != null) {
		stream.writeByte(ProtoPlatform.intToByte(66));
		var ms8 = new CitoMemoryStream();
		Packet_ServerPlayerStatsSerializer.serialize(ms8, instance.playerStats);
		var ms8Length = ms8.length();
		ProtocolParser.writeUInt32_(stream, ms8Length);
		stream.write(ms8.getBuffer(), 0, ms8Length);
	}
	if (instance.drawArea != null) {
		stream.writeByte(ProtoPlatform.intToByte(74));
		var ms9 = new CitoMemoryStream();
		Packet_ServerEntityDrawAreaSerializer.serialize(ms9, instance.drawArea);
		var ms9Length = ms9.length();
		ProtocolParser.writeUInt32_(stream, ms9Length);
		stream.write(ms9.getBuffer(), 0, ms9Length);
	}
}

Packet_ServerEntitySerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerEntitySerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerEntitySerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerEntitySerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerEntitySpawn()
{
	this.entity_ = null;
	this.id = 0;
}

Packet_ServerEntitySpawn.prototype.getEntity_ = function() {
	return this.entity_;
}

Packet_ServerEntitySpawn.prototype.getId = function() {
	return this.id;
}

Packet_ServerEntitySpawn.prototype.setEntity_ = function(value) {
	this.entity_ = value;
}

Packet_ServerEntitySpawn.prototype.setId = function(value) {
	this.id = value;
}

function Packet_ServerEntitySpawnSerializer()
{
}

Packet_ServerEntitySpawnSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.id = ProtocolParser.readUInt64(stream);
			continue;
		case 18:
			if (instance.entity_ == null)
				instance.entity_ = Packet_ServerEntitySerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntitySerializer.deserializeLengthDelimited(stream, instance.entity_);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntitySpawnSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerEntitySpawnSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerEntitySpawnSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.id = ProtocolParser.readUInt64(stream);
			continue;
		case 18:
			if (instance.entity_ == null)
				instance.entity_ = Packet_ServerEntitySerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntitySerializer.deserializeLengthDelimited(stream, instance.entity_);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntitySpawnSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.id = ProtocolParser.readUInt64(stream);
			continue;
		case 18:
			if (instance.entity_ == null)
				instance.entity_ = Packet_ServerEntitySerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntitySerializer.deserializeLengthDelimited(stream, instance.entity_);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntitySpawnSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerEntitySpawn();
	Packet_ServerEntitySpawnSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerEntitySpawnSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.id);
	if (instance.entity_ != null) {
		stream.writeByte(ProtoPlatform.intToByte(18));
		var ms2 = new CitoMemoryStream();
		Packet_ServerEntitySerializer.serialize(ms2, instance.entity_);
		var ms2Length = ms2.length();
		ProtocolParser.writeUInt32_(stream, ms2Length);
		stream.write(ms2.getBuffer(), 0, ms2Length);
	}
}

Packet_ServerEntitySpawnSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerEntitySpawnSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerEntitySpawnSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerEntitySpawnSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerExplosion()
{
	this.isRelativeToPlayerPosition = 0;
	this.rangeFloat = 0;
	this.timeFloat = 0;
	this.xFloat = 0;
	this.yFloat = 0;
	this.zFloat = 0;
}

Packet_ServerExplosion.prototype.getIsRelativeToPlayerPosition = function() {
	return this.isRelativeToPlayerPosition;
}

Packet_ServerExplosion.prototype.getRangeFloat = function() {
	return this.rangeFloat;
}

Packet_ServerExplosion.prototype.getTimeFloat = function() {
	return this.timeFloat;
}

Packet_ServerExplosion.prototype.getXFloat = function() {
	return this.xFloat;
}

Packet_ServerExplosion.prototype.getYFloat = function() {
	return this.yFloat;
}

Packet_ServerExplosion.prototype.getZFloat = function() {
	return this.zFloat;
}

Packet_ServerExplosion.prototype.setIsRelativeToPlayerPosition = function(value) {
	this.isRelativeToPlayerPosition = value;
}

Packet_ServerExplosion.prototype.setRangeFloat = function(value) {
	this.rangeFloat = value;
}

Packet_ServerExplosion.prototype.setTimeFloat = function(value) {
	this.timeFloat = value;
}

Packet_ServerExplosion.prototype.setXFloat = function(value) {
	this.xFloat = value;
}

Packet_ServerExplosion.prototype.setYFloat = function(value) {
	this.yFloat = value;
}

Packet_ServerExplosion.prototype.setZFloat = function(value) {
	this.zFloat = value;
}

function Packet_ServerExplosionSerializer()
{
}

Packet_ServerExplosionSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.xFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.yFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.zFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.isRelativeToPlayerPosition = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.rangeFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.timeFloat = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerExplosionSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerExplosionSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerExplosionSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.xFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.yFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.zFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.isRelativeToPlayerPosition = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.rangeFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.timeFloat = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerExplosionSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.xFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.yFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.zFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.isRelativeToPlayerPosition = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.rangeFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.timeFloat = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerExplosionSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerExplosion();
	Packet_ServerExplosionSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerExplosionSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.xFloat);
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.yFloat);
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.zFloat);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.isRelativeToPlayerPosition);
	stream.writeByte(ProtoPlatform.intToByte(40));
	ProtocolParser.writeUInt64(stream, instance.rangeFloat);
	stream.writeByte(ProtoPlatform.intToByte(48));
	ProtocolParser.writeUInt64(stream, instance.timeFloat);
}

Packet_ServerExplosionSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerExplosionSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerExplosionSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerExplosionSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerFillArea()
{
	this.blockCount = 0;
	this.blockType = 0;
	this.x1 = 0;
	this.x2 = 0;
	this.y1 = 0;
	this.y2 = 0;
	this.z1 = 0;
	this.z2 = 0;
}

Packet_ServerFillArea.prototype.getBlockCount = function() {
	return this.blockCount;
}

Packet_ServerFillArea.prototype.getBlockType = function() {
	return this.blockType;
}

Packet_ServerFillArea.prototype.getX1 = function() {
	return this.x1;
}

Packet_ServerFillArea.prototype.getX2 = function() {
	return this.x2;
}

Packet_ServerFillArea.prototype.getY1 = function() {
	return this.y1;
}

Packet_ServerFillArea.prototype.getY2 = function() {
	return this.y2;
}

Packet_ServerFillArea.prototype.getZ1 = function() {
	return this.z1;
}

Packet_ServerFillArea.prototype.getZ2 = function() {
	return this.z2;
}

Packet_ServerFillArea.prototype.setBlockCount = function(value) {
	this.blockCount = value;
}

Packet_ServerFillArea.prototype.setBlockType = function(value) {
	this.blockType = value;
}

Packet_ServerFillArea.prototype.setX1 = function(value) {
	this.x1 = value;
}

Packet_ServerFillArea.prototype.setX2 = function(value) {
	this.x2 = value;
}

Packet_ServerFillArea.prototype.setY1 = function(value) {
	this.y1 = value;
}

Packet_ServerFillArea.prototype.setY2 = function(value) {
	this.y2 = value;
}

Packet_ServerFillArea.prototype.setZ1 = function(value) {
	this.z1 = value;
}

Packet_ServerFillArea.prototype.setZ2 = function(value) {
	this.z2 = value;
}

function Packet_ServerFillAreaLimit()
{
	this.limit = 0;
}

Packet_ServerFillAreaLimit.prototype.getLimit = function() {
	return this.limit;
}

Packet_ServerFillAreaLimit.prototype.setLimit = function(value) {
	this.limit = value;
}

function Packet_ServerFillAreaLimitSerializer()
{
}

Packet_ServerFillAreaLimitSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.limit = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFillAreaLimitSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerFillAreaLimitSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerFillAreaLimitSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.limit = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFillAreaLimitSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.limit = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFillAreaLimitSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerFillAreaLimit();
	Packet_ServerFillAreaLimitSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerFillAreaLimitSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.limit);
}

Packet_ServerFillAreaLimitSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerFillAreaLimitSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerFillAreaLimitSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerFillAreaLimitSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerFillAreaSerializer()
{
}

Packet_ServerFillAreaSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.x1 = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.x2 = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.y1 = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.y2 = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.z1 = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.z2 = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.blockType = ProtocolParser.readUInt64(stream);
			continue;
		case 64:
			instance.blockCount = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFillAreaSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerFillAreaSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerFillAreaSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.x1 = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.x2 = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.y1 = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.y2 = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.z1 = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.z2 = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.blockType = ProtocolParser.readUInt64(stream);
			continue;
		case 64:
			instance.blockCount = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFillAreaSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.x1 = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.x2 = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.y1 = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.y2 = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.z1 = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.z2 = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.blockType = ProtocolParser.readUInt64(stream);
			continue;
		case 64:
			instance.blockCount = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFillAreaSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerFillArea();
	Packet_ServerFillAreaSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerFillAreaSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.x1);
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.x2);
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.y1);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.y2);
	stream.writeByte(ProtoPlatform.intToByte(40));
	ProtocolParser.writeUInt64(stream, instance.z1);
	stream.writeByte(ProtoPlatform.intToByte(48));
	ProtocolParser.writeUInt64(stream, instance.z2);
	stream.writeByte(ProtoPlatform.intToByte(56));
	ProtocolParser.writeUInt64(stream, instance.blockType);
	stream.writeByte(ProtoPlatform.intToByte(64));
	ProtocolParser.writeUInt64(stream, instance.blockCount);
}

Packet_ServerFillAreaSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerFillAreaSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerFillAreaSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerFillAreaSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerFollow()
{
	this.client = null;
	this.tpp = 0;
}

Packet_ServerFollow.prototype.getClient = function() {
	return this.client;
}

Packet_ServerFollow.prototype.getTpp = function() {
	return this.tpp;
}

Packet_ServerFollow.prototype.setClient = function(value) {
	this.client = value;
}

Packet_ServerFollow.prototype.setTpp = function(value) {
	this.tpp = value;
}

function Packet_ServerFollowSerializer()
{
}

Packet_ServerFollowSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.client = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.tpp = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFollowSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerFollowSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerFollowSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.client = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.tpp = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFollowSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.client = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.tpp = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFollowSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerFollow();
	Packet_ServerFollowSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerFollowSerializer.serialize = function(stream, instance) {
	if (instance.client != null) {
		stream.writeByte(ProtoPlatform.intToByte(10));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.client));
	}
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.tpp);
}

Packet_ServerFollowSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerFollowSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerFollowSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerFollowSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerFreemove()
{
	this.isEnabled = 0;
}

Packet_ServerFreemove.prototype.getIsEnabled = function() {
	return this.isEnabled;
}

Packet_ServerFreemove.prototype.setIsEnabled = function(value) {
	this.isEnabled = value;
}

function Packet_ServerFreemoveSerializer()
{
}

Packet_ServerFreemoveSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.isEnabled = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFreemoveSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerFreemoveSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerFreemoveSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.isEnabled = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFreemoveSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.isEnabled = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFreemoveSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerFreemove();
	Packet_ServerFreemoveSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerFreemoveSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.isEnabled);
}

Packet_ServerFreemoveSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerFreemoveSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerFreemoveSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerFreemoveSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerHeightmapChunk()
{
	this.compressedHeightmap = null;
	this.sizeX = 0;
	this.sizeY = 0;
	this.x = 0;
	this.y = 0;
}

Packet_ServerHeightmapChunk.prototype.getCompressedHeightmap = function() {
	return this.compressedHeightmap;
}

Packet_ServerHeightmapChunk.prototype.getSizeX = function() {
	return this.sizeX;
}

Packet_ServerHeightmapChunk.prototype.getSizeY = function() {
	return this.sizeY;
}

Packet_ServerHeightmapChunk.prototype.getX = function() {
	return this.x;
}

Packet_ServerHeightmapChunk.prototype.getY = function() {
	return this.y;
}

Packet_ServerHeightmapChunk.prototype.setCompressedHeightmap = function(value) {
	this.compressedHeightmap = value;
}

Packet_ServerHeightmapChunk.prototype.setSizeX = function(value) {
	this.sizeX = value;
}

Packet_ServerHeightmapChunk.prototype.setSizeY = function(value) {
	this.sizeY = value;
}

Packet_ServerHeightmapChunk.prototype.setX = function(value) {
	this.x = value;
}

Packet_ServerHeightmapChunk.prototype.setY = function(value) {
	this.y = value;
}

function Packet_ServerHeightmapChunkSerializer()
{
}

Packet_ServerHeightmapChunkSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.sizeX = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.sizeY = ProtocolParser.readUInt64(stream);
			continue;
		case 42:
			instance.compressedHeightmap = ProtocolParser.readBytes(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerHeightmapChunkSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerHeightmapChunkSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerHeightmapChunkSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.sizeX = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.sizeY = ProtocolParser.readUInt64(stream);
			continue;
		case 42:
			instance.compressedHeightmap = ProtocolParser.readBytes(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerHeightmapChunkSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.sizeX = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.sizeY = ProtocolParser.readUInt64(stream);
			continue;
		case 42:
			instance.compressedHeightmap = ProtocolParser.readBytes(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerHeightmapChunkSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerHeightmapChunk();
	Packet_ServerHeightmapChunkSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerHeightmapChunkSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.x);
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.y);
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.sizeX);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.sizeY);
	if (instance.compressedHeightmap != null) {
		stream.writeByte(ProtoPlatform.intToByte(42));
		ProtocolParser.writeBytes(stream, instance.compressedHeightmap);
	}
}

Packet_ServerHeightmapChunkSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerHeightmapChunkSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerHeightmapChunkSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerHeightmapChunkSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerIdEnum()
{
}
Packet_ServerIdEnum.ACTIVE_MONSTERS = 25;
Packet_ServerIdEnum.AMMO = 55;
Packet_ServerIdEnum.BLOB_FINALIZE = 20;
Packet_ServerIdEnum.BLOB_INITIALIZE = 18;
Packet_ServerIdEnum.BLOB_PART = 19;
Packet_ServerIdEnum.BLOCK_TYPE = 56;
Packet_ServerIdEnum.BLOCK_TYPES = 27;
Packet_ServerIdEnum.BULLET = 54;
Packet_ServerIdEnum.CHUNK_PART = 57;
Packet_ServerIdEnum.CHUNK_ = 15;
Packet_ServerIdEnum.CRAFTING_RECIPES = 30;
Packet_ServerIdEnum.DIALOG = 52;
Packet_ServerIdEnum.DISCONNECT_PLAYER = 14;
Packet_ServerIdEnum.ENTITY_DESPAWN = 68;
Packet_ServerIdEnum.ENTITY_POSITION = 67;
Packet_ServerIdEnum.ENTITY_SPAWN = 66;
Packet_ServerIdEnum.EXPLOSION = 58;
Packet_ServerIdEnum.EXTENDED_PACKET_COMMAND = 100;
Packet_ServerIdEnum.EXTENDED_PACKET_TICK = 101;
Packet_ServerIdEnum.FILL_AREA = 61;
Packet_ServerIdEnum.FILL_AREA_LIMIT = 62;
Packet_ServerIdEnum.FINITE_INVENTORY = 16;
Packet_ServerIdEnum.FOLLOW = 53;
Packet_ServerIdEnum.FREEMOVE = 51;
Packet_ServerIdEnum.HEIGHTMAP_CHUNK = 21;
Packet_ServerIdEnum.LEVEL_DATA_CHUNK = 3;
Packet_ServerIdEnum.LEVEL_FINALIZE = 4;
Packet_ServerIdEnum.LEVEL_INITIALIZE = 2;
Packet_ServerIdEnum.LIGHT_LEVELS = 29;
Packet_ServerIdEnum.MESSAGE = 13;
Packet_ServerIdEnum.MONSTER = 24;
Packet_ServerIdEnum.PING = 1;
Packet_ServerIdEnum.PLAYER_PING = 111;
Packet_ServerIdEnum.PLAYER_SPAWN_POSITION = 26;
Packet_ServerIdEnum.PLAYER_STATS = 23;
Packet_ServerIdEnum.PROJECTILE = 59;
Packet_ServerIdEnum.QUERY_ANSWER = 64;
Packet_ServerIdEnum.REMOVE_MONSTERS = 50;
Packet_ServerIdEnum.SEASON = 17;
Packet_ServerIdEnum.SERVER_IDENTIFICATION = 0;
Packet_ServerIdEnum.SERVER_REDIRECT = 65;
Packet_ServerIdEnum.SET_BLOCK = 6;
Packet_ServerIdEnum.SOUND = 22;
Packet_ServerIdEnum.SUN_LEVELS = 28;
Packet_ServerIdEnum.TRANSLATION = 60;

function Packet_ServerIdentification()
{
	this.assignedClientId = 0;
	this.disableShadows = 0;
	this.mapSizeX = 0;
	this.mapSizeY = 0;
	this.mapSizeZ = 0;
	this.mdProtocolVersion = null;
	this.playerAreaSize = 0;
	this.renderHint_ = 0;
	this.requiredBlobMd5 = null;
	this.requiredBlobName = null;
	this.serverMotd = null;
	this.serverName = null;
}

Packet_ServerIdentification.prototype.getAssignedClientId = function() {
	return this.assignedClientId;
}

Packet_ServerIdentification.prototype.getDisableShadows = function() {
	return this.disableShadows;
}

Packet_ServerIdentification.prototype.getMapSizeX = function() {
	return this.mapSizeX;
}

Packet_ServerIdentification.prototype.getMapSizeY = function() {
	return this.mapSizeY;
}

Packet_ServerIdentification.prototype.getMapSizeZ = function() {
	return this.mapSizeZ;
}

Packet_ServerIdentification.prototype.getMdProtocolVersion = function() {
	return this.mdProtocolVersion;
}

Packet_ServerIdentification.prototype.getPlayerAreaSize = function() {
	return this.playerAreaSize;
}

Packet_ServerIdentification.prototype.getRenderHint_ = function() {
	return this.renderHint_;
}

Packet_ServerIdentification.prototype.getRequiredBlobMd5 = function() {
	return this.requiredBlobMd5;
}

Packet_ServerIdentification.prototype.getRequiredBlobName = function() {
	return this.requiredBlobName;
}

Packet_ServerIdentification.prototype.getServerMotd = function() {
	return this.serverMotd;
}

Packet_ServerIdentification.prototype.getServerName = function() {
	return this.serverName;
}

Packet_ServerIdentification.prototype.setAssignedClientId = function(value) {
	this.assignedClientId = value;
}

Packet_ServerIdentification.prototype.setDisableShadows = function(value) {
	this.disableShadows = value;
}

Packet_ServerIdentification.prototype.setMapSizeX = function(value) {
	this.mapSizeX = value;
}

Packet_ServerIdentification.prototype.setMapSizeY = function(value) {
	this.mapSizeY = value;
}

Packet_ServerIdentification.prototype.setMapSizeZ = function(value) {
	this.mapSizeZ = value;
}

Packet_ServerIdentification.prototype.setMdProtocolVersion = function(value) {
	this.mdProtocolVersion = value;
}

Packet_ServerIdentification.prototype.setPlayerAreaSize = function(value) {
	this.playerAreaSize = value;
}

Packet_ServerIdentification.prototype.setRenderHint_ = function(value) {
	this.renderHint_ = value;
}

Packet_ServerIdentification.prototype.setRequiredBlobMd5 = function(value) {
	this.requiredBlobMd5 = value;
}

Packet_ServerIdentification.prototype.setRequiredBlobName = function(value) {
	this.requiredBlobName = value;
}

Packet_ServerIdentification.prototype.setServerMotd = function(value) {
	this.serverMotd = value;
}

Packet_ServerIdentification.prototype.setServerName = function(value) {
	this.serverName = value;
}

function Packet_ServerIdentificationSerializer()
{
}

Packet_ServerIdentificationSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.mdProtocolVersion = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.assignedClientId = ProtocolParser.readUInt64(stream);
			continue;
		case 26:
			instance.serverName = ProtocolParser.readString(stream);
			continue;
		case 34:
			instance.serverMotd = ProtocolParser.readString(stream);
			continue;
		case 56:
			instance.mapSizeX = ProtocolParser.readUInt64(stream);
			continue;
		case 64:
			instance.mapSizeY = ProtocolParser.readUInt64(stream);
			continue;
		case 72:
			instance.mapSizeZ = ProtocolParser.readUInt64(stream);
			continue;
		case 88:
			instance.disableShadows = ProtocolParser.readUInt64(stream);
			continue;
		case 96:
			instance.playerAreaSize = ProtocolParser.readUInt64(stream);
			continue;
		case 104:
			instance.renderHint_ = ProtocolParser.readUInt64(stream);
			continue;
		case 114:
			if (instance.requiredBlobMd5 == null)
				instance.requiredBlobMd5 = Packet_StringListSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_StringListSerializer.deserializeLengthDelimited(stream, instance.requiredBlobMd5);
			continue;
		case 122:
			if (instance.requiredBlobName == null)
				instance.requiredBlobName = Packet_StringListSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_StringListSerializer.deserializeLengthDelimited(stream, instance.requiredBlobName);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerIdentificationSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerIdentificationSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerIdentificationSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.mdProtocolVersion = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.assignedClientId = ProtocolParser.readUInt64(stream);
			continue;
		case 26:
			instance.serverName = ProtocolParser.readString(stream);
			continue;
		case 34:
			instance.serverMotd = ProtocolParser.readString(stream);
			continue;
		case 56:
			instance.mapSizeX = ProtocolParser.readUInt64(stream);
			continue;
		case 64:
			instance.mapSizeY = ProtocolParser.readUInt64(stream);
			continue;
		case 72:
			instance.mapSizeZ = ProtocolParser.readUInt64(stream);
			continue;
		case 88:
			instance.disableShadows = ProtocolParser.readUInt64(stream);
			continue;
		case 96:
			instance.playerAreaSize = ProtocolParser.readUInt64(stream);
			continue;
		case 104:
			instance.renderHint_ = ProtocolParser.readUInt64(stream);
			continue;
		case 114:
			if (instance.requiredBlobMd5 == null)
				instance.requiredBlobMd5 = Packet_StringListSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_StringListSerializer.deserializeLengthDelimited(stream, instance.requiredBlobMd5);
			continue;
		case 122:
			if (instance.requiredBlobName == null)
				instance.requiredBlobName = Packet_StringListSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_StringListSerializer.deserializeLengthDelimited(stream, instance.requiredBlobName);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerIdentificationSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.mdProtocolVersion = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.assignedClientId = ProtocolParser.readUInt64(stream);
			continue;
		case 26:
			instance.serverName = ProtocolParser.readString(stream);
			continue;
		case 34:
			instance.serverMotd = ProtocolParser.readString(stream);
			continue;
		case 56:
			instance.mapSizeX = ProtocolParser.readUInt64(stream);
			continue;
		case 64:
			instance.mapSizeY = ProtocolParser.readUInt64(stream);
			continue;
		case 72:
			instance.mapSizeZ = ProtocolParser.readUInt64(stream);
			continue;
		case 88:
			instance.disableShadows = ProtocolParser.readUInt64(stream);
			continue;
		case 96:
			instance.playerAreaSize = ProtocolParser.readUInt64(stream);
			continue;
		case 104:
			instance.renderHint_ = ProtocolParser.readUInt64(stream);
			continue;
		case 114:
			if (instance.requiredBlobMd5 == null)
				instance.requiredBlobMd5 = Packet_StringListSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_StringListSerializer.deserializeLengthDelimited(stream, instance.requiredBlobMd5);
			continue;
		case 122:
			if (instance.requiredBlobName == null)
				instance.requiredBlobName = Packet_StringListSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_StringListSerializer.deserializeLengthDelimited(stream, instance.requiredBlobName);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerIdentificationSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerIdentification();
	Packet_ServerIdentificationSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerIdentificationSerializer.serialize = function(stream, instance) {
	if (instance.mdProtocolVersion != null) {
		stream.writeByte(ProtoPlatform.intToByte(10));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.mdProtocolVersion));
	}
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.assignedClientId);
	if (instance.serverName != null) {
		stream.writeByte(ProtoPlatform.intToByte(26));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.serverName));
	}
	if (instance.serverMotd != null) {
		stream.writeByte(ProtoPlatform.intToByte(34));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.serverMotd));
	}
	stream.writeByte(ProtoPlatform.intToByte(56));
	ProtocolParser.writeUInt64(stream, instance.mapSizeX);
	stream.writeByte(ProtoPlatform.intToByte(64));
	ProtocolParser.writeUInt64(stream, instance.mapSizeY);
	stream.writeByte(ProtoPlatform.intToByte(72));
	ProtocolParser.writeUInt64(stream, instance.mapSizeZ);
	stream.writeByte(ProtoPlatform.intToByte(88));
	ProtocolParser.writeUInt64(stream, instance.disableShadows);
	stream.writeByte(ProtoPlatform.intToByte(96));
	ProtocolParser.writeUInt64(stream, instance.playerAreaSize);
	stream.writeByte(ProtoPlatform.intToByte(104));
	ProtocolParser.writeUInt64(stream, instance.renderHint_);
	if (instance.requiredBlobMd5 != null) {
		stream.writeByte(ProtoPlatform.intToByte(114));
		var ms14 = new CitoMemoryStream();
		Packet_StringListSerializer.serialize(ms14, instance.requiredBlobMd5);
		var ms14Length = ms14.length();
		ProtocolParser.writeUInt32_(stream, ms14Length);
		stream.write(ms14.getBuffer(), 0, ms14Length);
	}
	if (instance.requiredBlobName != null) {
		stream.writeByte(ProtoPlatform.intToByte(122));
		var ms15 = new CitoMemoryStream();
		Packet_StringListSerializer.serialize(ms15, instance.requiredBlobName);
		var ms15Length = ms15.length();
		ProtocolParser.writeUInt32_(stream, ms15Length);
		stream.write(ms15.getBuffer(), 0, ms15Length);
	}
}

Packet_ServerIdentificationSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerIdentificationSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerIdentificationSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerIdentificationSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerInventory()
{
	this.inventory = null;
}

Packet_ServerInventory.prototype.getInventory = function() {
	return this.inventory;
}

Packet_ServerInventory.prototype.setInventory = function(value) {
	this.inventory = value;
}

function Packet_ServerInventorySerializer()
{
}

Packet_ServerInventorySerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 34:
			if (instance.inventory == null)
				instance.inventory = Packet_InventorySerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_InventorySerializer.deserializeLengthDelimited(stream, instance.inventory);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerInventorySerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerInventorySerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerInventorySerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 34:
			if (instance.inventory == null)
				instance.inventory = Packet_InventorySerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_InventorySerializer.deserializeLengthDelimited(stream, instance.inventory);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerInventorySerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 34:
			if (instance.inventory == null)
				instance.inventory = Packet_InventorySerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_InventorySerializer.deserializeLengthDelimited(stream, instance.inventory);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerInventorySerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerInventory();
	Packet_ServerInventorySerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerInventorySerializer.serialize = function(stream, instance) {
	if (instance.inventory != null) {
		stream.writeByte(ProtoPlatform.intToByte(34));
		var ms4 = new CitoMemoryStream();
		Packet_InventorySerializer.serialize(ms4, instance.inventory);
		var ms4Length = ms4.length();
		ProtocolParser.writeUInt32_(stream, ms4Length);
		stream.write(ms4.getBuffer(), 0, ms4Length);
	}
}

Packet_ServerInventorySerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerInventorySerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerInventorySerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerInventorySerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerLevelFinalize()
{
}

function Packet_ServerLevelFinalizeSerializer()
{
}

Packet_ServerLevelFinalizeSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLevelFinalizeSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerLevelFinalizeSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerLevelFinalizeSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLevelFinalizeSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLevelFinalizeSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerLevelFinalize();
	Packet_ServerLevelFinalizeSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerLevelFinalizeSerializer.serialize = function(stream, instance) {
}

Packet_ServerLevelFinalizeSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerLevelFinalizeSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerLevelFinalizeSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerLevelFinalizeSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerLevelInitialize()
{
}

function Packet_ServerLevelInitializeSerializer()
{
}

Packet_ServerLevelInitializeSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLevelInitializeSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerLevelInitializeSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerLevelInitializeSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLevelInitializeSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLevelInitializeSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerLevelInitialize();
	Packet_ServerLevelInitializeSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerLevelInitializeSerializer.serialize = function(stream, instance) {
}

Packet_ServerLevelInitializeSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerLevelInitializeSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerLevelInitializeSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerLevelInitializeSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerLevelProgress()
{
	this.percentComplete = 0;
	this.percentCompleteSubitem = 0;
	this.status = null;
}

Packet_ServerLevelProgress.prototype.getPercentComplete = function() {
	return this.percentComplete;
}

Packet_ServerLevelProgress.prototype.getPercentCompleteSubitem = function() {
	return this.percentCompleteSubitem;
}

Packet_ServerLevelProgress.prototype.getStatus = function() {
	return this.status;
}

Packet_ServerLevelProgress.prototype.setPercentComplete = function(value) {
	this.percentComplete = value;
}

Packet_ServerLevelProgress.prototype.setPercentCompleteSubitem = function(value) {
	this.percentCompleteSubitem = value;
}

Packet_ServerLevelProgress.prototype.setStatus = function(value) {
	this.status = value;
}

function Packet_ServerLevelProgressSerializer()
{
}

Packet_ServerLevelProgressSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 16:
			instance.percentComplete = ProtocolParser.readUInt64(stream);
			continue;
		case 26:
			instance.status = ProtocolParser.readString(stream);
			continue;
		case 32:
			instance.percentCompleteSubitem = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLevelProgressSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerLevelProgressSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerLevelProgressSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 16:
			instance.percentComplete = ProtocolParser.readUInt64(stream);
			continue;
		case 26:
			instance.status = ProtocolParser.readString(stream);
			continue;
		case 32:
			instance.percentCompleteSubitem = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLevelProgressSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 16:
			instance.percentComplete = ProtocolParser.readUInt64(stream);
			continue;
		case 26:
			instance.status = ProtocolParser.readString(stream);
			continue;
		case 32:
			instance.percentCompleteSubitem = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLevelProgressSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerLevelProgress();
	Packet_ServerLevelProgressSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerLevelProgressSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.percentComplete);
	if (instance.status != null) {
		stream.writeByte(ProtoPlatform.intToByte(26));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.status));
	}
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.percentCompleteSubitem);
}

Packet_ServerLevelProgressSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerLevelProgressSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerLevelProgressSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerLevelProgressSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerLightLevels()
{
	this.lightlevels = null;
	this.lightlevelsCount = 0;
	this.lightlevelsLength = 0;
}

Packet_ServerLightLevels.prototype.getLightlevels = function() {
	return this.lightlevels;
}

Packet_ServerLightLevels.prototype.getLightlevelsCount = function() {
	return this.lightlevelsCount;
}

Packet_ServerLightLevels.prototype.getLightlevelsLength = function() {
	return this.lightlevelsLength;
}

Packet_ServerLightLevels.prototype.lightlevelsAdd = function(value) {
	if (this.lightlevelsCount >= this.lightlevelsLength) {
		var Lightlevels2 = new Int32Array(new ArrayBuffer(this.lightlevelsLength * 2 << 2));
		this.lightlevelsLength = this.lightlevelsLength * 2;
		for (var i = 0; i < this.lightlevelsCount; i++) {
			Lightlevels2[i] = this.lightlevels[i];
		}
		this.lightlevels = Lightlevels2;
	}
	this.lightlevels[this.lightlevelsCount] = value;
	this.lightlevelsCount++;
}

Packet_ServerLightLevels.prototype.setLightlevels = function(value, count, length) {
	this.lightlevels = value;
	this.lightlevelsCount = count;
	this.lightlevelsLength = length;
}

function Packet_ServerLightLevelsSerializer()
{
}

Packet_ServerLightLevelsSerializer.deserialize = function(stream, instance) {
	if (instance.lightlevels == null) {
		instance.lightlevels = new Int32Array(new ArrayBuffer(1 << 2));
		instance.lightlevelsCount = 0;
		instance.lightlevelsLength = 1;
	}
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.lightlevelsAdd(ProtocolParser.readUInt64(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLightLevelsSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerLightLevelsSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerLightLevelsSerializer.deserializeLength = function(stream, length, instance) {
	if (instance.lightlevels == null) {
		instance.lightlevels = new Int32Array(new ArrayBuffer(1 << 2));
		instance.lightlevelsCount = 0;
		instance.lightlevelsLength = 1;
	}
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.lightlevelsAdd(ProtocolParser.readUInt64(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLightLevelsSerializer.deserializeLengthDelimited = function(stream, instance) {
	if (instance.lightlevels == null) {
		instance.lightlevels = new Int32Array(new ArrayBuffer(1 << 2));
		instance.lightlevelsCount = 0;
		instance.lightlevelsLength = 1;
	}
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.lightlevelsAdd(ProtocolParser.readUInt64(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLightLevelsSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerLightLevels();
	Packet_ServerLightLevelsSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerLightLevelsSerializer.serialize = function(stream, instance) {
	if (instance.lightlevels != null) {
		for (var k = 0; k < instance.lightlevelsCount; k++) {
			var i1 = instance.lightlevels[k];
			stream.writeByte(ProtoPlatform.intToByte(8));
			ProtocolParser.writeUInt64(stream, i1);
		}
	}
}

Packet_ServerLightLevelsSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerLightLevelsSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerLightLevelsSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerLightLevelsSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerMessage()
{
	this.message = null;
}

Packet_ServerMessage.prototype.getMessage = function() {
	return this.message;
}

Packet_ServerMessage.prototype.setMessage = function(value) {
	this.message = value;
}

function Packet_ServerMessageSerializer()
{
}

Packet_ServerMessageSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 18:
			instance.message = ProtocolParser.readString(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerMessageSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerMessageSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerMessageSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 18:
			instance.message = ProtocolParser.readString(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerMessageSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 18:
			instance.message = ProtocolParser.readString(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerMessageSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerMessage();
	Packet_ServerMessageSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerMessageSerializer.serialize = function(stream, instance) {
	if (instance.message != null) {
		stream.writeByte(ProtoPlatform.intToByte(18));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.message));
	}
}

Packet_ServerMessageSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerMessageSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerMessageSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerMessageSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerMonster()
{
	this.health = 0;
	this.id = 0;
	this.monsterType = 0;
	this.positionAndOrientation = null;
}

Packet_ServerMonster.prototype.getHealth = function() {
	return this.health;
}

Packet_ServerMonster.prototype.getId = function() {
	return this.id;
}

Packet_ServerMonster.prototype.getMonsterType = function() {
	return this.monsterType;
}

Packet_ServerMonster.prototype.getPositionAndOrientation = function() {
	return this.positionAndOrientation;
}

Packet_ServerMonster.prototype.setHealth = function(value) {
	this.health = value;
}

Packet_ServerMonster.prototype.setId = function(value) {
	this.id = value;
}

Packet_ServerMonster.prototype.setMonsterType = function(value) {
	this.monsterType = value;
}

Packet_ServerMonster.prototype.setPositionAndOrientation = function(value) {
	this.positionAndOrientation = value;
}

function Packet_ServerMonsterSerializer()
{
}

Packet_ServerMonsterSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.id = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.monsterType = ProtocolParser.readUInt64(stream);
			continue;
		case 26:
			if (instance.positionAndOrientation == null)
				instance.positionAndOrientation = Packet_PositionAndOrientationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer.deserializeLengthDelimited(stream, instance.positionAndOrientation);
			continue;
		case 32:
			instance.health = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerMonsterSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerMonsterSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerMonsterSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.id = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.monsterType = ProtocolParser.readUInt64(stream);
			continue;
		case 26:
			if (instance.positionAndOrientation == null)
				instance.positionAndOrientation = Packet_PositionAndOrientationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer.deserializeLengthDelimited(stream, instance.positionAndOrientation);
			continue;
		case 32:
			instance.health = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerMonsterSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.id = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.monsterType = ProtocolParser.readUInt64(stream);
			continue;
		case 26:
			if (instance.positionAndOrientation == null)
				instance.positionAndOrientation = Packet_PositionAndOrientationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer.deserializeLengthDelimited(stream, instance.positionAndOrientation);
			continue;
		case 32:
			instance.health = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerMonsterSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerMonster();
	Packet_ServerMonsterSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerMonsterSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.id);
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.monsterType);
	if (instance.positionAndOrientation != null) {
		stream.writeByte(ProtoPlatform.intToByte(26));
		var ms3 = new CitoMemoryStream();
		Packet_PositionAndOrientationSerializer.serialize(ms3, instance.positionAndOrientation);
		var ms3Length = ms3.length();
		ProtocolParser.writeUInt32_(stream, ms3Length);
		stream.write(ms3.getBuffer(), 0, ms3Length);
	}
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.health);
}

Packet_ServerMonsterSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerMonsterSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerMonsterSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerMonsterSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerMonsters()
{
	this.monsters = null;
	this.monstersCount = 0;
	this.monstersLength = 0;
}

Packet_ServerMonsters.prototype.getMonsters = function() {
	return this.monsters;
}

Packet_ServerMonsters.prototype.getMonstersCount = function() {
	return this.monstersCount;
}

Packet_ServerMonsters.prototype.getMonstersLength = function() {
	return this.monstersLength;
}

Packet_ServerMonsters.prototype.monstersAdd = function(value) {
	if (this.monstersCount >= this.monstersLength) {
		var Monsters2 = new Array(this.monstersLength * 2);
		this.monstersLength = this.monstersLength * 2;
		for (var i = 0; i < this.monstersCount; i++) {
			Monsters2[i] = this.monsters[i];
		}
		this.monsters = Monsters2;
	}
	this.monsters[this.monstersCount] = value;
	this.monstersCount++;
}

Packet_ServerMonsters.prototype.setMonsters = function(value, count, length) {
	this.monsters = value;
	this.monstersCount = count;
	this.monstersLength = length;
}

function Packet_ServerMonstersSerializer()
{
}

Packet_ServerMonstersSerializer.deserialize = function(stream, instance) {
	if (instance.monsters == null) {
		instance.monsters = new Array(1);
		instance.monstersCount = 0;
		instance.monstersLength = 1;
	}
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.monstersAdd(Packet_ServerMonsterSerializer.deserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerMonstersSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerMonstersSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerMonstersSerializer.deserializeLength = function(stream, length, instance) {
	if (instance.monsters == null) {
		instance.monsters = new Array(1);
		instance.monstersCount = 0;
		instance.monstersLength = 1;
	}
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.monstersAdd(Packet_ServerMonsterSerializer.deserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerMonstersSerializer.deserializeLengthDelimited = function(stream, instance) {
	if (instance.monsters == null) {
		instance.monsters = new Array(1);
		instance.monstersCount = 0;
		instance.monstersLength = 1;
	}
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.monstersAdd(Packet_ServerMonsterSerializer.deserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerMonstersSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerMonsters();
	Packet_ServerMonstersSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerMonstersSerializer.serialize = function(stream, instance) {
	if (instance.monsters != null) {
		for (var k = 0; k < instance.monstersCount; k++) {
			var i1 = instance.monsters[k];
			stream.writeByte(ProtoPlatform.intToByte(10));
			var ms1 = new CitoMemoryStream();
			Packet_ServerMonsterSerializer.serialize(ms1, i1);
			var ms1Length = ms1.length();
			ProtocolParser.writeUInt32_(stream, ms1Length);
			stream.write(ms1.getBuffer(), 0, ms1Length);
		}
	}
}

Packet_ServerMonstersSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerMonstersSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerMonstersSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerMonstersSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerPing()
{
}

function Packet_ServerPingSerializer()
{
}

Packet_ServerPingSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPingSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerPingSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerPingSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPingSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPingSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerPing();
	Packet_ServerPingSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerPingSerializer.serialize = function(stream, instance) {
}

Packet_ServerPingSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerPingSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerPingSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerPingSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerPlayerPing()
{
	this.clientId = 0;
	this.ping = 0;
}

Packet_ServerPlayerPing.prototype.getClientId = function() {
	return this.clientId;
}

Packet_ServerPlayerPing.prototype.getPing = function() {
	return this.ping;
}

Packet_ServerPlayerPing.prototype.setClientId = function(value) {
	this.clientId = value;
}

Packet_ServerPlayerPing.prototype.setPing = function(value) {
	this.ping = value;
}

function Packet_ServerPlayerPingSerializer()
{
}

Packet_ServerPlayerPingSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.clientId = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.ping = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPlayerPingSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerPlayerPingSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerPlayerPingSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.clientId = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.ping = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPlayerPingSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.clientId = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.ping = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPlayerPingSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerPlayerPing();
	Packet_ServerPlayerPingSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerPlayerPingSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.clientId);
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.ping);
}

Packet_ServerPlayerPingSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerPlayerPingSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerPlayerPingSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerPlayerPingSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerPlayerSpawnPosition()
{
	this.x = 0;
	this.y = 0;
	this.z = 0;
}

Packet_ServerPlayerSpawnPosition.prototype.getX = function() {
	return this.x;
}

Packet_ServerPlayerSpawnPosition.prototype.getY = function() {
	return this.y;
}

Packet_ServerPlayerSpawnPosition.prototype.getZ = function() {
	return this.z;
}

Packet_ServerPlayerSpawnPosition.prototype.setX = function(value) {
	this.x = value;
}

Packet_ServerPlayerSpawnPosition.prototype.setY = function(value) {
	this.y = value;
}

Packet_ServerPlayerSpawnPosition.prototype.setZ = function(value) {
	this.z = value;
}

function Packet_ServerPlayerSpawnPositionSerializer()
{
}

Packet_ServerPlayerSpawnPositionSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPlayerSpawnPositionSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerPlayerSpawnPositionSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerPlayerSpawnPositionSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPlayerSpawnPositionSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPlayerSpawnPositionSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerPlayerSpawnPosition();
	Packet_ServerPlayerSpawnPositionSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerPlayerSpawnPositionSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.x);
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.y);
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.z);
}

Packet_ServerPlayerSpawnPositionSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerPlayerSpawnPositionSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerPlayerSpawnPositionSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerPlayerSpawnPositionSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerPlayerStats()
{
	this.currentHealth = 0;
	this.currentOxygen = 0;
	this.maxHealth = 0;
	this.maxOxygen = 0;
}

Packet_ServerPlayerStats.prototype.getCurrentHealth = function() {
	return this.currentHealth;
}

Packet_ServerPlayerStats.prototype.getCurrentOxygen = function() {
	return this.currentOxygen;
}

Packet_ServerPlayerStats.prototype.getMaxHealth = function() {
	return this.maxHealth;
}

Packet_ServerPlayerStats.prototype.getMaxOxygen = function() {
	return this.maxOxygen;
}

Packet_ServerPlayerStats.prototype.setCurrentHealth = function(value) {
	this.currentHealth = value;
}

Packet_ServerPlayerStats.prototype.setCurrentOxygen = function(value) {
	this.currentOxygen = value;
}

Packet_ServerPlayerStats.prototype.setMaxHealth = function(value) {
	this.maxHealth = value;
}

Packet_ServerPlayerStats.prototype.setMaxOxygen = function(value) {
	this.maxOxygen = value;
}

function Packet_ServerPlayerStatsSerializer()
{
}

Packet_ServerPlayerStatsSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.currentHealth = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.maxHealth = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.currentOxygen = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.maxOxygen = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPlayerStatsSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerPlayerStatsSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerPlayerStatsSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.currentHealth = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.maxHealth = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.currentOxygen = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.maxOxygen = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPlayerStatsSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.currentHealth = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.maxHealth = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.currentOxygen = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.maxOxygen = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPlayerStatsSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerPlayerStats();
	Packet_ServerPlayerStatsSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerPlayerStatsSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.currentHealth);
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.maxHealth);
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.currentOxygen);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.maxOxygen);
}

Packet_ServerPlayerStatsSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerPlayerStatsSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerPlayerStatsSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerPlayerStatsSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerProjectile()
{
	this.blockId = 0;
	this.explodesAfterFloat = 0;
	this.fromXFloat = 0;
	this.fromYFloat = 0;
	this.fromZFloat = 0;
	this.sourcePlayerID = 0;
	this.velocityXFloat = 0;
	this.velocityYFloat = 0;
	this.velocityZFloat = 0;
}

Packet_ServerProjectile.prototype.getBlockId = function() {
	return this.blockId;
}

Packet_ServerProjectile.prototype.getExplodesAfterFloat = function() {
	return this.explodesAfterFloat;
}

Packet_ServerProjectile.prototype.getFromXFloat = function() {
	return this.fromXFloat;
}

Packet_ServerProjectile.prototype.getFromYFloat = function() {
	return this.fromYFloat;
}

Packet_ServerProjectile.prototype.getFromZFloat = function() {
	return this.fromZFloat;
}

Packet_ServerProjectile.prototype.getSourcePlayerID = function() {
	return this.sourcePlayerID;
}

Packet_ServerProjectile.prototype.getVelocityXFloat = function() {
	return this.velocityXFloat;
}

Packet_ServerProjectile.prototype.getVelocityYFloat = function() {
	return this.velocityYFloat;
}

Packet_ServerProjectile.prototype.getVelocityZFloat = function() {
	return this.velocityZFloat;
}

Packet_ServerProjectile.prototype.setBlockId = function(value) {
	this.blockId = value;
}

Packet_ServerProjectile.prototype.setExplodesAfterFloat = function(value) {
	this.explodesAfterFloat = value;
}

Packet_ServerProjectile.prototype.setFromXFloat = function(value) {
	this.fromXFloat = value;
}

Packet_ServerProjectile.prototype.setFromYFloat = function(value) {
	this.fromYFloat = value;
}

Packet_ServerProjectile.prototype.setFromZFloat = function(value) {
	this.fromZFloat = value;
}

Packet_ServerProjectile.prototype.setSourcePlayerID = function(value) {
	this.sourcePlayerID = value;
}

Packet_ServerProjectile.prototype.setVelocityXFloat = function(value) {
	this.velocityXFloat = value;
}

Packet_ServerProjectile.prototype.setVelocityYFloat = function(value) {
	this.velocityYFloat = value;
}

Packet_ServerProjectile.prototype.setVelocityZFloat = function(value) {
	this.velocityZFloat = value;
}

function Packet_ServerProjectileSerializer()
{
}

Packet_ServerProjectileSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.fromXFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.fromYFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.fromZFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.velocityXFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.velocityYFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.velocityZFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.blockId = ProtocolParser.readUInt64(stream);
			continue;
		case 64:
			instance.explodesAfterFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 72:
			instance.sourcePlayerID = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerProjectileSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerProjectileSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerProjectileSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.fromXFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.fromYFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.fromZFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.velocityXFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.velocityYFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.velocityZFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.blockId = ProtocolParser.readUInt64(stream);
			continue;
		case 64:
			instance.explodesAfterFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 72:
			instance.sourcePlayerID = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerProjectileSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.fromXFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.fromYFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.fromZFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.velocityXFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.velocityYFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.velocityZFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 56:
			instance.blockId = ProtocolParser.readUInt64(stream);
			continue;
		case 64:
			instance.explodesAfterFloat = ProtocolParser.readUInt64(stream);
			continue;
		case 72:
			instance.sourcePlayerID = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerProjectileSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerProjectile();
	Packet_ServerProjectileSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerProjectileSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.fromXFloat);
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.fromYFloat);
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.fromZFloat);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.velocityXFloat);
	stream.writeByte(ProtoPlatform.intToByte(40));
	ProtocolParser.writeUInt64(stream, instance.velocityYFloat);
	stream.writeByte(ProtoPlatform.intToByte(48));
	ProtocolParser.writeUInt64(stream, instance.velocityZFloat);
	stream.writeByte(ProtoPlatform.intToByte(56));
	ProtocolParser.writeUInt64(stream, instance.blockId);
	stream.writeByte(ProtoPlatform.intToByte(64));
	ProtocolParser.writeUInt64(stream, instance.explodesAfterFloat);
	stream.writeByte(ProtoPlatform.intToByte(72));
	ProtocolParser.writeUInt64(stream, instance.sourcePlayerID);
}

Packet_ServerProjectileSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerProjectileSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerProjectileSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerProjectileSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerQueryAnswer()
{
	this.gameMode = null;
	this.mOTD = null;
	this.mapSizeX = 0;
	this.mapSizeY = 0;
	this.mapSizeZ = 0;
	this.maxPlayers = 0;
	this.name = null;
	this.password = false;
	this.playerCount = 0;
	this.playerList = null;
	this.port = 0;
	this.publicHash = null;
	this.serverThumbnail = null;
	this.serverVersion = null;
}

Packet_ServerQueryAnswer.prototype.getGameMode = function() {
	return this.gameMode;
}

Packet_ServerQueryAnswer.prototype.getMOTD = function() {
	return this.mOTD;
}

Packet_ServerQueryAnswer.prototype.getMapSizeX = function() {
	return this.mapSizeX;
}

Packet_ServerQueryAnswer.prototype.getMapSizeY = function() {
	return this.mapSizeY;
}

Packet_ServerQueryAnswer.prototype.getMapSizeZ = function() {
	return this.mapSizeZ;
}

Packet_ServerQueryAnswer.prototype.getMaxPlayers = function() {
	return this.maxPlayers;
}

Packet_ServerQueryAnswer.prototype.getName = function() {
	return this.name;
}

Packet_ServerQueryAnswer.prototype.getPassword = function() {
	return this.password;
}

Packet_ServerQueryAnswer.prototype.getPlayerCount = function() {
	return this.playerCount;
}

Packet_ServerQueryAnswer.prototype.getPlayerList = function() {
	return this.playerList;
}

Packet_ServerQueryAnswer.prototype.getPort = function() {
	return this.port;
}

Packet_ServerQueryAnswer.prototype.getPublicHash = function() {
	return this.publicHash;
}

Packet_ServerQueryAnswer.prototype.getServerThumbnail = function() {
	return this.serverThumbnail;
}

Packet_ServerQueryAnswer.prototype.getServerVersion = function() {
	return this.serverVersion;
}

Packet_ServerQueryAnswer.prototype.setGameMode = function(value) {
	this.gameMode = value;
}

Packet_ServerQueryAnswer.prototype.setMOTD = function(value) {
	this.mOTD = value;
}

Packet_ServerQueryAnswer.prototype.setMapSizeX = function(value) {
	this.mapSizeX = value;
}

Packet_ServerQueryAnswer.prototype.setMapSizeY = function(value) {
	this.mapSizeY = value;
}

Packet_ServerQueryAnswer.prototype.setMapSizeZ = function(value) {
	this.mapSizeZ = value;
}

Packet_ServerQueryAnswer.prototype.setMaxPlayers = function(value) {
	this.maxPlayers = value;
}

Packet_ServerQueryAnswer.prototype.setName = function(value) {
	this.name = value;
}

Packet_ServerQueryAnswer.prototype.setPassword = function(value) {
	this.password = value;
}

Packet_ServerQueryAnswer.prototype.setPlayerCount = function(value) {
	this.playerCount = value;
}

Packet_ServerQueryAnswer.prototype.setPlayerList = function(value) {
	this.playerList = value;
}

Packet_ServerQueryAnswer.prototype.setPort = function(value) {
	this.port = value;
}

Packet_ServerQueryAnswer.prototype.setPublicHash = function(value) {
	this.publicHash = value;
}

Packet_ServerQueryAnswer.prototype.setServerThumbnail = function(value) {
	this.serverThumbnail = value;
}

Packet_ServerQueryAnswer.prototype.setServerVersion = function(value) {
	this.serverVersion = value;
}

function Packet_ServerQueryAnswerSerializer()
{
}

Packet_ServerQueryAnswerSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.name = ProtocolParser.readString(stream);
			continue;
		case 18:
			instance.mOTD = ProtocolParser.readString(stream);
			continue;
		case 24:
			instance.playerCount = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.maxPlayers = ProtocolParser.readUInt64(stream);
			continue;
		case 42:
			instance.playerList = ProtocolParser.readString(stream);
			continue;
		case 48:
			instance.port = ProtocolParser.readUInt64(stream);
			continue;
		case 58:
			instance.gameMode = ProtocolParser.readString(stream);
			continue;
		case 64:
			instance.password = ProtocolParser.readBool(stream);
			continue;
		case 74:
			instance.publicHash = ProtocolParser.readString(stream);
			continue;
		case 82:
			instance.serverVersion = ProtocolParser.readString(stream);
			continue;
		case 88:
			instance.mapSizeX = ProtocolParser.readUInt64(stream);
			continue;
		case 96:
			instance.mapSizeY = ProtocolParser.readUInt64(stream);
			continue;
		case 104:
			instance.mapSizeZ = ProtocolParser.readUInt64(stream);
			continue;
		case 114:
			instance.serverThumbnail = ProtocolParser.readBytes(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerQueryAnswerSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerQueryAnswerSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerQueryAnswerSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.name = ProtocolParser.readString(stream);
			continue;
		case 18:
			instance.mOTD = ProtocolParser.readString(stream);
			continue;
		case 24:
			instance.playerCount = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.maxPlayers = ProtocolParser.readUInt64(stream);
			continue;
		case 42:
			instance.playerList = ProtocolParser.readString(stream);
			continue;
		case 48:
			instance.port = ProtocolParser.readUInt64(stream);
			continue;
		case 58:
			instance.gameMode = ProtocolParser.readString(stream);
			continue;
		case 64:
			instance.password = ProtocolParser.readBool(stream);
			continue;
		case 74:
			instance.publicHash = ProtocolParser.readString(stream);
			continue;
		case 82:
			instance.serverVersion = ProtocolParser.readString(stream);
			continue;
		case 88:
			instance.mapSizeX = ProtocolParser.readUInt64(stream);
			continue;
		case 96:
			instance.mapSizeY = ProtocolParser.readUInt64(stream);
			continue;
		case 104:
			instance.mapSizeZ = ProtocolParser.readUInt64(stream);
			continue;
		case 114:
			instance.serverThumbnail = ProtocolParser.readBytes(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerQueryAnswerSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.name = ProtocolParser.readString(stream);
			continue;
		case 18:
			instance.mOTD = ProtocolParser.readString(stream);
			continue;
		case 24:
			instance.playerCount = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.maxPlayers = ProtocolParser.readUInt64(stream);
			continue;
		case 42:
			instance.playerList = ProtocolParser.readString(stream);
			continue;
		case 48:
			instance.port = ProtocolParser.readUInt64(stream);
			continue;
		case 58:
			instance.gameMode = ProtocolParser.readString(stream);
			continue;
		case 64:
			instance.password = ProtocolParser.readBool(stream);
			continue;
		case 74:
			instance.publicHash = ProtocolParser.readString(stream);
			continue;
		case 82:
			instance.serverVersion = ProtocolParser.readString(stream);
			continue;
		case 88:
			instance.mapSizeX = ProtocolParser.readUInt64(stream);
			continue;
		case 96:
			instance.mapSizeY = ProtocolParser.readUInt64(stream);
			continue;
		case 104:
			instance.mapSizeZ = ProtocolParser.readUInt64(stream);
			continue;
		case 114:
			instance.serverThumbnail = ProtocolParser.readBytes(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerQueryAnswerSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerQueryAnswer();
	Packet_ServerQueryAnswerSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerQueryAnswerSerializer.serialize = function(stream, instance) {
	if (instance.name != null) {
		stream.writeByte(ProtoPlatform.intToByte(10));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.name));
	}
	if (instance.mOTD != null) {
		stream.writeByte(ProtoPlatform.intToByte(18));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.mOTD));
	}
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.playerCount);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.maxPlayers);
	if (instance.playerList != null) {
		stream.writeByte(ProtoPlatform.intToByte(42));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.playerList));
	}
	stream.writeByte(ProtoPlatform.intToByte(48));
	ProtocolParser.writeUInt64(stream, instance.port);
	if (instance.gameMode != null) {
		stream.writeByte(ProtoPlatform.intToByte(58));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.gameMode));
	}
	stream.writeByte(ProtoPlatform.intToByte(64));
	ProtocolParser.writeBool(stream, instance.password);
	if (instance.publicHash != null) {
		stream.writeByte(ProtoPlatform.intToByte(74));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.publicHash));
	}
	if (instance.serverVersion != null) {
		stream.writeByte(ProtoPlatform.intToByte(82));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.serverVersion));
	}
	stream.writeByte(ProtoPlatform.intToByte(88));
	ProtocolParser.writeUInt64(stream, instance.mapSizeX);
	stream.writeByte(ProtoPlatform.intToByte(96));
	ProtocolParser.writeUInt64(stream, instance.mapSizeY);
	stream.writeByte(ProtoPlatform.intToByte(104));
	ProtocolParser.writeUInt64(stream, instance.mapSizeZ);
	if (instance.serverThumbnail != null) {
		stream.writeByte(ProtoPlatform.intToByte(114));
		ProtocolParser.writeBytes(stream, instance.serverThumbnail);
	}
}

Packet_ServerQueryAnswerSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerQueryAnswerSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerQueryAnswerSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerQueryAnswerSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerRedirect()
{
	this.iP = null;
	this.port = 0;
}

Packet_ServerRedirect.prototype.getIP = function() {
	return this.iP;
}

Packet_ServerRedirect.prototype.getPort = function() {
	return this.port;
}

Packet_ServerRedirect.prototype.setIP = function(value) {
	this.iP = value;
}

Packet_ServerRedirect.prototype.setPort = function(value) {
	this.port = value;
}

function Packet_ServerRedirectSerializer()
{
}

Packet_ServerRedirectSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.iP = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.port = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerRedirectSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerRedirectSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerRedirectSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.iP = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.port = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerRedirectSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.iP = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.port = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerRedirectSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerRedirect();
	Packet_ServerRedirectSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerRedirectSerializer.serialize = function(stream, instance) {
	if (instance.iP != null) {
		stream.writeByte(ProtoPlatform.intToByte(10));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.iP));
	}
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.port);
}

Packet_ServerRedirectSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerRedirectSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerRedirectSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerRedirectSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerSeason()
{
	this.dayNightCycleSpeedup = 0;
	this.hour = 0;
	this.moon = 0;
}

Packet_ServerSeason.prototype.getDayNightCycleSpeedup = function() {
	return this.dayNightCycleSpeedup;
}

Packet_ServerSeason.prototype.getHour = function() {
	return this.hour;
}

Packet_ServerSeason.prototype.getMoon = function() {
	return this.moon;
}

Packet_ServerSeason.prototype.setDayNightCycleSpeedup = function(value) {
	this.dayNightCycleSpeedup = value;
}

Packet_ServerSeason.prototype.setHour = function(value) {
	this.hour = value;
}

Packet_ServerSeason.prototype.setMoon = function(value) {
	this.moon = value;
}

function Packet_ServerSeasonSerializer()
{
}

Packet_ServerSeasonSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 16:
			instance.hour = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.dayNightCycleSpeedup = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.moon = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSeasonSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerSeasonSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerSeasonSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 16:
			instance.hour = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.dayNightCycleSpeedup = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.moon = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSeasonSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 16:
			instance.hour = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.dayNightCycleSpeedup = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.moon = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSeasonSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerSeason();
	Packet_ServerSeasonSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerSeasonSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.hour);
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.dayNightCycleSpeedup);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.moon);
}

Packet_ServerSeasonSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerSeasonSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerSeasonSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerSeasonSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerSerializer()
{
}

Packet_ServerSerializer.deserialize = function(stream, instance) {
	instance.id = 0;
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			if (instance.identification == null)
				instance.identification = Packet_ServerIdentificationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerIdentificationSerializer.deserializeLengthDelimited(stream, instance.identification);
			continue;
		case 18:
			if (instance.levelInitialize == null)
				instance.levelInitialize = Packet_ServerLevelInitializeSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLevelInitializeSerializer.deserializeLengthDelimited(stream, instance.levelInitialize);
			continue;
		case 26:
			if (instance.levelDataChunk == null)
				instance.levelDataChunk = Packet_ServerLevelProgressSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLevelProgressSerializer.deserializeLengthDelimited(stream, instance.levelDataChunk);
			continue;
		case 34:
			if (instance.levelFinalize == null)
				instance.levelFinalize = Packet_ServerLevelFinalizeSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLevelFinalizeSerializer.deserializeLengthDelimited(stream, instance.levelFinalize);
			continue;
		case 42:
			if (instance.setBlock == null)
				instance.setBlock = Packet_ServerSetBlockSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSetBlockSerializer.deserializeLengthDelimited(stream, instance.setBlock);
			continue;
		case 74:
			if (instance.message == null)
				instance.message = Packet_ServerMessageSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerMessageSerializer.deserializeLengthDelimited(stream, instance.message);
			continue;
		case 82:
			if (instance.disconnectPlayer == null)
				instance.disconnectPlayer = Packet_ServerDisconnectPlayerSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerDisconnectPlayerSerializer.deserializeLengthDelimited(stream, instance.disconnectPlayer);
			continue;
		case 90:
			if (instance.chunk_ == null)
				instance.chunk_ = Packet_ServerChunkSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerChunkSerializer.deserializeLengthDelimited(stream, instance.chunk_);
			continue;
		case 98:
			if (instance.inventory == null)
				instance.inventory = Packet_ServerInventorySerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerInventorySerializer.deserializeLengthDelimited(stream, instance.inventory);
			continue;
		case 106:
			if (instance.season == null)
				instance.season = Packet_ServerSeasonSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSeasonSerializer.deserializeLengthDelimited(stream, instance.season);
			continue;
		case 114:
			if (instance.blobInitialize == null)
				instance.blobInitialize = Packet_ServerBlobInitializeSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlobInitializeSerializer.deserializeLengthDelimited(stream, instance.blobInitialize);
			continue;
		case 122:
			if (instance.blobPart == null)
				instance.blobPart = Packet_ServerBlobPartSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlobPartSerializer.deserializeLengthDelimited(stream, instance.blobPart);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		case 90:
			if (key.getWireType() != 0)
				break;
			instance.id = ProtocolParser.readUInt64(stream);
			continue;
		case 51:
			if (key.getWireType() != 2)
				break;
			if (instance.fillArea == null)
				instance.fillArea = Packet_ServerFillAreaSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFillAreaSerializer.deserializeLengthDelimited(stream, instance.fillArea);
			continue;
		case 52:
			if (key.getWireType() != 2)
				break;
			if (instance.fillAreaLimit == null)
				instance.fillAreaLimit = Packet_ServerFillAreaLimitSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFillAreaLimitSerializer.deserializeLengthDelimited(stream, instance.fillAreaLimit);
			continue;
		case 53:
			if (key.getWireType() != 2)
				break;
			if (instance.freemove == null)
				instance.freemove = Packet_ServerFreemoveSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFreemoveSerializer.deserializeLengthDelimited(stream, instance.freemove);
			continue;
		case 16:
			if (key.getWireType() != 2)
				break;
			if (instance.blobFinalize == null)
				instance.blobFinalize = Packet_ServerBlobFinalizeSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlobFinalizeSerializer.deserializeLengthDelimited(stream, instance.blobFinalize);
			continue;
		case 17:
			if (key.getWireType() != 2)
				break;
			if (instance.heightmapChunk == null)
				instance.heightmapChunk = Packet_ServerHeightmapChunkSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerHeightmapChunkSerializer.deserializeLengthDelimited(stream, instance.heightmapChunk);
			continue;
		case 18:
			if (key.getWireType() != 2)
				break;
			if (instance.ping == null)
				instance.ping = Packet_ServerPingSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPingSerializer.deserializeLengthDelimited(stream, instance.ping);
			continue;
		case 181:
			if (key.getWireType() != 2)
				break;
			if (instance.playerPing == null)
				instance.playerPing = Packet_ServerPlayerPingSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerPingSerializer.deserializeLengthDelimited(stream, instance.playerPing);
			continue;
		case 19:
			if (key.getWireType() != 2)
				break;
			if (instance.sound == null)
				instance.sound = Packet_ServerSoundSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSoundSerializer.deserializeLengthDelimited(stream, instance.sound);
			continue;
		case 20:
			if (key.getWireType() != 2)
				break;
			if (instance.playerStats == null)
				instance.playerStats = Packet_ServerPlayerStatsSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerStatsSerializer.deserializeLengthDelimited(stream, instance.playerStats);
			continue;
		case 21:
			if (key.getWireType() != 2)
				break;
			if (instance.monster == null)
				instance.monster = Packet_ServerMonstersSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerMonstersSerializer.deserializeLengthDelimited(stream, instance.monster);
			continue;
		case 22:
			if (key.getWireType() != 2)
				break;
			if (instance.playerSpawnPosition == null)
				instance.playerSpawnPosition = Packet_ServerPlayerSpawnPositionSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerSpawnPositionSerializer.deserializeLengthDelimited(stream, instance.playerSpawnPosition);
			continue;
		case 23:
			if (key.getWireType() != 2)
				break;
			if (instance.blockTypes == null)
				instance.blockTypes = Packet_ServerBlockTypesSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlockTypesSerializer.deserializeLengthDelimited(stream, instance.blockTypes);
			continue;
		case 24:
			if (key.getWireType() != 2)
				break;
			if (instance.sunLevels == null)
				instance.sunLevels = Packet_ServerSunLevelsSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSunLevelsSerializer.deserializeLengthDelimited(stream, instance.sunLevels);
			continue;
		case 25:
			if (key.getWireType() != 2)
				break;
			if (instance.lightLevels == null)
				instance.lightLevels = Packet_ServerLightLevelsSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLightLevelsSerializer.deserializeLengthDelimited(stream, instance.lightLevels);
			continue;
		case 26:
			if (key.getWireType() != 2)
				break;
			if (instance.craftingRecipes == null)
				instance.craftingRecipes = Packet_ServerCraftingRecipesSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerCraftingRecipesSerializer.deserializeLengthDelimited(stream, instance.craftingRecipes);
			continue;
		case 27:
			if (key.getWireType() != 2)
				break;
			if (instance.dialog == null)
				instance.dialog = Packet_ServerDialogSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerDialogSerializer.deserializeLengthDelimited(stream, instance.dialog);
			continue;
		case 28:
			if (key.getWireType() != 2)
				break;
			if (instance.follow == null)
				instance.follow = Packet_ServerFollowSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFollowSerializer.deserializeLengthDelimited(stream, instance.follow);
			continue;
		case 29:
			if (key.getWireType() != 2)
				break;
			if (instance.bullet == null)
				instance.bullet = Packet_ServerBulletSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBulletSerializer.deserializeLengthDelimited(stream, instance.bullet);
			continue;
		case 30:
			if (key.getWireType() != 2)
				break;
			if (instance.ammo == null)
				instance.ammo = Packet_ServerAmmoSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerAmmoSerializer.deserializeLengthDelimited(stream, instance.ammo);
			continue;
		case 31:
			if (key.getWireType() != 2)
				break;
			if (instance.blockType == null)
				instance.blockType = Packet_ServerBlockTypeSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlockTypeSerializer.deserializeLengthDelimited(stream, instance.blockType);
			continue;
		case 32:
			if (key.getWireType() != 2)
				break;
			if (instance.chunkPart == null)
				instance.chunkPart = Packet_ServerChunkPartSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerChunkPartSerializer.deserializeLengthDelimited(stream, instance.chunkPart);
			continue;
		case 33:
			if (key.getWireType() != 2)
				break;
			if (instance.explosion == null)
				instance.explosion = Packet_ServerExplosionSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerExplosionSerializer.deserializeLengthDelimited(stream, instance.explosion);
			continue;
		case 34:
			if (key.getWireType() != 2)
				break;
			if (instance.projectile == null)
				instance.projectile = Packet_ServerProjectileSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerProjectileSerializer.deserializeLengthDelimited(stream, instance.projectile);
			continue;
		case 35:
			if (key.getWireType() != 2)
				break;
			if (instance.translation == null)
				instance.translation = Packet_ServerTranslatedStringSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerTranslatedStringSerializer.deserializeLengthDelimited(stream, instance.translation);
			continue;
		case 36:
			if (key.getWireType() != 2)
				break;
			if (instance.queryAnswer == null)
				instance.queryAnswer = Packet_ServerQueryAnswerSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerQueryAnswerSerializer.deserializeLengthDelimited(stream, instance.queryAnswer);
			continue;
		case 37:
			if (key.getWireType() != 2)
				break;
			if (instance.redirect == null)
				instance.redirect = Packet_ServerRedirectSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerRedirectSerializer.deserializeLengthDelimited(stream, instance.redirect);
			continue;
		case 39:
			if (key.getWireType() != 2)
				break;
			if (instance.entitySpawn == null)
				instance.entitySpawn = Packet_ServerEntitySpawnSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntitySpawnSerializer.deserializeLengthDelimited(stream, instance.entitySpawn);
			continue;
		case 40:
			if (key.getWireType() != 2)
				break;
			if (instance.entityPosition == null)
				instance.entityPosition = Packet_ServerEntityPositionAndOrientationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityPositionAndOrientationSerializer.deserializeLengthDelimited(stream, instance.entityPosition);
			continue;
		case 41:
			if (key.getWireType() != 2)
				break;
			if (instance.entityDespawn == null)
				instance.entityDespawn = Packet_ServerEntityDespawnSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDespawnSerializer.deserializeLengthDelimited(stream, instance.entityDespawn);
			continue;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerSerializer.deserializeLength = function(stream, length, instance) {
	instance.id = 0;
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			if (instance.identification == null)
				instance.identification = Packet_ServerIdentificationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerIdentificationSerializer.deserializeLengthDelimited(stream, instance.identification);
			continue;
		case 18:
			if (instance.levelInitialize == null)
				instance.levelInitialize = Packet_ServerLevelInitializeSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLevelInitializeSerializer.deserializeLengthDelimited(stream, instance.levelInitialize);
			continue;
		case 26:
			if (instance.levelDataChunk == null)
				instance.levelDataChunk = Packet_ServerLevelProgressSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLevelProgressSerializer.deserializeLengthDelimited(stream, instance.levelDataChunk);
			continue;
		case 34:
			if (instance.levelFinalize == null)
				instance.levelFinalize = Packet_ServerLevelFinalizeSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLevelFinalizeSerializer.deserializeLengthDelimited(stream, instance.levelFinalize);
			continue;
		case 42:
			if (instance.setBlock == null)
				instance.setBlock = Packet_ServerSetBlockSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSetBlockSerializer.deserializeLengthDelimited(stream, instance.setBlock);
			continue;
		case 74:
			if (instance.message == null)
				instance.message = Packet_ServerMessageSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerMessageSerializer.deserializeLengthDelimited(stream, instance.message);
			continue;
		case 82:
			if (instance.disconnectPlayer == null)
				instance.disconnectPlayer = Packet_ServerDisconnectPlayerSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerDisconnectPlayerSerializer.deserializeLengthDelimited(stream, instance.disconnectPlayer);
			continue;
		case 90:
			if (instance.chunk_ == null)
				instance.chunk_ = Packet_ServerChunkSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerChunkSerializer.deserializeLengthDelimited(stream, instance.chunk_);
			continue;
		case 98:
			if (instance.inventory == null)
				instance.inventory = Packet_ServerInventorySerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerInventorySerializer.deserializeLengthDelimited(stream, instance.inventory);
			continue;
		case 106:
			if (instance.season == null)
				instance.season = Packet_ServerSeasonSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSeasonSerializer.deserializeLengthDelimited(stream, instance.season);
			continue;
		case 114:
			if (instance.blobInitialize == null)
				instance.blobInitialize = Packet_ServerBlobInitializeSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlobInitializeSerializer.deserializeLengthDelimited(stream, instance.blobInitialize);
			continue;
		case 122:
			if (instance.blobPart == null)
				instance.blobPart = Packet_ServerBlobPartSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlobPartSerializer.deserializeLengthDelimited(stream, instance.blobPart);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		case 90:
			if (key.getWireType() != 0)
				break;
			instance.id = ProtocolParser.readUInt64(stream);
			continue;
		case 51:
			if (key.getWireType() != 2)
				break;
			if (instance.fillArea == null)
				instance.fillArea = Packet_ServerFillAreaSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFillAreaSerializer.deserializeLengthDelimited(stream, instance.fillArea);
			continue;
		case 52:
			if (key.getWireType() != 2)
				break;
			if (instance.fillAreaLimit == null)
				instance.fillAreaLimit = Packet_ServerFillAreaLimitSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFillAreaLimitSerializer.deserializeLengthDelimited(stream, instance.fillAreaLimit);
			continue;
		case 53:
			if (key.getWireType() != 2)
				break;
			if (instance.freemove == null)
				instance.freemove = Packet_ServerFreemoveSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFreemoveSerializer.deserializeLengthDelimited(stream, instance.freemove);
			continue;
		case 16:
			if (key.getWireType() != 2)
				break;
			if (instance.blobFinalize == null)
				instance.blobFinalize = Packet_ServerBlobFinalizeSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlobFinalizeSerializer.deserializeLengthDelimited(stream, instance.blobFinalize);
			continue;
		case 17:
			if (key.getWireType() != 2)
				break;
			if (instance.heightmapChunk == null)
				instance.heightmapChunk = Packet_ServerHeightmapChunkSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerHeightmapChunkSerializer.deserializeLengthDelimited(stream, instance.heightmapChunk);
			continue;
		case 18:
			if (key.getWireType() != 2)
				break;
			if (instance.ping == null)
				instance.ping = Packet_ServerPingSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPingSerializer.deserializeLengthDelimited(stream, instance.ping);
			continue;
		case 181:
			if (key.getWireType() != 2)
				break;
			if (instance.playerPing == null)
				instance.playerPing = Packet_ServerPlayerPingSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerPingSerializer.deserializeLengthDelimited(stream, instance.playerPing);
			continue;
		case 19:
			if (key.getWireType() != 2)
				break;
			if (instance.sound == null)
				instance.sound = Packet_ServerSoundSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSoundSerializer.deserializeLengthDelimited(stream, instance.sound);
			continue;
		case 20:
			if (key.getWireType() != 2)
				break;
			if (instance.playerStats == null)
				instance.playerStats = Packet_ServerPlayerStatsSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerStatsSerializer.deserializeLengthDelimited(stream, instance.playerStats);
			continue;
		case 21:
			if (key.getWireType() != 2)
				break;
			if (instance.monster == null)
				instance.monster = Packet_ServerMonstersSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerMonstersSerializer.deserializeLengthDelimited(stream, instance.monster);
			continue;
		case 22:
			if (key.getWireType() != 2)
				break;
			if (instance.playerSpawnPosition == null)
				instance.playerSpawnPosition = Packet_ServerPlayerSpawnPositionSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerSpawnPositionSerializer.deserializeLengthDelimited(stream, instance.playerSpawnPosition);
			continue;
		case 23:
			if (key.getWireType() != 2)
				break;
			if (instance.blockTypes == null)
				instance.blockTypes = Packet_ServerBlockTypesSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlockTypesSerializer.deserializeLengthDelimited(stream, instance.blockTypes);
			continue;
		case 24:
			if (key.getWireType() != 2)
				break;
			if (instance.sunLevels == null)
				instance.sunLevels = Packet_ServerSunLevelsSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSunLevelsSerializer.deserializeLengthDelimited(stream, instance.sunLevels);
			continue;
		case 25:
			if (key.getWireType() != 2)
				break;
			if (instance.lightLevels == null)
				instance.lightLevels = Packet_ServerLightLevelsSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLightLevelsSerializer.deserializeLengthDelimited(stream, instance.lightLevels);
			continue;
		case 26:
			if (key.getWireType() != 2)
				break;
			if (instance.craftingRecipes == null)
				instance.craftingRecipes = Packet_ServerCraftingRecipesSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerCraftingRecipesSerializer.deserializeLengthDelimited(stream, instance.craftingRecipes);
			continue;
		case 27:
			if (key.getWireType() != 2)
				break;
			if (instance.dialog == null)
				instance.dialog = Packet_ServerDialogSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerDialogSerializer.deserializeLengthDelimited(stream, instance.dialog);
			continue;
		case 28:
			if (key.getWireType() != 2)
				break;
			if (instance.follow == null)
				instance.follow = Packet_ServerFollowSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFollowSerializer.deserializeLengthDelimited(stream, instance.follow);
			continue;
		case 29:
			if (key.getWireType() != 2)
				break;
			if (instance.bullet == null)
				instance.bullet = Packet_ServerBulletSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBulletSerializer.deserializeLengthDelimited(stream, instance.bullet);
			continue;
		case 30:
			if (key.getWireType() != 2)
				break;
			if (instance.ammo == null)
				instance.ammo = Packet_ServerAmmoSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerAmmoSerializer.deserializeLengthDelimited(stream, instance.ammo);
			continue;
		case 31:
			if (key.getWireType() != 2)
				break;
			if (instance.blockType == null)
				instance.blockType = Packet_ServerBlockTypeSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlockTypeSerializer.deserializeLengthDelimited(stream, instance.blockType);
			continue;
		case 32:
			if (key.getWireType() != 2)
				break;
			if (instance.chunkPart == null)
				instance.chunkPart = Packet_ServerChunkPartSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerChunkPartSerializer.deserializeLengthDelimited(stream, instance.chunkPart);
			continue;
		case 33:
			if (key.getWireType() != 2)
				break;
			if (instance.explosion == null)
				instance.explosion = Packet_ServerExplosionSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerExplosionSerializer.deserializeLengthDelimited(stream, instance.explosion);
			continue;
		case 34:
			if (key.getWireType() != 2)
				break;
			if (instance.projectile == null)
				instance.projectile = Packet_ServerProjectileSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerProjectileSerializer.deserializeLengthDelimited(stream, instance.projectile);
			continue;
		case 35:
			if (key.getWireType() != 2)
				break;
			if (instance.translation == null)
				instance.translation = Packet_ServerTranslatedStringSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerTranslatedStringSerializer.deserializeLengthDelimited(stream, instance.translation);
			continue;
		case 36:
			if (key.getWireType() != 2)
				break;
			if (instance.queryAnswer == null)
				instance.queryAnswer = Packet_ServerQueryAnswerSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerQueryAnswerSerializer.deserializeLengthDelimited(stream, instance.queryAnswer);
			continue;
		case 37:
			if (key.getWireType() != 2)
				break;
			if (instance.redirect == null)
				instance.redirect = Packet_ServerRedirectSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerRedirectSerializer.deserializeLengthDelimited(stream, instance.redirect);
			continue;
		case 39:
			if (key.getWireType() != 2)
				break;
			if (instance.entitySpawn == null)
				instance.entitySpawn = Packet_ServerEntitySpawnSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntitySpawnSerializer.deserializeLengthDelimited(stream, instance.entitySpawn);
			continue;
		case 40:
			if (key.getWireType() != 2)
				break;
			if (instance.entityPosition == null)
				instance.entityPosition = Packet_ServerEntityPositionAndOrientationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityPositionAndOrientationSerializer.deserializeLengthDelimited(stream, instance.entityPosition);
			continue;
		case 41:
			if (key.getWireType() != 2)
				break;
			if (instance.entityDespawn == null)
				instance.entityDespawn = Packet_ServerEntityDespawnSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDespawnSerializer.deserializeLengthDelimited(stream, instance.entityDespawn);
			continue;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSerializer.deserializeLengthDelimited = function(stream, instance) {
	instance.id = 0;
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			if (instance.identification == null)
				instance.identification = Packet_ServerIdentificationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerIdentificationSerializer.deserializeLengthDelimited(stream, instance.identification);
			continue;
		case 18:
			if (instance.levelInitialize == null)
				instance.levelInitialize = Packet_ServerLevelInitializeSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLevelInitializeSerializer.deserializeLengthDelimited(stream, instance.levelInitialize);
			continue;
		case 26:
			if (instance.levelDataChunk == null)
				instance.levelDataChunk = Packet_ServerLevelProgressSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLevelProgressSerializer.deserializeLengthDelimited(stream, instance.levelDataChunk);
			continue;
		case 34:
			if (instance.levelFinalize == null)
				instance.levelFinalize = Packet_ServerLevelFinalizeSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLevelFinalizeSerializer.deserializeLengthDelimited(stream, instance.levelFinalize);
			continue;
		case 42:
			if (instance.setBlock == null)
				instance.setBlock = Packet_ServerSetBlockSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSetBlockSerializer.deserializeLengthDelimited(stream, instance.setBlock);
			continue;
		case 74:
			if (instance.message == null)
				instance.message = Packet_ServerMessageSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerMessageSerializer.deserializeLengthDelimited(stream, instance.message);
			continue;
		case 82:
			if (instance.disconnectPlayer == null)
				instance.disconnectPlayer = Packet_ServerDisconnectPlayerSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerDisconnectPlayerSerializer.deserializeLengthDelimited(stream, instance.disconnectPlayer);
			continue;
		case 90:
			if (instance.chunk_ == null)
				instance.chunk_ = Packet_ServerChunkSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerChunkSerializer.deserializeLengthDelimited(stream, instance.chunk_);
			continue;
		case 98:
			if (instance.inventory == null)
				instance.inventory = Packet_ServerInventorySerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerInventorySerializer.deserializeLengthDelimited(stream, instance.inventory);
			continue;
		case 106:
			if (instance.season == null)
				instance.season = Packet_ServerSeasonSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSeasonSerializer.deserializeLengthDelimited(stream, instance.season);
			continue;
		case 114:
			if (instance.blobInitialize == null)
				instance.blobInitialize = Packet_ServerBlobInitializeSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlobInitializeSerializer.deserializeLengthDelimited(stream, instance.blobInitialize);
			continue;
		case 122:
			if (instance.blobPart == null)
				instance.blobPart = Packet_ServerBlobPartSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlobPartSerializer.deserializeLengthDelimited(stream, instance.blobPart);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		case 90:
			if (key.getWireType() != 0)
				break;
			instance.id = ProtocolParser.readUInt64(stream);
			continue;
		case 51:
			if (key.getWireType() != 2)
				break;
			if (instance.fillArea == null)
				instance.fillArea = Packet_ServerFillAreaSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFillAreaSerializer.deserializeLengthDelimited(stream, instance.fillArea);
			continue;
		case 52:
			if (key.getWireType() != 2)
				break;
			if (instance.fillAreaLimit == null)
				instance.fillAreaLimit = Packet_ServerFillAreaLimitSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFillAreaLimitSerializer.deserializeLengthDelimited(stream, instance.fillAreaLimit);
			continue;
		case 53:
			if (key.getWireType() != 2)
				break;
			if (instance.freemove == null)
				instance.freemove = Packet_ServerFreemoveSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFreemoveSerializer.deserializeLengthDelimited(stream, instance.freemove);
			continue;
		case 16:
			if (key.getWireType() != 2)
				break;
			if (instance.blobFinalize == null)
				instance.blobFinalize = Packet_ServerBlobFinalizeSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlobFinalizeSerializer.deserializeLengthDelimited(stream, instance.blobFinalize);
			continue;
		case 17:
			if (key.getWireType() != 2)
				break;
			if (instance.heightmapChunk == null)
				instance.heightmapChunk = Packet_ServerHeightmapChunkSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerHeightmapChunkSerializer.deserializeLengthDelimited(stream, instance.heightmapChunk);
			continue;
		case 18:
			if (key.getWireType() != 2)
				break;
			if (instance.ping == null)
				instance.ping = Packet_ServerPingSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPingSerializer.deserializeLengthDelimited(stream, instance.ping);
			continue;
		case 181:
			if (key.getWireType() != 2)
				break;
			if (instance.playerPing == null)
				instance.playerPing = Packet_ServerPlayerPingSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerPingSerializer.deserializeLengthDelimited(stream, instance.playerPing);
			continue;
		case 19:
			if (key.getWireType() != 2)
				break;
			if (instance.sound == null)
				instance.sound = Packet_ServerSoundSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSoundSerializer.deserializeLengthDelimited(stream, instance.sound);
			continue;
		case 20:
			if (key.getWireType() != 2)
				break;
			if (instance.playerStats == null)
				instance.playerStats = Packet_ServerPlayerStatsSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerStatsSerializer.deserializeLengthDelimited(stream, instance.playerStats);
			continue;
		case 21:
			if (key.getWireType() != 2)
				break;
			if (instance.monster == null)
				instance.monster = Packet_ServerMonstersSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerMonstersSerializer.deserializeLengthDelimited(stream, instance.monster);
			continue;
		case 22:
			if (key.getWireType() != 2)
				break;
			if (instance.playerSpawnPosition == null)
				instance.playerSpawnPosition = Packet_ServerPlayerSpawnPositionSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerSpawnPositionSerializer.deserializeLengthDelimited(stream, instance.playerSpawnPosition);
			continue;
		case 23:
			if (key.getWireType() != 2)
				break;
			if (instance.blockTypes == null)
				instance.blockTypes = Packet_ServerBlockTypesSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlockTypesSerializer.deserializeLengthDelimited(stream, instance.blockTypes);
			continue;
		case 24:
			if (key.getWireType() != 2)
				break;
			if (instance.sunLevels == null)
				instance.sunLevels = Packet_ServerSunLevelsSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSunLevelsSerializer.deserializeLengthDelimited(stream, instance.sunLevels);
			continue;
		case 25:
			if (key.getWireType() != 2)
				break;
			if (instance.lightLevels == null)
				instance.lightLevels = Packet_ServerLightLevelsSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLightLevelsSerializer.deserializeLengthDelimited(stream, instance.lightLevels);
			continue;
		case 26:
			if (key.getWireType() != 2)
				break;
			if (instance.craftingRecipes == null)
				instance.craftingRecipes = Packet_ServerCraftingRecipesSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerCraftingRecipesSerializer.deserializeLengthDelimited(stream, instance.craftingRecipes);
			continue;
		case 27:
			if (key.getWireType() != 2)
				break;
			if (instance.dialog == null)
				instance.dialog = Packet_ServerDialogSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerDialogSerializer.deserializeLengthDelimited(stream, instance.dialog);
			continue;
		case 28:
			if (key.getWireType() != 2)
				break;
			if (instance.follow == null)
				instance.follow = Packet_ServerFollowSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFollowSerializer.deserializeLengthDelimited(stream, instance.follow);
			continue;
		case 29:
			if (key.getWireType() != 2)
				break;
			if (instance.bullet == null)
				instance.bullet = Packet_ServerBulletSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBulletSerializer.deserializeLengthDelimited(stream, instance.bullet);
			continue;
		case 30:
			if (key.getWireType() != 2)
				break;
			if (instance.ammo == null)
				instance.ammo = Packet_ServerAmmoSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerAmmoSerializer.deserializeLengthDelimited(stream, instance.ammo);
			continue;
		case 31:
			if (key.getWireType() != 2)
				break;
			if (instance.blockType == null)
				instance.blockType = Packet_ServerBlockTypeSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlockTypeSerializer.deserializeLengthDelimited(stream, instance.blockType);
			continue;
		case 32:
			if (key.getWireType() != 2)
				break;
			if (instance.chunkPart == null)
				instance.chunkPart = Packet_ServerChunkPartSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerChunkPartSerializer.deserializeLengthDelimited(stream, instance.chunkPart);
			continue;
		case 33:
			if (key.getWireType() != 2)
				break;
			if (instance.explosion == null)
				instance.explosion = Packet_ServerExplosionSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerExplosionSerializer.deserializeLengthDelimited(stream, instance.explosion);
			continue;
		case 34:
			if (key.getWireType() != 2)
				break;
			if (instance.projectile == null)
				instance.projectile = Packet_ServerProjectileSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerProjectileSerializer.deserializeLengthDelimited(stream, instance.projectile);
			continue;
		case 35:
			if (key.getWireType() != 2)
				break;
			if (instance.translation == null)
				instance.translation = Packet_ServerTranslatedStringSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerTranslatedStringSerializer.deserializeLengthDelimited(stream, instance.translation);
			continue;
		case 36:
			if (key.getWireType() != 2)
				break;
			if (instance.queryAnswer == null)
				instance.queryAnswer = Packet_ServerQueryAnswerSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerQueryAnswerSerializer.deserializeLengthDelimited(stream, instance.queryAnswer);
			continue;
		case 37:
			if (key.getWireType() != 2)
				break;
			if (instance.redirect == null)
				instance.redirect = Packet_ServerRedirectSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerRedirectSerializer.deserializeLengthDelimited(stream, instance.redirect);
			continue;
		case 39:
			if (key.getWireType() != 2)
				break;
			if (instance.entitySpawn == null)
				instance.entitySpawn = Packet_ServerEntitySpawnSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntitySpawnSerializer.deserializeLengthDelimited(stream, instance.entitySpawn);
			continue;
		case 40:
			if (key.getWireType() != 2)
				break;
			if (instance.entityPosition == null)
				instance.entityPosition = Packet_ServerEntityPositionAndOrientationSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityPositionAndOrientationSerializer.deserializeLengthDelimited(stream, instance.entityPosition);
			continue;
		case 41:
			if (key.getWireType() != 2)
				break;
			if (instance.entityDespawn == null)
				instance.entityDespawn = Packet_ServerEntityDespawnSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDespawnSerializer.deserializeLengthDelimited(stream, instance.entityDespawn);
			continue;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_Server();
	Packet_ServerSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerSerializer.serialize = function(stream, instance) {
	if (instance.id != 0) {
		stream.writeByte(ProtoPlatform.intToByte(208));
		stream.writeByte(ProtoPlatform.intToByte(5));
		ProtocolParser.writeUInt64(stream, instance.id);
	}
	if (instance.identification != null) {
		stream.writeByte(ProtoPlatform.intToByte(10));
		var ms1 = new CitoMemoryStream();
		Packet_ServerIdentificationSerializer.serialize(ms1, instance.identification);
		var ms1Length = ms1.length();
		ProtocolParser.writeUInt32_(stream, ms1Length);
		stream.write(ms1.getBuffer(), 0, ms1Length);
	}
	if (instance.levelInitialize != null) {
		stream.writeByte(ProtoPlatform.intToByte(18));
		var ms2 = new CitoMemoryStream();
		Packet_ServerLevelInitializeSerializer.serialize(ms2, instance.levelInitialize);
		var ms2Length = ms2.length();
		ProtocolParser.writeUInt32_(stream, ms2Length);
		stream.write(ms2.getBuffer(), 0, ms2Length);
	}
	if (instance.levelDataChunk != null) {
		stream.writeByte(ProtoPlatform.intToByte(26));
		var ms3 = new CitoMemoryStream();
		Packet_ServerLevelProgressSerializer.serialize(ms3, instance.levelDataChunk);
		var ms3Length = ms3.length();
		ProtocolParser.writeUInt32_(stream, ms3Length);
		stream.write(ms3.getBuffer(), 0, ms3Length);
	}
	if (instance.levelFinalize != null) {
		stream.writeByte(ProtoPlatform.intToByte(34));
		var ms4 = new CitoMemoryStream();
		Packet_ServerLevelFinalizeSerializer.serialize(ms4, instance.levelFinalize);
		var ms4Length = ms4.length();
		ProtocolParser.writeUInt32_(stream, ms4Length);
		stream.write(ms4.getBuffer(), 0, ms4Length);
	}
	if (instance.setBlock != null) {
		stream.writeByte(ProtoPlatform.intToByte(42));
		var ms5 = new CitoMemoryStream();
		Packet_ServerSetBlockSerializer.serialize(ms5, instance.setBlock);
		var ms5Length = ms5.length();
		ProtocolParser.writeUInt32_(stream, ms5Length);
		stream.write(ms5.getBuffer(), 0, ms5Length);
	}
	if (instance.fillArea != null) {
		stream.writeByte(ProtoPlatform.intToByte(154));
		stream.writeByte(ProtoPlatform.intToByte(3));
		var ms51 = new CitoMemoryStream();
		Packet_ServerFillAreaSerializer.serialize(ms51, instance.fillArea);
		var ms51Length = ms51.length();
		ProtocolParser.writeUInt32_(stream, ms51Length);
		stream.write(ms51.getBuffer(), 0, ms51Length);
	}
	if (instance.fillAreaLimit != null) {
		stream.writeByte(ProtoPlatform.intToByte(162));
		stream.writeByte(ProtoPlatform.intToByte(3));
		var ms52 = new CitoMemoryStream();
		Packet_ServerFillAreaLimitSerializer.serialize(ms52, instance.fillAreaLimit);
		var ms52Length = ms52.length();
		ProtocolParser.writeUInt32_(stream, ms52Length);
		stream.write(ms52.getBuffer(), 0, ms52Length);
	}
	if (instance.freemove != null) {
		stream.writeByte(ProtoPlatform.intToByte(170));
		stream.writeByte(ProtoPlatform.intToByte(3));
		var ms53 = new CitoMemoryStream();
		Packet_ServerFreemoveSerializer.serialize(ms53, instance.freemove);
		var ms53Length = ms53.length();
		ProtocolParser.writeUInt32_(stream, ms53Length);
		stream.write(ms53.getBuffer(), 0, ms53Length);
	}
	if (instance.message != null) {
		stream.writeByte(ProtoPlatform.intToByte(74));
		var ms9 = new CitoMemoryStream();
		Packet_ServerMessageSerializer.serialize(ms9, instance.message);
		var ms9Length = ms9.length();
		ProtocolParser.writeUInt32_(stream, ms9Length);
		stream.write(ms9.getBuffer(), 0, ms9Length);
	}
	if (instance.disconnectPlayer != null) {
		stream.writeByte(ProtoPlatform.intToByte(82));
		var ms10 = new CitoMemoryStream();
		Packet_ServerDisconnectPlayerSerializer.serialize(ms10, instance.disconnectPlayer);
		var ms10Length = ms10.length();
		ProtocolParser.writeUInt32_(stream, ms10Length);
		stream.write(ms10.getBuffer(), 0, ms10Length);
	}
	if (instance.chunk_ != null) {
		stream.writeByte(ProtoPlatform.intToByte(90));
		var ms11 = new CitoMemoryStream();
		Packet_ServerChunkSerializer.serialize(ms11, instance.chunk_);
		var ms11Length = ms11.length();
		ProtocolParser.writeUInt32_(stream, ms11Length);
		stream.write(ms11.getBuffer(), 0, ms11Length);
	}
	if (instance.inventory != null) {
		stream.writeByte(ProtoPlatform.intToByte(98));
		var ms12 = new CitoMemoryStream();
		Packet_ServerInventorySerializer.serialize(ms12, instance.inventory);
		var ms12Length = ms12.length();
		ProtocolParser.writeUInt32_(stream, ms12Length);
		stream.write(ms12.getBuffer(), 0, ms12Length);
	}
	if (instance.season != null) {
		stream.writeByte(ProtoPlatform.intToByte(106));
		var ms13 = new CitoMemoryStream();
		Packet_ServerSeasonSerializer.serialize(ms13, instance.season);
		var ms13Length = ms13.length();
		ProtocolParser.writeUInt32_(stream, ms13Length);
		stream.write(ms13.getBuffer(), 0, ms13Length);
	}
	if (instance.blobInitialize != null) {
		stream.writeByte(ProtoPlatform.intToByte(114));
		var ms14 = new CitoMemoryStream();
		Packet_ServerBlobInitializeSerializer.serialize(ms14, instance.blobInitialize);
		var ms14Length = ms14.length();
		ProtocolParser.writeUInt32_(stream, ms14Length);
		stream.write(ms14.getBuffer(), 0, ms14Length);
	}
	if (instance.blobPart != null) {
		stream.writeByte(ProtoPlatform.intToByte(122));
		var ms15 = new CitoMemoryStream();
		Packet_ServerBlobPartSerializer.serialize(ms15, instance.blobPart);
		var ms15Length = ms15.length();
		ProtocolParser.writeUInt32_(stream, ms15Length);
		stream.write(ms15.getBuffer(), 0, ms15Length);
	}
	if (instance.blobFinalize != null) {
		stream.writeByte(ProtoPlatform.intToByte(130));
		stream.writeByte(ProtoPlatform.intToByte(1));
		var ms16 = new CitoMemoryStream();
		Packet_ServerBlobFinalizeSerializer.serialize(ms16, instance.blobFinalize);
		var ms16Length = ms16.length();
		ProtocolParser.writeUInt32_(stream, ms16Length);
		stream.write(ms16.getBuffer(), 0, ms16Length);
	}
	if (instance.heightmapChunk != null) {
		stream.writeByte(ProtoPlatform.intToByte(138));
		stream.writeByte(ProtoPlatform.intToByte(1));
		var ms17 = new CitoMemoryStream();
		Packet_ServerHeightmapChunkSerializer.serialize(ms17, instance.heightmapChunk);
		var ms17Length = ms17.length();
		ProtocolParser.writeUInt32_(stream, ms17Length);
		stream.write(ms17.getBuffer(), 0, ms17Length);
	}
	if (instance.ping != null) {
		stream.writeByte(ProtoPlatform.intToByte(146));
		stream.writeByte(ProtoPlatform.intToByte(1));
		var ms18 = new CitoMemoryStream();
		Packet_ServerPingSerializer.serialize(ms18, instance.ping);
		var ms18Length = ms18.length();
		ProtocolParser.writeUInt32_(stream, ms18Length);
		stream.write(ms18.getBuffer(), 0, ms18Length);
	}
	if (instance.playerPing != null) {
		stream.writeByte(ProtoPlatform.intToByte(170));
		stream.writeByte(ProtoPlatform.intToByte(11));
		var ms181 = new CitoMemoryStream();
		Packet_ServerPlayerPingSerializer.serialize(ms181, instance.playerPing);
		var ms181Length = ms181.length();
		ProtocolParser.writeUInt32_(stream, ms181Length);
		stream.write(ms181.getBuffer(), 0, ms181Length);
	}
	if (instance.sound != null) {
		stream.writeByte(ProtoPlatform.intToByte(154));
		stream.writeByte(ProtoPlatform.intToByte(1));
		var ms19 = new CitoMemoryStream();
		Packet_ServerSoundSerializer.serialize(ms19, instance.sound);
		var ms19Length = ms19.length();
		ProtocolParser.writeUInt32_(stream, ms19Length);
		stream.write(ms19.getBuffer(), 0, ms19Length);
	}
	if (instance.playerStats != null) {
		stream.writeByte(ProtoPlatform.intToByte(162));
		stream.writeByte(ProtoPlatform.intToByte(1));
		var ms20 = new CitoMemoryStream();
		Packet_ServerPlayerStatsSerializer.serialize(ms20, instance.playerStats);
		var ms20Length = ms20.length();
		ProtocolParser.writeUInt32_(stream, ms20Length);
		stream.write(ms20.getBuffer(), 0, ms20Length);
	}
	if (instance.monster != null) {
		stream.writeByte(ProtoPlatform.intToByte(170));
		stream.writeByte(ProtoPlatform.intToByte(1));
		var ms21 = new CitoMemoryStream();
		Packet_ServerMonstersSerializer.serialize(ms21, instance.monster);
		var ms21Length = ms21.length();
		ProtocolParser.writeUInt32_(stream, ms21Length);
		stream.write(ms21.getBuffer(), 0, ms21Length);
	}
	if (instance.playerSpawnPosition != null) {
		stream.writeByte(ProtoPlatform.intToByte(178));
		stream.writeByte(ProtoPlatform.intToByte(1));
		var ms22 = new CitoMemoryStream();
		Packet_ServerPlayerSpawnPositionSerializer.serialize(ms22, instance.playerSpawnPosition);
		var ms22Length = ms22.length();
		ProtocolParser.writeUInt32_(stream, ms22Length);
		stream.write(ms22.getBuffer(), 0, ms22Length);
	}
	if (instance.blockTypes != null) {
		stream.writeByte(ProtoPlatform.intToByte(186));
		stream.writeByte(ProtoPlatform.intToByte(1));
		var ms23 = new CitoMemoryStream();
		Packet_ServerBlockTypesSerializer.serialize(ms23, instance.blockTypes);
		var ms23Length = ms23.length();
		ProtocolParser.writeUInt32_(stream, ms23Length);
		stream.write(ms23.getBuffer(), 0, ms23Length);
	}
	if (instance.sunLevels != null) {
		stream.writeByte(ProtoPlatform.intToByte(194));
		stream.writeByte(ProtoPlatform.intToByte(1));
		var ms24 = new CitoMemoryStream();
		Packet_ServerSunLevelsSerializer.serialize(ms24, instance.sunLevels);
		var ms24Length = ms24.length();
		ProtocolParser.writeUInt32_(stream, ms24Length);
		stream.write(ms24.getBuffer(), 0, ms24Length);
	}
	if (instance.lightLevels != null) {
		stream.writeByte(ProtoPlatform.intToByte(202));
		stream.writeByte(ProtoPlatform.intToByte(1));
		var ms25 = new CitoMemoryStream();
		Packet_ServerLightLevelsSerializer.serialize(ms25, instance.lightLevels);
		var ms25Length = ms25.length();
		ProtocolParser.writeUInt32_(stream, ms25Length);
		stream.write(ms25.getBuffer(), 0, ms25Length);
	}
	if (instance.craftingRecipes != null) {
		stream.writeByte(ProtoPlatform.intToByte(210));
		stream.writeByte(ProtoPlatform.intToByte(1));
		var ms26 = new CitoMemoryStream();
		Packet_ServerCraftingRecipesSerializer.serialize(ms26, instance.craftingRecipes);
		var ms26Length = ms26.length();
		ProtocolParser.writeUInt32_(stream, ms26Length);
		stream.write(ms26.getBuffer(), 0, ms26Length);
	}
	if (instance.dialog != null) {
		stream.writeByte(ProtoPlatform.intToByte(218));
		stream.writeByte(ProtoPlatform.intToByte(1));
		var ms27 = new CitoMemoryStream();
		Packet_ServerDialogSerializer.serialize(ms27, instance.dialog);
		var ms27Length = ms27.length();
		ProtocolParser.writeUInt32_(stream, ms27Length);
		stream.write(ms27.getBuffer(), 0, ms27Length);
	}
	if (instance.follow != null) {
		stream.writeByte(ProtoPlatform.intToByte(226));
		stream.writeByte(ProtoPlatform.intToByte(1));
		var ms28 = new CitoMemoryStream();
		Packet_ServerFollowSerializer.serialize(ms28, instance.follow);
		var ms28Length = ms28.length();
		ProtocolParser.writeUInt32_(stream, ms28Length);
		stream.write(ms28.getBuffer(), 0, ms28Length);
	}
	if (instance.bullet != null) {
		stream.writeByte(ProtoPlatform.intToByte(234));
		stream.writeByte(ProtoPlatform.intToByte(1));
		var ms29 = new CitoMemoryStream();
		Packet_ServerBulletSerializer.serialize(ms29, instance.bullet);
		var ms29Length = ms29.length();
		ProtocolParser.writeUInt32_(stream, ms29Length);
		stream.write(ms29.getBuffer(), 0, ms29Length);
	}
	if (instance.ammo != null) {
		stream.writeByte(ProtoPlatform.intToByte(242));
		stream.writeByte(ProtoPlatform.intToByte(1));
		var ms30 = new CitoMemoryStream();
		Packet_ServerAmmoSerializer.serialize(ms30, instance.ammo);
		var ms30Length = ms30.length();
		ProtocolParser.writeUInt32_(stream, ms30Length);
		stream.write(ms30.getBuffer(), 0, ms30Length);
	}
	if (instance.blockType != null) {
		stream.writeByte(ProtoPlatform.intToByte(250));
		stream.writeByte(ProtoPlatform.intToByte(1));
		var ms31 = new CitoMemoryStream();
		Packet_ServerBlockTypeSerializer.serialize(ms31, instance.blockType);
		var ms31Length = ms31.length();
		ProtocolParser.writeUInt32_(stream, ms31Length);
		stream.write(ms31.getBuffer(), 0, ms31Length);
	}
	if (instance.chunkPart != null) {
		stream.writeByte(ProtoPlatform.intToByte(130));
		stream.writeByte(ProtoPlatform.intToByte(2));
		var ms32 = new CitoMemoryStream();
		Packet_ServerChunkPartSerializer.serialize(ms32, instance.chunkPart);
		var ms32Length = ms32.length();
		ProtocolParser.writeUInt32_(stream, ms32Length);
		stream.write(ms32.getBuffer(), 0, ms32Length);
	}
	if (instance.explosion != null) {
		stream.writeByte(ProtoPlatform.intToByte(138));
		stream.writeByte(ProtoPlatform.intToByte(2));
		var ms33 = new CitoMemoryStream();
		Packet_ServerExplosionSerializer.serialize(ms33, instance.explosion);
		var ms33Length = ms33.length();
		ProtocolParser.writeUInt32_(stream, ms33Length);
		stream.write(ms33.getBuffer(), 0, ms33Length);
	}
	if (instance.projectile != null) {
		stream.writeByte(ProtoPlatform.intToByte(146));
		stream.writeByte(ProtoPlatform.intToByte(2));
		var ms34 = new CitoMemoryStream();
		Packet_ServerProjectileSerializer.serialize(ms34, instance.projectile);
		var ms34Length = ms34.length();
		ProtocolParser.writeUInt32_(stream, ms34Length);
		stream.write(ms34.getBuffer(), 0, ms34Length);
	}
	if (instance.translation != null) {
		stream.writeByte(ProtoPlatform.intToByte(154));
		stream.writeByte(ProtoPlatform.intToByte(2));
		var ms35 = new CitoMemoryStream();
		Packet_ServerTranslatedStringSerializer.serialize(ms35, instance.translation);
		var ms35Length = ms35.length();
		ProtocolParser.writeUInt32_(stream, ms35Length);
		stream.write(ms35.getBuffer(), 0, ms35Length);
	}
	if (instance.queryAnswer != null) {
		stream.writeByte(ProtoPlatform.intToByte(162));
		stream.writeByte(ProtoPlatform.intToByte(2));
		var ms36 = new CitoMemoryStream();
		Packet_ServerQueryAnswerSerializer.serialize(ms36, instance.queryAnswer);
		var ms36Length = ms36.length();
		ProtocolParser.writeUInt32_(stream, ms36Length);
		stream.write(ms36.getBuffer(), 0, ms36Length);
	}
	if (instance.redirect != null) {
		stream.writeByte(ProtoPlatform.intToByte(170));
		stream.writeByte(ProtoPlatform.intToByte(2));
		var ms37 = new CitoMemoryStream();
		Packet_ServerRedirectSerializer.serialize(ms37, instance.redirect);
		var ms37Length = ms37.length();
		ProtocolParser.writeUInt32_(stream, ms37Length);
		stream.write(ms37.getBuffer(), 0, ms37Length);
	}
	if (instance.entitySpawn != null) {
		stream.writeByte(ProtoPlatform.intToByte(186));
		stream.writeByte(ProtoPlatform.intToByte(2));
		var ms39 = new CitoMemoryStream();
		Packet_ServerEntitySpawnSerializer.serialize(ms39, instance.entitySpawn);
		var ms39Length = ms39.length();
		ProtocolParser.writeUInt32_(stream, ms39Length);
		stream.write(ms39.getBuffer(), 0, ms39Length);
	}
	if (instance.entityPosition != null) {
		stream.writeByte(ProtoPlatform.intToByte(194));
		stream.writeByte(ProtoPlatform.intToByte(2));
		var ms40 = new CitoMemoryStream();
		Packet_ServerEntityPositionAndOrientationSerializer.serialize(ms40, instance.entityPosition);
		var ms40Length = ms40.length();
		ProtocolParser.writeUInt32_(stream, ms40Length);
		stream.write(ms40.getBuffer(), 0, ms40Length);
	}
	if (instance.entityDespawn != null) {
		stream.writeByte(ProtoPlatform.intToByte(202));
		stream.writeByte(ProtoPlatform.intToByte(2));
		var ms41 = new CitoMemoryStream();
		Packet_ServerEntityDespawnSerializer.serialize(ms41, instance.entityDespawn);
		var ms41Length = ms41.length();
		ProtocolParser.writeUInt32_(stream, ms41Length);
		stream.write(ms41.getBuffer(), 0, ms41Length);
	}
}

Packet_ServerSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerSetBlock()
{
	this.blockType = 0;
	this.x = 0;
	this.y = 0;
	this.z = 0;
}

Packet_ServerSetBlock.prototype.getBlockType = function() {
	return this.blockType;
}

Packet_ServerSetBlock.prototype.getX = function() {
	return this.x;
}

Packet_ServerSetBlock.prototype.getY = function() {
	return this.y;
}

Packet_ServerSetBlock.prototype.getZ = function() {
	return this.z;
}

Packet_ServerSetBlock.prototype.setBlockType = function(value) {
	this.blockType = value;
}

Packet_ServerSetBlock.prototype.setX = function(value) {
	this.x = value;
}

Packet_ServerSetBlock.prototype.setY = function(value) {
	this.y = value;
}

Packet_ServerSetBlock.prototype.setZ = function(value) {
	this.z = value;
}

function Packet_ServerSetBlockSerializer()
{
}

Packet_ServerSetBlockSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.blockType = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSetBlockSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerSetBlockSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerSetBlockSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.blockType = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSetBlockSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 16:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.blockType = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSetBlockSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerSetBlock();
	Packet_ServerSetBlockSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerSetBlockSerializer.serialize = function(stream, instance) {
	stream.writeByte(ProtoPlatform.intToByte(8));
	ProtocolParser.writeUInt64(stream, instance.x);
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.y);
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.z);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.blockType);
}

Packet_ServerSetBlockSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerSetBlockSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerSetBlockSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerSetBlockSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerSound()
{
	this.name = null;
	this.x = 0;
	this.y = 0;
	this.z = 0;
}

Packet_ServerSound.prototype.getName = function() {
	return this.name;
}

Packet_ServerSound.prototype.getX = function() {
	return this.x;
}

Packet_ServerSound.prototype.getY = function() {
	return this.y;
}

Packet_ServerSound.prototype.getZ = function() {
	return this.z;
}

Packet_ServerSound.prototype.setName = function(value) {
	this.name = value;
}

Packet_ServerSound.prototype.setX = function(value) {
	this.x = value;
}

Packet_ServerSound.prototype.setY = function(value) {
	this.y = value;
}

Packet_ServerSound.prototype.setZ = function(value) {
	this.z = value;
}

function Packet_ServerSoundSerializer()
{
}

Packet_ServerSoundSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.name = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSoundSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerSoundSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerSoundSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.name = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSoundSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.name = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.z = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSoundSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerSound();
	Packet_ServerSoundSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerSoundSerializer.serialize = function(stream, instance) {
	if (instance.name != null) {
		stream.writeByte(ProtoPlatform.intToByte(10));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.name));
	}
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.x);
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.y);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.z);
}

Packet_ServerSoundSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerSoundSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerSoundSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerSoundSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerSunLevels()
{
	this.sunlevels = null;
	this.sunlevelsCount = 0;
	this.sunlevelsLength = 0;
}

Packet_ServerSunLevels.prototype.getSunlevels = function() {
	return this.sunlevels;
}

Packet_ServerSunLevels.prototype.getSunlevelsCount = function() {
	return this.sunlevelsCount;
}

Packet_ServerSunLevels.prototype.getSunlevelsLength = function() {
	return this.sunlevelsLength;
}

Packet_ServerSunLevels.prototype.setSunlevels = function(value, count, length) {
	this.sunlevels = value;
	this.sunlevelsCount = count;
	this.sunlevelsLength = length;
}

Packet_ServerSunLevels.prototype.sunlevelsAdd = function(value) {
	if (this.sunlevelsCount >= this.sunlevelsLength) {
		var Sunlevels2 = new Int32Array(new ArrayBuffer(this.sunlevelsLength * 2 << 2));
		this.sunlevelsLength = this.sunlevelsLength * 2;
		for (var i = 0; i < this.sunlevelsCount; i++) {
			Sunlevels2[i] = this.sunlevels[i];
		}
		this.sunlevels = Sunlevels2;
	}
	this.sunlevels[this.sunlevelsCount] = value;
	this.sunlevelsCount++;
}

function Packet_ServerSunLevelsSerializer()
{
}

Packet_ServerSunLevelsSerializer.deserialize = function(stream, instance) {
	if (instance.sunlevels == null) {
		instance.sunlevels = new Int32Array(new ArrayBuffer(1 << 2));
		instance.sunlevelsCount = 0;
		instance.sunlevelsLength = 1;
	}
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance.sunlevelsAdd(ProtocolParser.readUInt64(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSunLevelsSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerSunLevelsSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerSunLevelsSerializer.deserializeLength = function(stream, length, instance) {
	if (instance.sunlevels == null) {
		instance.sunlevels = new Int32Array(new ArrayBuffer(1 << 2));
		instance.sunlevelsCount = 0;
		instance.sunlevelsLength = 1;
	}
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.sunlevelsAdd(ProtocolParser.readUInt64(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSunLevelsSerializer.deserializeLengthDelimited = function(stream, instance) {
	if (instance.sunlevels == null) {
		instance.sunlevels = new Int32Array(new ArrayBuffer(1 << 2));
		instance.sunlevelsCount = 0;
		instance.sunlevelsLength = 1;
	}
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 8:
			instance.sunlevelsAdd(ProtocolParser.readUInt64(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSunLevelsSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerSunLevels();
	Packet_ServerSunLevelsSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerSunLevelsSerializer.serialize = function(stream, instance) {
	if (instance.sunlevels != null) {
		for (var k = 0; k < instance.sunlevelsCount; k++) {
			var i1 = instance.sunlevels[k];
			stream.writeByte(ProtoPlatform.intToByte(8));
			ProtocolParser.writeUInt64(stream, i1);
		}
	}
}

Packet_ServerSunLevelsSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerSunLevelsSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerSunLevelsSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerSunLevelsSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_ServerTranslatedString()
{
	this.id = null;
	this.lang = null;
	this.translation = null;
}

Packet_ServerTranslatedString.prototype.getId = function() {
	return this.id;
}

Packet_ServerTranslatedString.prototype.getLang = function() {
	return this.lang;
}

Packet_ServerTranslatedString.prototype.getTranslation = function() {
	return this.translation;
}

Packet_ServerTranslatedString.prototype.setId = function(value) {
	this.id = value;
}

Packet_ServerTranslatedString.prototype.setLang = function(value) {
	this.lang = value;
}

Packet_ServerTranslatedString.prototype.setTranslation = function(value) {
	this.translation = value;
}

function Packet_ServerTranslatedStringSerializer()
{
}

Packet_ServerTranslatedStringSerializer.deserialize = function(stream, instance) {
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.lang = ProtocolParser.readString(stream);
			continue;
		case 18:
			instance.id = ProtocolParser.readString(stream);
			continue;
		case 26:
			instance.translation = ProtocolParser.readString(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerTranslatedStringSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_ServerTranslatedStringSerializer.deserialize(ms, instance);
	return instance;
}

Packet_ServerTranslatedStringSerializer.deserializeLength = function(stream, length, instance) {
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.lang = ProtocolParser.readString(stream);
			continue;
		case 18:
			instance.id = ProtocolParser.readString(stream);
			continue;
		case 26:
			instance.translation = ProtocolParser.readString(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerTranslatedStringSerializer.deserializeLengthDelimited = function(stream, instance) {
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.lang = ProtocolParser.readString(stream);
			continue;
		case 18:
			instance.id = ProtocolParser.readString(stream);
			continue;
		case 26:
			instance.translation = ProtocolParser.readString(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerTranslatedStringSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_ServerTranslatedString();
	Packet_ServerTranslatedStringSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_ServerTranslatedStringSerializer.serialize = function(stream, instance) {
	if (instance.lang != null) {
		stream.writeByte(ProtoPlatform.intToByte(10));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.lang));
	}
	if (instance.id != null) {
		stream.writeByte(ProtoPlatform.intToByte(18));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.id));
	}
	if (instance.translation != null) {
		stream.writeByte(ProtoPlatform.intToByte(26));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.translation));
	}
}

Packet_ServerTranslatedStringSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_ServerTranslatedStringSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_ServerTranslatedStringSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_ServerTranslatedStringSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_SoundSet()
{
	this.break1 = null;
	this.break1Count = 0;
	this.break1Length = 0;
	this.build = null;
	this.buildCount = 0;
	this.buildLength = 0;
	this.clone = null;
	this.cloneCount = 0;
	this.cloneLength = 0;
	this.reload = null;
	this.reloadCount = 0;
	this.reloadLength = 0;
	this.shoot = null;
	this.shootCount = 0;
	this.shootEnd = null;
	this.shootEndCount = 0;
	this.shootEndLength = 0;
	this.shootLength = 0;
	this.walk = null;
	this.walkCount = 0;
	this.walkLength = 0;
}

Packet_SoundSet.prototype.break1Add = function(value) {
	if (this.break1Count >= this.break1Length) {
		var Break12 = new Array(this.break1Length * 2);
		this.break1Length = this.break1Length * 2;
		for (var i = 0; i < this.break1Count; i++) {
			Break12[i] = this.break1[i];
		}
		this.break1 = Break12;
	}
	this.break1[this.break1Count] = value;
	this.break1Count++;
}

Packet_SoundSet.prototype.buildAdd = function(value) {
	if (this.buildCount >= this.buildLength) {
		var Build2 = new Array(this.buildLength * 2);
		this.buildLength = this.buildLength * 2;
		for (var i = 0; i < this.buildCount; i++) {
			Build2[i] = this.build[i];
		}
		this.build = Build2;
	}
	this.build[this.buildCount] = value;
	this.buildCount++;
}

Packet_SoundSet.prototype.cloneAdd = function(value) {
	if (this.cloneCount >= this.cloneLength) {
		var Clone2 = new Array(this.cloneLength * 2);
		this.cloneLength = this.cloneLength * 2;
		for (var i = 0; i < this.cloneCount; i++) {
			Clone2[i] = this.clone[i];
		}
		this.clone = Clone2;
	}
	this.clone[this.cloneCount] = value;
	this.cloneCount++;
}

Packet_SoundSet.prototype.getBreak1 = function() {
	return this.break1;
}

Packet_SoundSet.prototype.getBreak1Count = function() {
	return this.break1Count;
}

Packet_SoundSet.prototype.getBreak1Length = function() {
	return this.break1Length;
}

Packet_SoundSet.prototype.getBuild = function() {
	return this.build;
}

Packet_SoundSet.prototype.getBuildCount = function() {
	return this.buildCount;
}

Packet_SoundSet.prototype.getBuildLength = function() {
	return this.buildLength;
}

Packet_SoundSet.prototype.getClone = function() {
	return this.clone;
}

Packet_SoundSet.prototype.getCloneCount = function() {
	return this.cloneCount;
}

Packet_SoundSet.prototype.getCloneLength = function() {
	return this.cloneLength;
}

Packet_SoundSet.prototype.getReload = function() {
	return this.reload;
}

Packet_SoundSet.prototype.getReloadCount = function() {
	return this.reloadCount;
}

Packet_SoundSet.prototype.getReloadLength = function() {
	return this.reloadLength;
}

Packet_SoundSet.prototype.getShoot = function() {
	return this.shoot;
}

Packet_SoundSet.prototype.getShootCount = function() {
	return this.shootCount;
}

Packet_SoundSet.prototype.getShootEnd = function() {
	return this.shootEnd;
}

Packet_SoundSet.prototype.getShootEndCount = function() {
	return this.shootEndCount;
}

Packet_SoundSet.prototype.getShootEndLength = function() {
	return this.shootEndLength;
}

Packet_SoundSet.prototype.getShootLength = function() {
	return this.shootLength;
}

Packet_SoundSet.prototype.getWalk = function() {
	return this.walk;
}

Packet_SoundSet.prototype.getWalkCount = function() {
	return this.walkCount;
}

Packet_SoundSet.prototype.getWalkLength = function() {
	return this.walkLength;
}

Packet_SoundSet.prototype.reloadAdd = function(value) {
	if (this.reloadCount >= this.reloadLength) {
		var Reload2 = new Array(this.reloadLength * 2);
		this.reloadLength = this.reloadLength * 2;
		for (var i = 0; i < this.reloadCount; i++) {
			Reload2[i] = this.reload[i];
		}
		this.reload = Reload2;
	}
	this.reload[this.reloadCount] = value;
	this.reloadCount++;
}

Packet_SoundSet.prototype.setBreak1 = function(value, count, length) {
	this.break1 = value;
	this.break1Count = count;
	this.break1Length = length;
}

Packet_SoundSet.prototype.setBuild = function(value, count, length) {
	this.build = value;
	this.buildCount = count;
	this.buildLength = length;
}

Packet_SoundSet.prototype.setClone = function(value, count, length) {
	this.clone = value;
	this.cloneCount = count;
	this.cloneLength = length;
}

Packet_SoundSet.prototype.setReload = function(value, count, length) {
	this.reload = value;
	this.reloadCount = count;
	this.reloadLength = length;
}

Packet_SoundSet.prototype.setShoot = function(value, count, length) {
	this.shoot = value;
	this.shootCount = count;
	this.shootLength = length;
}

Packet_SoundSet.prototype.setShootEnd = function(value, count, length) {
	this.shootEnd = value;
	this.shootEndCount = count;
	this.shootEndLength = length;
}

Packet_SoundSet.prototype.setWalk = function(value, count, length) {
	this.walk = value;
	this.walkCount = count;
	this.walkLength = length;
}

Packet_SoundSet.prototype.shootAdd = function(value) {
	if (this.shootCount >= this.shootLength) {
		var Shoot2 = new Array(this.shootLength * 2);
		this.shootLength = this.shootLength * 2;
		for (var i = 0; i < this.shootCount; i++) {
			Shoot2[i] = this.shoot[i];
		}
		this.shoot = Shoot2;
	}
	this.shoot[this.shootCount] = value;
	this.shootCount++;
}

Packet_SoundSet.prototype.shootEndAdd = function(value) {
	if (this.shootEndCount >= this.shootEndLength) {
		var ShootEnd2 = new Array(this.shootEndLength * 2);
		this.shootEndLength = this.shootEndLength * 2;
		for (var i = 0; i < this.shootEndCount; i++) {
			ShootEnd2[i] = this.shootEnd[i];
		}
		this.shootEnd = ShootEnd2;
	}
	this.shootEnd[this.shootEndCount] = value;
	this.shootEndCount++;
}

Packet_SoundSet.prototype.walkAdd = function(value) {
	if (this.walkCount >= this.walkLength) {
		var Walk2 = new Array(this.walkLength * 2);
		this.walkLength = this.walkLength * 2;
		for (var i = 0; i < this.walkCount; i++) {
			Walk2[i] = this.walk[i];
		}
		this.walk = Walk2;
	}
	this.walk[this.walkCount] = value;
	this.walkCount++;
}

function Packet_SoundSetSerializer()
{
}

Packet_SoundSetSerializer.deserialize = function(stream, instance) {
	if (instance.walk == null) {
		instance.walk = new Array(1);
		instance.walkCount = 0;
		instance.walkLength = 1;
	}
	if (instance.break1 == null) {
		instance.break1 = new Array(1);
		instance.break1Count = 0;
		instance.break1Length = 1;
	}
	if (instance.build == null) {
		instance.build = new Array(1);
		instance.buildCount = 0;
		instance.buildLength = 1;
	}
	if (instance.clone == null) {
		instance.clone = new Array(1);
		instance.cloneCount = 0;
		instance.cloneLength = 1;
	}
	if (instance.shoot == null) {
		instance.shoot = new Array(1);
		instance.shootCount = 0;
		instance.shootLength = 1;
	}
	if (instance.shootEnd == null) {
		instance.shootEnd = new Array(1);
		instance.shootEndCount = 0;
		instance.shootEndLength = 1;
	}
	if (instance.reload == null) {
		instance.reload = new Array(1);
		instance.reloadCount = 0;
		instance.reloadLength = 1;
	}
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.walkAdd(ProtocolParser.readString(stream));
			continue;
		case 18:
			instance.break1Add(ProtocolParser.readString(stream));
			continue;
		case 26:
			instance.buildAdd(ProtocolParser.readString(stream));
			continue;
		case 34:
			instance.cloneAdd(ProtocolParser.readString(stream));
			continue;
		case 42:
			instance.shootAdd(ProtocolParser.readString(stream));
			continue;
		case 50:
			instance.shootEndAdd(ProtocolParser.readString(stream));
			continue;
		case 58:
			instance.reloadAdd(ProtocolParser.readString(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_SoundSetSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_SoundSetSerializer.deserialize(ms, instance);
	return instance;
}

Packet_SoundSetSerializer.deserializeLength = function(stream, length, instance) {
	if (instance.walk == null) {
		instance.walk = new Array(1);
		instance.walkCount = 0;
		instance.walkLength = 1;
	}
	if (instance.break1 == null) {
		instance.break1 = new Array(1);
		instance.break1Count = 0;
		instance.break1Length = 1;
	}
	if (instance.build == null) {
		instance.build = new Array(1);
		instance.buildCount = 0;
		instance.buildLength = 1;
	}
	if (instance.clone == null) {
		instance.clone = new Array(1);
		instance.cloneCount = 0;
		instance.cloneLength = 1;
	}
	if (instance.shoot == null) {
		instance.shoot = new Array(1);
		instance.shootCount = 0;
		instance.shootLength = 1;
	}
	if (instance.shootEnd == null) {
		instance.shootEnd = new Array(1);
		instance.shootEndCount = 0;
		instance.shootEndLength = 1;
	}
	if (instance.reload == null) {
		instance.reload = new Array(1);
		instance.reloadCount = 0;
		instance.reloadLength = 1;
	}
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.walkAdd(ProtocolParser.readString(stream));
			continue;
		case 18:
			instance.break1Add(ProtocolParser.readString(stream));
			continue;
		case 26:
			instance.buildAdd(ProtocolParser.readString(stream));
			continue;
		case 34:
			instance.cloneAdd(ProtocolParser.readString(stream));
			continue;
		case 42:
			instance.shootAdd(ProtocolParser.readString(stream));
			continue;
		case 50:
			instance.shootEndAdd(ProtocolParser.readString(stream));
			continue;
		case 58:
			instance.reloadAdd(ProtocolParser.readString(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_SoundSetSerializer.deserializeLengthDelimited = function(stream, instance) {
	if (instance.walk == null) {
		instance.walk = new Array(1);
		instance.walkCount = 0;
		instance.walkLength = 1;
	}
	if (instance.break1 == null) {
		instance.break1 = new Array(1);
		instance.break1Count = 0;
		instance.break1Length = 1;
	}
	if (instance.build == null) {
		instance.build = new Array(1);
		instance.buildCount = 0;
		instance.buildLength = 1;
	}
	if (instance.clone == null) {
		instance.clone = new Array(1);
		instance.cloneCount = 0;
		instance.cloneLength = 1;
	}
	if (instance.shoot == null) {
		instance.shoot = new Array(1);
		instance.shootCount = 0;
		instance.shootLength = 1;
	}
	if (instance.shootEnd == null) {
		instance.shootEnd = new Array(1);
		instance.shootEndCount = 0;
		instance.shootEndLength = 1;
	}
	if (instance.reload == null) {
		instance.reload = new Array(1);
		instance.reloadCount = 0;
		instance.reloadLength = 1;
	}
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.walkAdd(ProtocolParser.readString(stream));
			continue;
		case 18:
			instance.break1Add(ProtocolParser.readString(stream));
			continue;
		case 26:
			instance.buildAdd(ProtocolParser.readString(stream));
			continue;
		case 34:
			instance.cloneAdd(ProtocolParser.readString(stream));
			continue;
		case 42:
			instance.shootAdd(ProtocolParser.readString(stream));
			continue;
		case 50:
			instance.shootEndAdd(ProtocolParser.readString(stream));
			continue;
		case 58:
			instance.reloadAdd(ProtocolParser.readString(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_SoundSetSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_SoundSet();
	Packet_SoundSetSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_SoundSetSerializer.serialize = function(stream, instance) {
	if (instance.walk != null) {
		for (var k = 0; k < instance.walkCount; k++) {
			var i1 = instance.walk[k];
			stream.writeByte(ProtoPlatform.intToByte(10));
			ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(i1));
		}
	}
	if (instance.break1 != null) {
		for (var k = 0; k < instance.break1Count; k++) {
			var i2 = instance.break1[k];
			stream.writeByte(ProtoPlatform.intToByte(18));
			ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(i2));
		}
	}
	if (instance.build != null) {
		for (var k = 0; k < instance.buildCount; k++) {
			var i3 = instance.build[k];
			stream.writeByte(ProtoPlatform.intToByte(26));
			ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(i3));
		}
	}
	if (instance.clone != null) {
		for (var k = 0; k < instance.cloneCount; k++) {
			var i4 = instance.clone[k];
			stream.writeByte(ProtoPlatform.intToByte(34));
			ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(i4));
		}
	}
	if (instance.shoot != null) {
		for (var k = 0; k < instance.shootCount; k++) {
			var i5 = instance.shoot[k];
			stream.writeByte(ProtoPlatform.intToByte(42));
			ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(i5));
		}
	}
	if (instance.shootEnd != null) {
		for (var k = 0; k < instance.shootEndCount; k++) {
			var i6 = instance.shootEnd[k];
			stream.writeByte(ProtoPlatform.intToByte(50));
			ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(i6));
		}
	}
	if (instance.reload != null) {
		for (var k = 0; k < instance.reloadCount; k++) {
			var i7 = instance.reload[k];
			stream.writeByte(ProtoPlatform.intToByte(58));
			ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(i7));
		}
	}
}

Packet_SoundSetSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_SoundSetSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_SoundSetSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_SoundSetSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_SpecialKeyEnum()
{
}
Packet_SpecialKeyEnum.RESPAWN = 0;
Packet_SpecialKeyEnum.SELECT_TEAM = 3;
Packet_SpecialKeyEnum.SET_SPAWN = 1;
Packet_SpecialKeyEnum.TAB_PLAYER_LIST = 2;

function Packet_StringList()
{
	this.items = null;
	this.itemsCount = 0;
	this.itemsLength = 0;
}

Packet_StringList.prototype.getItems = function() {
	return this.items;
}

Packet_StringList.prototype.getItemsCount = function() {
	return this.itemsCount;
}

Packet_StringList.prototype.getItemsLength = function() {
	return this.itemsLength;
}

Packet_StringList.prototype.itemsAdd = function(value) {
	if (this.itemsCount >= this.itemsLength) {
		var Items2 = new Array(this.itemsLength * 2);
		this.itemsLength = this.itemsLength * 2;
		for (var i = 0; i < this.itemsCount; i++) {
			Items2[i] = this.items[i];
		}
		this.items = Items2;
	}
	this.items[this.itemsCount] = value;
	this.itemsCount++;
}

Packet_StringList.prototype.setItems = function(value, count, length) {
	this.items = value;
	this.itemsCount = count;
	this.itemsLength = length;
}

function Packet_StringListSerializer()
{
}

Packet_StringListSerializer.deserialize = function(stream, instance) {
	if (instance.items == null) {
		instance.items = new Array(1);
		instance.itemsCount = 0;
		instance.itemsLength = 1;
	}
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.itemsAdd(ProtocolParser.readString(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_StringListSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_StringListSerializer.deserialize(ms, instance);
	return instance;
}

Packet_StringListSerializer.deserializeLength = function(stream, length, instance) {
	if (instance.items == null) {
		instance.items = new Array(1);
		instance.itemsCount = 0;
		instance.itemsLength = 1;
	}
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.itemsAdd(ProtocolParser.readString(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_StringListSerializer.deserializeLengthDelimited = function(stream, instance) {
	if (instance.items == null) {
		instance.items = new Array(1);
		instance.itemsCount = 0;
		instance.itemsLength = 1;
	}
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.itemsAdd(ProtocolParser.readString(stream));
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_StringListSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_StringList();
	Packet_StringListSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_StringListSerializer.serialize = function(stream, instance) {
	if (instance.items != null) {
		for (var k = 0; k < instance.itemsCount; k++) {
			var i1 = instance.items[k];
			stream.writeByte(ProtoPlatform.intToByte(10));
			ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(i1));
		}
	}
}

Packet_StringListSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_StringListSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_StringListSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_StringListSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_WalkableTypeEnum()
{
}
Packet_WalkableTypeEnum.EMPTY = 0;
Packet_WalkableTypeEnum.FLUID = 1;
Packet_WalkableTypeEnum.SOLID = 2;

function Packet_Widget()
{
	this.click = 0;
	this.clickKey = 0;
	this.color = 0;
	this.font = null;
	this.height_ = 0;
	this.id = null;
	this.image = null;
	this.text = null;
	this.type = 0;
	this.width = 0;
	this.x = 0;
	this.y = 0;
}

Packet_Widget.prototype.getClick = function() {
	return this.click;
}

Packet_Widget.prototype.getClickKey = function() {
	return this.clickKey;
}

Packet_Widget.prototype.getColor = function() {
	return this.color;
}

Packet_Widget.prototype.getFont = function() {
	return this.font;
}

Packet_Widget.prototype.getHeight_ = function() {
	return this.height_;
}

Packet_Widget.prototype.getId = function() {
	return this.id;
}

Packet_Widget.prototype.getImage = function() {
	return this.image;
}

Packet_Widget.prototype.getText = function() {
	return this.text;
}

Packet_Widget.prototype.getType = function() {
	return this.type;
}

Packet_Widget.prototype.getWidth = function() {
	return this.width;
}

Packet_Widget.prototype.getX = function() {
	return this.x;
}

Packet_Widget.prototype.getY = function() {
	return this.y;
}

Packet_Widget.prototype.setClick = function(value) {
	this.click = value;
}

Packet_Widget.prototype.setClickKey = function(value) {
	this.clickKey = value;
}

Packet_Widget.prototype.setColor = function(value) {
	this.color = value;
}

Packet_Widget.prototype.setFont = function(value) {
	this.font = value;
}

Packet_Widget.prototype.setHeight_ = function(value) {
	this.height_ = value;
}

Packet_Widget.prototype.setId = function(value) {
	this.id = value;
}

Packet_Widget.prototype.setImage = function(value) {
	this.image = value;
}

Packet_Widget.prototype.setText = function(value) {
	this.text = value;
}

Packet_Widget.prototype.setType = function(value) {
	this.type = value;
}

Packet_Widget.prototype.setWidth = function(value) {
	this.width = value;
}

Packet_Widget.prototype.setX = function(value) {
	this.x = value;
}

Packet_Widget.prototype.setY = function(value) {
	this.y = value;
}

function Packet_WidgetSerializer()
{
}

Packet_WidgetSerializer.deserialize = function(stream, instance) {
	instance.type = 0;
	while (true) {
		var keyByte = stream.readByte();
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance.id = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.click = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.width = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.height_ = ProtocolParser.readUInt64(stream);
			continue;
		case 58:
			instance.text = ProtocolParser.readString(stream);
			continue;
		case 64:
			instance.clickKey = ProtocolParser.readUInt64(stream);
			continue;
		case 74:
			instance.image = ProtocolParser.readString(stream);
			continue;
		case 80:
			instance.color = ProtocolParser.readUInt64(stream);
			continue;
		case 90:
			if (instance.font == null)
				instance.font = Packet_DialogFontSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_DialogFontSerializer.deserializeLengthDelimited(stream, instance.font);
			continue;
		case 96:
			instance.type = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_WidgetSerializer.deserializeBuffer = function(buffer, length, instance) {
	var ms = CitoMemoryStream.create(buffer, length);
	Packet_WidgetSerializer.deserialize(ms, instance);
	return instance;
}

Packet_WidgetSerializer.deserializeLength = function(stream, length, instance) {
	instance.type = 0;
	var limit = stream.position() + length;
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.id = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.click = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.width = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.height_ = ProtocolParser.readUInt64(stream);
			continue;
		case 58:
			instance.text = ProtocolParser.readString(stream);
			continue;
		case 64:
			instance.clickKey = ProtocolParser.readUInt64(stream);
			continue;
		case 74:
			instance.image = ProtocolParser.readString(stream);
			continue;
		case 80:
			instance.color = ProtocolParser.readUInt64(stream);
			continue;
		case 90:
			if (instance.font == null)
				instance.font = Packet_DialogFontSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_DialogFontSerializer.deserializeLengthDelimited(stream, instance.font);
			continue;
		case 96:
			instance.type = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_WidgetSerializer.deserializeLengthDelimited = function(stream, instance) {
	instance.type = 0;
	var limit = ProtocolParser.readUInt32(stream);
	limit += stream.position();
	while (true) {
		if (stream.position() >= limit) {
			if (stream.position() == limit)
				break;
			else
				return null;
		}
		var keyByte = stream.readByte();
		if (keyByte == -1)
			return null;
		switch (keyByte) {
		case 10:
			instance.id = ProtocolParser.readString(stream);
			continue;
		case 16:
			instance.click = ProtocolParser.readUInt64(stream);
			continue;
		case 24:
			instance.x = ProtocolParser.readUInt64(stream);
			continue;
		case 32:
			instance.y = ProtocolParser.readUInt64(stream);
			continue;
		case 40:
			instance.width = ProtocolParser.readUInt64(stream);
			continue;
		case 48:
			instance.height_ = ProtocolParser.readUInt64(stream);
			continue;
		case 58:
			instance.text = ProtocolParser.readString(stream);
			continue;
		case 64:
			instance.clickKey = ProtocolParser.readUInt64(stream);
			continue;
		case 74:
			instance.image = ProtocolParser.readString(stream);
			continue;
		case 80:
			instance.color = ProtocolParser.readUInt64(stream);
			continue;
		case 90:
			if (instance.font == null)
				instance.font = Packet_DialogFontSerializer.deserializeLengthDelimitedNew(stream);
			else
				Packet_DialogFontSerializer.deserializeLengthDelimited(stream, instance.font);
			continue;
		case 96:
			instance.type = ProtocolParser.readUInt64(stream);
			continue;
		default:
			break;
		}
		var key = ProtocolParser.readKey_(keyByte & 0xff, stream);
		switch (key.getField()) {
		case 0:
			return null;
		default:
			ProtocolParser.skipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_WidgetSerializer.deserializeLengthDelimitedNew = function(stream) {
	var instance = new Packet_Widget();
	Packet_WidgetSerializer.deserializeLengthDelimited(stream, instance);
	return instance;
}

Packet_WidgetSerializer.serialize = function(stream, instance) {
	if (instance.id != null) {
		stream.writeByte(ProtoPlatform.intToByte(10));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.id));
	}
	stream.writeByte(ProtoPlatform.intToByte(16));
	ProtocolParser.writeUInt64(stream, instance.click);
	stream.writeByte(ProtoPlatform.intToByte(24));
	ProtocolParser.writeUInt64(stream, instance.x);
	stream.writeByte(ProtoPlatform.intToByte(32));
	ProtocolParser.writeUInt64(stream, instance.y);
	stream.writeByte(ProtoPlatform.intToByte(40));
	ProtocolParser.writeUInt64(stream, instance.width);
	stream.writeByte(ProtoPlatform.intToByte(48));
	ProtocolParser.writeUInt64(stream, instance.height_);
	if (instance.text != null) {
		stream.writeByte(ProtoPlatform.intToByte(58));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.text));
	}
	stream.writeByte(ProtoPlatform.intToByte(64));
	ProtocolParser.writeUInt64(stream, instance.clickKey);
	if (instance.image != null) {
		stream.writeByte(ProtoPlatform.intToByte(74));
		ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(instance.image));
	}
	stream.writeByte(ProtoPlatform.intToByte(80));
	ProtocolParser.writeUInt64(stream, instance.color);
	if (instance.font != null) {
		stream.writeByte(ProtoPlatform.intToByte(90));
		var ms11 = new CitoMemoryStream();
		Packet_DialogFontSerializer.serialize(ms11, instance.font);
		var ms11Length = ms11.length();
		ProtocolParser.writeUInt32_(stream, ms11Length);
		stream.write(ms11.getBuffer(), 0, ms11Length);
	}
	if (instance.type != 0) {
		stream.writeByte(ProtoPlatform.intToByte(96));
		ProtocolParser.writeUInt64(stream, instance.type);
	}
}

Packet_WidgetSerializer.serializeLengthDelimited = function(stream, instance) {
	var data = Packet_WidgetSerializer.serializeToBytes(instance);
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(data));
	stream.write(data, 0, ProtoPlatform.arrayLength(data));
}

Packet_WidgetSerializer.serializeToBytes = function(instance) {
	var ms = new CitoMemoryStream();
	Packet_WidgetSerializer.serialize(ms, instance);
	return ms.toArray();
}

function Packet_WidgetTypeEnum()
{
}
Packet_WidgetTypeEnum.IMAGE = 0;
Packet_WidgetTypeEnum.TEXT = 1;
Packet_WidgetTypeEnum.TEXT_BOX = 2;

function Ping_()
{
	this.roundtripTimeMilliseconds = 0;
	this.ready = false;
	this.timeSendMilliseconds = 0;
	this.timeout = 0;
	this.roundtripTimeMilliseconds = 0;
	this.ready = true;
	this.timeSendMilliseconds = 0;
	this.timeout = 10;
}

Ping_.prototype.getTimeoutValue = function() {
	return this.timeout;
}

Ping_.prototype.receive = function(currentTimeMilliseconds) {
	if (this.ready) {
		return false;
	}
	this.roundtripTimeMilliseconds = currentTimeMilliseconds - this.timeSendMilliseconds;
	this.ready = true;
	return true;
}

Ping_.prototype.roundtripTimeTotalMilliseconds = function() {
	return this.roundtripTimeMilliseconds;
}

Ping_.prototype.send = function(currentTimeMilliseconds) {
	if (!this.ready) {
		return false;
	}
	this.ready = false;
	this.timeSendMilliseconds = currentTimeMilliseconds;
	return true;
}

Ping_.prototype.setTimeoutValue = function(value) {
	this.timeout = value;
}

Ping_.prototype.timeout = function(currentTimeMilliseconds) {
	if (Math.floor((currentTimeMilliseconds - this.timeSendMilliseconds) / 1000) > this.timeout) {
		this.ready = true;
		return true;
	}
	return false;
}

function Platform()
{
}

Platform.acos = function(a) {
	
            return Math.acos(a);
        return 0;
}

Platform.cos = function(a) {
	
            return Math.cos(a);
        return 0;
}

Platform.sin = function(a) {
	
            return Math.sin(a);
        return 0;
}

Platform.sqrt = function(a) {
	
            return Math.sqrt(a);
        return 0;
}

Platform.tan = function(a) {
	
            return Math.tan(a);
        return 0;
}

Platform.writeInt = function(a) {
	
            console.log(a);
        }

Platform.writeString = function(a) {
	
            console.log(a);
        }

function Player()
{
	this.animationHint_ = null;
	this.currentTexture = 0;
	this.eyeHeight = null;
	this.heading = 0;
	this.health = 0;
	this.lastUpdateMilliseconds = 0;
	this.modelHeight = null;
	this.model_ = null;
	this.monsterType = 0;
	this.name = null;
	this.networkHeading = 0;
	this.networkPitch = 0;
	this.networkX = null;
	this.networkY = null;
	this.networkZ = null;
	this.pitch = 0;
	this.positionLoaded = false;
	this.positionX = null;
	this.positionY = null;
	this.positionZ = null;
	this.skinDownloadResponse = null;
	this.texture = null;
	this.type = PlayerType.PLAYER;
	this.moves = false;
	this.playerDrawInfo = null;
	this.animationHint_ = new AnimationHint();
	this.model_ = "player.txt";
	this.eyeHeight = this.defaultEyeHeight();
	this.modelHeight = this.defaultModelHeight();
	this.currentTexture = -1;
}

Player.prototype.defaultEyeHeight = function() {
	var one = 1;
	return (one * 15) / (10);
}

Player.prototype.defaultModelHeight = function() {
	var one = 1;
	return (one * 17) / (10);
}

function PlayerDrawInfo()
{
	this.animationHint_ = null;
	this.anim = null;
	this.interpolation = null;
	this.lastcurposX = null;
	this.lastcurposY = null;
	this.lastcurposZ = null;
	this.lastnetworkposX = null;
	this.lastnetworkposY = null;
	this.lastnetworkposZ = null;
	this.lastnetworkrotx = null;
	this.lastnetworkroty = null;
	this.lastnetworkrotz = null;
	this.moves = false;
	this.velocityX = null;
	this.velocityY = null;
	this.velocityZ = null;
	this.anim = new AnimationState();
	this.animationHint_ = new AnimationHint();
}

function PlayerInterpolate()
{
	this.platform = null;
}
PlayerInterpolate.prototype = new IInterpolation();

PlayerInterpolate.degToRad = function(deg) {
	return deg / (360) * 2 * Game.getPi();
}

PlayerInterpolate.prototype.interpolate = function(a, b, progress) {
	var aa = this.platform.castToPlayerInterpolationState(a);
	var bb = this.platform.castToPlayerInterpolationState(b);
	var cc = new PlayerInterpolationState();
	cc.positionX = aa.positionX + (bb.positionX - aa.positionX) * progress;
	cc.positionY = aa.positionY + (bb.positionY - aa.positionY) * progress;
	cc.positionZ = aa.positionZ + (bb.positionZ - aa.positionZ) * progress;
	cc.rotx = PlayerInterpolate.degToRad(AngleInterpolation.interpolateAngle360(this.platform, PlayerInterpolate.radToDeg(aa.rotx), PlayerInterpolate.radToDeg(bb.rotx), progress));
	cc.roty = PlayerInterpolate.degToRad(AngleInterpolation.interpolateAngle360(this.platform, PlayerInterpolate.radToDeg(aa.roty), PlayerInterpolate.radToDeg(bb.roty), progress));
	cc.rotz = PlayerInterpolate.degToRad(AngleInterpolation.interpolateAngle360(this.platform, PlayerInterpolate.radToDeg(aa.rotz), PlayerInterpolate.radToDeg(bb.rotz), progress));
	return cc;
}

PlayerInterpolate.radToDeg = function(rad) {
	return rad / (2 * Game.getPi()) * 360;
}

function PlayerInterpolationState()
{
	this.heading = 0;
	this.pitch = 0;
	this.positionX = null;
	this.positionY = null;
	this.positionZ = null;
	this.rotx = null;
	this.roty = null;
	this.rotz = null;
}
PlayerInterpolationState.prototype = new InterpolatedObject();

var PlayerType = {
	PLAYER : 0,
	MONSTER : 1
}

function PointFloatRef()
{
	this.x = null;
	this.y = null;
}

PointFloatRef.create = function(x_, y_) {
	var p = new PointFloatRef();
	p.x = x_;
	p.y = y_;
	return p;
}

function PointRef()
{
	this.x = 0;
	this.y = 0;
}

PointRef.create = function(x_, y_) {
	var p = new PointRef();
	p.x = x_;
	p.y = y_;
	return p;
}

function PredicateBox3D()
{
}

function PredicateBox3DHit()
{
	this.s = null;
}
PredicateBox3DHit.prototype = new PredicateBox3D();

PredicateBox3DHit.create = function(s_) {
	var p = new PredicateBox3DHit();
	p.s = s_;
	return p;
}

PredicateBox3DHit.prototype.hit = function(o) {
	return this.s.boxHit(o);
}

function Preferences()
{
	this.items = null;
	this.platform = null;
	this.items = new DictionaryStringString();
}

Preferences.prototype.getBool = function(key, default_) {
	var value = this.getString(key, null);
	if (value == null) {
		return default_;
	}
	if (value == "0") {
		return false;
	}
	if (value == "1") {
		return true;
	}
	return default_;
}

Preferences.prototype.getInt = function(key, default_) {
	if (this.getString(key, null) == null) {
		return default_;
	}
	var ret = new FloatRef();
	if (this.platform.floatTryParse(this.getString(key, null), ret)) {
		return this.platform.floatToInt(ret.value);
	}
	return default_;
}

Preferences.prototype.getItems = function() {
	return this.items;
}

Preferences.prototype.getKey = function(i) {
	if (this.items.items[i] != null) {
		return this.items.items[i].key;
	}
	else {
		return null;
	}
}

Preferences.prototype.getKeysCount = function() {
	return this.items.size;
}

Preferences.prototype.getString = function(key, default_) {
	if (!this.items.containsKey(key)) {
		return default_;
	}
	return this.items.get(key);
}

Preferences.prototype.remove = function(key) {
	this.items.remove(key);
}

Preferences.prototype.setBool = function(key, value) {
	this.setString(key, value ? "1" : "0");
}

Preferences.prototype.setInt = function(key, value) {
	this.setString(key, this.platform.intToString(value));
}

Preferences.prototype.setPlatform = function(value_) {
	this.platform = value_;
}

Preferences.prototype.setString = function(key, value) {
	this.items.set(key, value);
}

function ProcessPacketTask()
{
	this.game = null;
	this.packet_ = null;
}
ProcessPacketTask.prototype = new Action_();

ProcessPacketTask.prototype.contains = function(arr, arrLength, value) {
	return this.indexOf(arr, arrLength, value) != -1;
}

ProcessPacketTask.prototype.indexOf = function(arr, arrLength, value) {
	for (var i = 0; i < arrLength; i++) {
		if (Game.stringEquals(arr[i], value)) {
			return i;
		}
	}
	return -1;
}

ProcessPacketTask.prototype.processPacket = function(packet) {
	if (this.game.packetHandlers[packet.id] != null) {
		this.game.packetHandlers[packet.id].handle(this.game, packet);
	}
	switch (packet.id) {
	case 0:
		{
			var invalidversionstr = this.game.language.invalidVersionConnectAnyway();
			this.game.serverGameVersion = packet.identification.mdProtocolVersion;
			if (this.game.serverGameVersion != this.game.platform.getGameVersion()) {
				this.game.chatLog("[GAME] Different game versions");
				var q = this.game.platform.stringFormat2(invalidversionstr, this.game.platform.getGameVersion(), this.game.serverGameVersion);
				this.game.invalidVersionDrawMessage = q;
				this.game.invalidVersionPacketIdentification = packet;
			}
			else {
				this.game.processServerIdentification(packet);
			}
			this.game.receivedMapLength = 0;
		}
		break;
	case 1:
		{
			this.game.sendPingReply();
			this.game.serverInfo.serverPing.send(this.game.platform.timeMillisecondsFromStart());
		}
		break;
	case 111:
		{
			this.game.serverInfo.serverPing.receive(this.game.platform.timeMillisecondsFromStart());
			this.game.performanceinfo.set("Ping", this.game.platform.intToString(this.game.serverInfo.serverPing.roundtripTimeTotalMilliseconds()));
		}
		break;
	case 2:
		{
			this.game.chatLog("[GAME] Initialized map loading");
			this.game.receivedMapLength = 0;
			this.game.invokeMapLoadingProgress(0, 0, this.game.language.connecting());
		}
		break;
	case 3:
		{
			this.game.invokeMapLoadingProgress(packet.levelDataChunk.percentComplete, this.game.receivedMapLength, packet.levelDataChunk.status);
		}
		break;
	case 4:
		{
			this.game.chatLog("[GAME] Finished map loading");
		}
		break;
	case 6:
		{
			var x = packet.setBlock.x;
			var y = packet.setBlock.y;
			var z = packet.setBlock.z;
			var type = packet.setBlock.blockType;
			{
				this.game.setTileAndUpdate(x, y, z, type);
			}
		}
		break;
	case 61:
		{
			var ax = packet.fillArea.x1;
			var ay = packet.fillArea.y1;
			var az = packet.fillArea.z1;
			var bx = packet.fillArea.x2;
			var by = packet.fillArea.y2;
			var bz = packet.fillArea.z2;
			var startx = MathCi.minInt(ax, bx);
			var endx = MathCi.maxInt(ax, bx);
			var starty = MathCi.minInt(ay, by);
			var endy = MathCi.maxInt(ay, by);
			var startz = MathCi.minInt(az, bz);
			var endz = MathCi.maxInt(az, bz);
			var blockCount = packet.fillArea.blockCount;
			{
				for (var x = startx; x <= endx; x++) {
					for (var y = starty; y <= endy; y++) {
						for (var z = startz; z <= endz; z++) {
							if (blockCount == 0) {
								return;
							}
							{
								this.game.setTileAndUpdate(x, y, z, packet.fillArea.blockType);
							}
							blockCount--;
						}
					}
				}
			}
		}
		break;
	case 62:
		{
			this.game.fillAreaLimit = packet.fillAreaLimit.limit;
			if (this.game.fillAreaLimit > 100000) {
				this.game.fillAreaLimit = 100000;
			}
		}
		break;
	case 51:
		{
			this.game.allowFreemove = packet.freemove.isEnabled != 0;
			if (!this.game.allowFreemove) {
				this.game.controls.setFreemove(0);
				this.game.movespeed = this.game.basemovespeed;
				this.game.log(this.game.language.moveNormal());
			}
		}
		break;
	case 26:
		{
			var x = packet.playerSpawnPosition.x;
			var y = packet.playerSpawnPosition.y;
			var z = packet.playerSpawnPosition.z;
			this.game.playerPositionSpawnX = x;
			this.game.playerPositionSpawnY = z;
			this.game.playerPositionSpawnZ = y;
			this.game.log(this.game.platform.stringFormat(this.game.language.spawnPositionSetTo(), this.game.platform.stringFormat3("{0},{1},{2}", this.game.platform.intToString(x), this.game.platform.intToString(y), this.game.platform.intToString(z))));
		}
		break;
	case 13:
		{
			this.game.addChatline(packet.message.message);
			this.game.chatLog(packet.message.message);
		}
		break;
	case 14:
		{
			this.game.chatLog(this.game.platform.stringFormat("[GAME] Disconnected by the server ({0})", packet.disconnectPlayer.disconnectReason));
			if (this.game.platform.isMousePointerLocked()) {
				this.game.platform.exitMousePointerLock();
			}
			this.game.platform.messageBoxShowError(packet.disconnectPlayer.disconnectReason, "Disconnected from server");
			this.game.exitToMainMenu_();
			break;
		}
	case 23:
		{
			var p = packet.playerStats;
			this.game.playerStats = p;
		}
		break;
	case 16:
		{
			if (packet.inventory.inventory != null) {
				this.game.useInventory(packet.inventory.inventory);
			}
		}
		break;
	case 17:
		{
			packet.season.hour -= 1;
			if (packet.season.hour < 0) {
				packet.season.hour = 48;
			}
			var sunlight = this.game.nightLevels[packet.season.hour];
			this.game.skySphereNight = sunlight < 8;
			this.game.d_SunMoonRenderer.day_length_in_seconds = Math.floor(86400 / packet.season.dayNightCycleSpeedup);
			var hour = Math.floor(packet.season.hour / 4);
			if (this.game.d_SunMoonRenderer.getHour() != hour) {
				this.game.d_SunMoonRenderer.setHour(hour);
			}
			if (this.game.sunlight_ != sunlight) {
				this.game.sunlight_ = sunlight;
				this.game.redrawAllBlocks();
			}
		}
		break;
	case 18:
		{
			this.game.blobdownload = new CitoMemoryStream();
			this.game.blobdownloadname = packet.blobInitialize.name;
			this.game.blobdownloadmd5 = packet.blobInitialize.md5;
		}
		break;
	case 19:
		{
			var length = this.game.platform.byteArrayLength(packet.blobPart.data);
			this.game.blobdownload.write(packet.blobPart.data, 0, length);
			this.game.receivedMapLength += length;
		}
		break;
	case 20:
		{
			var downloaded = this.game.blobdownload.toArray();
			if (this.game.blobdownloadname != null) {
				this.game.setFile(this.game.blobdownloadname, this.game.blobdownloadmd5, downloaded, this.game.blobdownload.length());
			}
			this.game.blobdownload = null;
		}
		break;
	case 22:
		{
			this.game.playSoundAt(packet.sound.name, packet.sound.x, packet.sound.y, packet.sound.z);
		}
		break;
	case 50:
		{
			for (var i = 128; i < 256; i++) {
				this.game.entities[i] = null;
			}
		}
		break;
	case 60:
		this.game.language.override(packet.translation.lang, packet.translation.id, packet.translation.translation);
		break;
	case 56:
		this.game.newBlockTypes[packet.blockType.id] = packet.blockType.blocktype;
		break;
	case 28:
		this.game.nightLevels = packet.sunLevels.sunlevels;
		break;
	case 29:
		for (var i = 0; i < packet.lightLevels.lightlevelsCount; i++) {
			this.game.mLightLevels[i] = this.game.deserializeFloat(packet.lightLevels.lightlevels[i]);
		}
		break;
	case 53:
		var oldFollowId = this.game.followId();
		this.game.follow = packet.follow.client;
		if (packet.follow.tpp != 0) {
			this.game.setCamera(CameraType.OVERHEAD);
			this.game.player.position.rotx = Game.getPi();
			this.game.guiStateBackToGame();
		}
		else {
			this.game.setCamera(CameraType.FPP);
		}
		break;
	case 54:
		this.game.entityAddLocal(this.game.createBulletEntity(this.game.deserializeFloat(packet.bullet.fromXFloat), this.game.deserializeFloat(packet.bullet.fromYFloat), this.game.deserializeFloat(packet.bullet.fromZFloat), this.game.deserializeFloat(packet.bullet.toXFloat), this.game.deserializeFloat(packet.bullet.toYFloat), this.game.deserializeFloat(packet.bullet.toZFloat), this.game.deserializeFloat(packet.bullet.speedFloat)));
		break;
	case 55:
		if (!this.game.ammostarted) {
			this.game.ammostarted = true;
			for (var i = 0; i < packet.ammo.totalAmmoCount; i++) {
				var k = packet.ammo.totalAmmo[i];
				this.game.loadedAmmo[k.key_] = MathCi.minInt(k.value_, this.game.blocktypes[k.key_].ammoMagazine);
			}
		}
		this.game.totalAmmo = new Int32Array(new ArrayBuffer(1024 << 2));
		for (var i = 0; i < packet.ammo.totalAmmoCount; i++) {
			this.game.totalAmmo[packet.ammo.totalAmmo[i].key_] = packet.ammo.totalAmmo[i].value_;
		}
		break;
	case 58:
		{
			var entity = new Entity();
			entity.expires = new Expires();
			entity.expires.timeLeft = this.game.deserializeFloat(packet.explosion.timeFloat);
			entity.push = packet.explosion;
			this.game.entityAddLocal(entity);
		}
		break;
	case 59:
		{
			var entity = new Entity();
			var sprite = new Sprite();
			sprite.image = "ChemicalGreen.png";
			sprite.size = 14;
			sprite.animationcount = 0;
			sprite.positionX = this.game.deserializeFloat(packet.projectile.fromXFloat);
			sprite.positionY = this.game.deserializeFloat(packet.projectile.fromYFloat);
			sprite.positionZ = this.game.deserializeFloat(packet.projectile.fromZFloat);
			entity.sprite = sprite;
			var grenade = new Grenade_();
			grenade.velocityX = this.game.deserializeFloat(packet.projectile.velocityXFloat);
			grenade.velocityY = this.game.deserializeFloat(packet.projectile.velocityYFloat);
			grenade.velocityZ = this.game.deserializeFloat(packet.projectile.velocityZFloat);
			grenade.block = packet.projectile.blockId;
			grenade.sourcePlayer = packet.projectile.sourcePlayerID;
			entity.grenade = grenade;
			entity.expires = Expires.create(this.game.deserializeFloat(packet.projectile.explodesAfterFloat));
			this.game.entityAddLocal(entity);
		}
		break;
	case 27:
		this.game.blocktypes = this.game.newBlockTypes;
		this.game.newBlockTypes = new Array(1024);
		var textureInAtlasIdsCount = 1024;
		var textureInAtlasIds = new Array(textureInAtlasIdsCount);
		var lastTextureId = 0;
		for (var i = 0; i < 1024; i++) {
			if (this.game.blocktypes[i] != null) {
				var to_load = new Array(7);
				var to_loadLength = 7;
				{
					to_load[0] = this.game.blocktypes[i].textureIdLeft;
					to_load[1] = this.game.blocktypes[i].textureIdRight;
					to_load[2] = this.game.blocktypes[i].textureIdFront;
					to_load[3] = this.game.blocktypes[i].textureIdBack;
					to_load[4] = this.game.blocktypes[i].textureIdTop;
					to_load[5] = this.game.blocktypes[i].textureIdBottom;
					to_load[6] = this.game.blocktypes[i].textureIdForInventory;
				}
				for (var k = 0; k < to_loadLength; k++) {
					if (!this.contains(textureInAtlasIds, textureInAtlasIdsCount, to_load[k])) {
						textureInAtlasIds[lastTextureId++] = to_load[k];
					}
				}
			}
		}
		this.game.d_Data.useBlockTypes(this.game.blocktypes, 1024);
		for (var i = 0; i < 1024; i++) {
			var b = this.game.blocktypes[i];
			if (b == null) {
				continue;
			}
			if (textureInAtlasIds != null) {
				this.game.textureId[i][0] = this.indexOf(textureInAtlasIds, textureInAtlasIdsCount, b.textureIdTop);
				this.game.textureId[i][1] = this.indexOf(textureInAtlasIds, textureInAtlasIdsCount, b.textureIdBottom);
				this.game.textureId[i][2] = this.indexOf(textureInAtlasIds, textureInAtlasIdsCount, b.textureIdFront);
				this.game.textureId[i][3] = this.indexOf(textureInAtlasIds, textureInAtlasIdsCount, b.textureIdBack);
				this.game.textureId[i][4] = this.indexOf(textureInAtlasIds, textureInAtlasIdsCount, b.textureIdLeft);
				this.game.textureId[i][5] = this.indexOf(textureInAtlasIds, textureInAtlasIdsCount, b.textureIdRight);
				this.game.textureIdForInventory[i] = this.indexOf(textureInAtlasIds, textureInAtlasIdsCount, b.textureIdForInventory);
			}
		}
		this.game.useTerrainTextures(textureInAtlasIds, textureInAtlasIdsCount);
		this.game.handRedraw = true;
		this.game.redrawAllBlocks();
		break;
	case 65:
		this.game.chatLog("[GAME] Received server redirect");
		this.game.sendLeave(0);
		this.game.exitAndSwitchServer(packet.redirect);
		break;
	}
}

ProcessPacketTask.prototype.run = function() {
	this.processPacket(this.packet_);
}

function ProtoPlatform()
{
}

ProtoPlatform.arrayLength = function(a) {
	var len;
	
            len = a.length;
        return len;
}

ProtoPlatform.bytesToString = function(bytes, length) {
	var s;
	
            var arr = new Uint8Array(bytes.length);
	        for(var i = 0; i < bytes.length;i++)
	        {
		        arr[i] = bytes[i];
	        }
	        var encodedString = String.fromCharCode.apply(null, arr);
	        var decodedString = decodeURIComponent(escape(encodedString));
	        s = decodedString;
        return s;
}

ProtoPlatform.intToByte = function(a) {
	return a & 0xff;
}

ProtoPlatform.stringToBytes = function(s) {
	var b;
	
        // http://stackoverflow.com/a/18729931
	var str = s;
    var utf8 = [];
    for (var i=0; i < str.length; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 0x80) utf8.push(charcode);
        else if (charcode < 0x800) {
            utf8.push(0xc0 | (charcode >> 6), 
                      0x80 | (charcode & 0x3f));
        }
        else if (charcode < 0xd800 || charcode >= 0xe000) {
            utf8.push(0xe0 | (charcode >> 12), 
                      0x80 | ((charcode>>6) & 0x3f), 
                      0x80 | (charcode & 0x3f));
        }
        // surrogate pair
        else {
            i++;
            // UTF-16 encodes 0x10000-0x10FFFF by
            // subtracting 0x10000 and splitting the
            // 20 bits of 0x0-0xFFFFF into two halves
            charcode = 0x10000 + (((charcode & 0x3ff)<<10)
                      | (str.charCodeAt(i) & 0x3ff))
            utf8.push(0xf0 | (charcode >>18), 
                      0x80 | ((charcode>>12) & 0x3f), 
                      0x80 | ((charcode>>6) & 0x3f), 
                      0x80 | (charcode & 0x3f));
        }
    }
        b = utf8;
        return b;
}

ProtoPlatform.logical_right_shift = function(x, n) {
	var mask = ~(-1 << n) << 32 - n;
	return ~mask & (x >> n | mask);
}

function ProtocolParser()
{
}

ProtocolParser.readBool = function(stream) {
	var b = stream.readByte();
	if (b < 0)
		return false;
	if (b == 1)
		return true;
	if (b == 0)
		return false;
	return false;
}

ProtocolParser.readBytes = function(stream) {
	var length = ProtocolParser.readUInt32(stream);
	var buffer = new Uint8Array(new ArrayBuffer(length));
	var read = 0;
	while (read < length) {
		var r = stream.read(buffer, read, length - read);
		if (r == 0)
			return null;
		read += r;
	}
	return buffer;
}

ProtocolParser.readInt32 = function(stream) {
	return ProtocolParser.readUInt64(stream);
}

ProtocolParser.readInt64 = function(stream) {
	return ProtocolParser.readUInt64(stream);
}

ProtocolParser.readKey = function(stream) {
	var n = ProtocolParser.readUInt32(stream);
	return Key.create(n >> 3, n & 7);
}

ProtocolParser.readKey_ = function(firstByte, stream) {
	if (firstByte < 128)
		return Key.create(firstByte >> 3, firstByte & 7);
	var fieldID = ProtocolParser.readUInt32(stream) << 4 | firstByte >> 3 & 15;
	return Key.create(fieldID, firstByte & 7);
}

ProtocolParser.readSkipVarInt = function(stream) {
	while (true) {
		var b = stream.readByte();
		if (b < 0)
			return;
		if ((b & 128) == 0)
			return;
	}
}

ProtocolParser.readString = function(stream) {
	var bytes = ProtocolParser.readBytes(stream);
	return ProtoPlatform.bytesToString(bytes, 0);
}

ProtocolParser.readUInt32 = function(stream) {
	var b;
	var val = 0;
	for (var n = 0; n < 5; n++) {
		b = stream.readByte();
		if (b < 0)
			return 0;
		if (n == 4 && (b & 240) != 0)
			return 0;
		if ((b & 128) == 0)
			return val | b << 7 * n;
		val |= (b & 127) << 7 * n;
	}
	return 0;
}

ProtocolParser.readUInt64 = function(stream) {
	var b;
	var val = 0;
	for (var n = 0; n < 10; n++) {
		b = stream.readByte();
		if (b < 0)
			return 0;
		if (n == 9 && (b & 254) != 0)
			return 0;
		if ((b & 128) == 0)
			return val | b << 7 * n;
		val |= (b & 127) << 7 * n;
	}
	return 0;
}

ProtocolParser.readValueBytes = function(stream, key) {
	var b;
	var offset = 0;
	switch (key.getWireType()) {
	case 5:
		b = new Uint8Array(new ArrayBuffer(4));
		while (offset < 4)
			offset += stream.read(b, offset, 4 - offset);
		return b;
	case 1:
		b = new Uint8Array(new ArrayBuffer(8));
		while (offset < 8)
			offset += stream.read(b, offset, 8 - offset);
		return b;
	case 2:
		var length = ProtocolParser.readUInt32(stream);
		var ms = new CitoMemoryStream();
		{
			ProtocolParser.writeUInt32(ms, length);
			b = new Uint8Array(new ArrayBuffer(length + ms.length()));
			var arr = ms.toArray();
			for (var i = 0; i < ProtoPlatform.arrayLength(arr); i++) {
				b[i] = arr[i];
			}
			offset = ms.length();
		}
		while (offset < ProtoPlatform.arrayLength(b))
			offset += stream.read(b, offset, ProtoPlatform.arrayLength(b) - offset);
		return b;
	case 0:
		return ProtocolParser.readVarIntBytes(stream);
	default:
		return null;
	}
}

ProtocolParser.readVarIntBytes = function(stream) {
	var buffer = new Uint8Array(new ArrayBuffer(10));
	var offset = 0;
	while (true) {
		var b = stream.readByte();
		if (b < 0)
			return null;
		buffer[offset] = b & 0xff;
		offset += 1;
		if ((b & 128) == 0)
			break;
		if (offset >= ProtoPlatform.arrayLength(buffer))
			return null;
	}
	var ret = new Uint8Array(new ArrayBuffer(offset));
	for (var i = 0; i < offset; i++) {
		ret[i] = buffer[i];
	}
	return ret;
}

ProtocolParser.readZInt32 = function(stream) {
	var val = ProtocolParser.readUInt32(stream);
	return val >> 1 ^ val << 31 >> 31;
}

ProtocolParser.readZInt64 = function(stream) {
	var val = ProtocolParser.readUInt64(stream);
	return val >> 1 ^ val << 63 >> 63;
}

ProtocolParser.skipBytes = function(stream) {
	var length = ProtocolParser.readUInt32(stream);
	if (stream.canSeek())
		stream.seek(length, CitoSeekOrigin.CURRENT);
	else
		ProtocolParser.readBytes(stream);
}

ProtocolParser.skipKey = function(stream, key) {
	switch (key.getWireType()) {
	case 5:
		stream.seek(4, CitoSeekOrigin.CURRENT);
		return;
	case 1:
		stream.seek(8, CitoSeekOrigin.CURRENT);
		return;
	case 2:
		stream.seek(ProtocolParser.readUInt32(stream), CitoSeekOrigin.CURRENT);
		return;
	case 0:
		ProtocolParser.readSkipVarInt(stream);
		return;
	default:
		return;
	}
}

ProtocolParser.writeBool = function(stream, val) {
	var ret = 0;
	if (val) {
		ret = 1;
	}
	stream.writeByte(ret);
}

ProtocolParser.writeBytes = function(stream, val) {
	ProtocolParser.writeUInt32_(stream, ProtoPlatform.arrayLength(val));
	stream.write(val, 0, ProtoPlatform.arrayLength(val));
}

ProtocolParser.writeInt32 = function(stream, val) {
	ProtocolParser.writeUInt64(stream, val);
}

ProtocolParser.writeInt64 = function(stream, val) {
	ProtocolParser.writeUInt64(stream, val);
}

ProtocolParser.writeKey = function(stream, key) {
	var n = key.getField() << 3 | key.getWireType();
	ProtocolParser.writeUInt32_(stream, n);
}

ProtocolParser.writeString = function(stream, val) {
	ProtocolParser.writeBytes(stream, ProtoPlatform.stringToBytes(val));
}

ProtocolParser.writeUInt32 = function(ms, length) {
}

ProtocolParser.writeUInt32_ = function(stream, val) {
	var buffer = new Uint8Array(new ArrayBuffer(5));
	var count = 0;
	while (true) {
		buffer[count] = val & 127 & 0xff;
		val = val >> 7;
		if (val == 0)
			break;
		buffer[count] |= 128;
		count += 1;
	}
	stream.write(buffer, 0, count + 1);
}

ProtocolParser.writeUInt64 = function(stream, val) {
	var buffer = new Uint8Array(new ArrayBuffer(10));
	var count = 0;
	while (true) {
		buffer[count] = val & 127 & 0xff;
		val = ProtoPlatform.logical_right_shift(val, 7);
		if (val == 0)
			break;
		buffer[count] |= 128;
		count += 1;
	}
	stream.write(buffer, 0, count + 1);
}

ProtocolParser.writeZInt32 = function(stream, val) {
	ProtocolParser.writeUInt32_(stream, val << 1 ^ val >> 31);
}

ProtocolParser.writeZInt64 = function(stream, val) {
	ProtocolParser.writeUInt64(stream, val << 1 ^ val >> 63);
}

function QuadModelData()
{
}

QuadModelData.getQuadModelData = function() {
	var m = new ModelData();
	var xyz = new Float32Array(new ArrayBuffer(12 << 2));
	for (var i = 0; i < 12; i++) {
		xyz[i] = QuadModelData.CI_CONST_ARRAY_1[i];
	}
	m.setXyz(xyz);
	var uv = new Float32Array(new ArrayBuffer(8 << 2));
	for (var i = 0; i < 8; i++) {
		uv[i] = QuadModelData.CI_CONST_ARRAY_2[i];
	}
	m.setUv(uv);
	m.setVerticesCount(4);
	m.setIndices(QuadModelData.CI_CONST_ARRAY_3);
	m.setIndicesCount(6);
	return m;
}

QuadModelData.getQuadModelData2 = function(sx, sy, sw, sh, dx, dy, dw, dh, r, g, b, a) {
	var m = new ModelData();
	var xyz = new Float32Array(new ArrayBuffer(12 << 2));
	xyz[0] = dx;
	xyz[1] = dy;
	xyz[2] = 0;
	xyz[3] = dx + dw;
	xyz[4] = dy;
	xyz[5] = 0;
	xyz[6] = dx + dw;
	xyz[7] = dy + dh;
	xyz[8] = 0;
	xyz[9] = dx;
	xyz[10] = dy + dh;
	xyz[11] = 0;
	m.setXyz(xyz);
	var uv = new Float32Array(new ArrayBuffer(8 << 2));
	uv[0] = sx;
	uv[1] = sy;
	uv[2] = sx + sw;
	uv[3] = sy;
	uv[4] = sx + sw;
	uv[5] = sy + sh;
	uv[6] = sx;
	uv[7] = sy + sh;
	m.setUv(uv);
	var rgba = new Uint8Array(new ArrayBuffer(16));
	for (var i = 0; i < 4; i++) {
		rgba[i * 4 + 0] = r;
		rgba[i * 4 + 1] = g;
		rgba[i * 4 + 2] = b;
		rgba[i * 4 + 3] = a;
	}
	m.setRgba(rgba);
	m.setVerticesCount(4);
	m.setIndices(QuadModelData.CI_CONST_ARRAY_3);
	m.setIndicesCount(6);
	return m;
}
QuadModelData.CI_CONST_ARRAY_1 = [ -1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0 ];
QuadModelData.CI_CONST_ARRAY_2 = [ 0, 0, 1, 0, 1, 1, 0, 1 ];
QuadModelData.CI_CONST_ARRAY_3 = [ 0, 1, 2, 0, 2, 3 ];

function Quat()
{
}

Quat.add = function(output, a, b) {
	return Vec4.add(output, a, b);
}

Quat.calculateW = function(output, a) {
	var x = a[0];
	var y = a[1];
	var z = a[2];
	output[0] = x;
	output[1] = y;
	output[2] = z;
	var one = 1;
	output[3] = -Platform.sqrt(GlMatrixMath.abs(one - x * x - y * y - z * z));
	return output;
}

Quat.cloneIt = function(a) {
	return Vec4.cloneIt(a);
}

Quat.prototype.conjugate = function(output, a) {
	output[0] = -a[0];
	output[1] = -a[1];
	output[2] = -a[2];
	output[3] = a[3];
	return output;
}

Quat.copy = function(output, a) {
	return Vec4.copy(output, a);
}

Quat.create = function() {
	var output = new Float32Array(new ArrayBuffer(4 << 2));
	output[0] = 0;
	output[1] = 0;
	output[2] = 0;
	output[3] = 1;
	return output;
}

Quat.dot = function(a, b) {
	return Vec4.dot(a, b);
}

Quat.fromMat3 = function(output, m) {
	var fTrace = m[0] + m[4] + m[8];
	var fRoot;
	var zero = 0;
	var one = 1;
	var half = one / (2);
	if (fTrace > zero) {
		fRoot = Platform.sqrt(fTrace + one);
		output[3] = half * fRoot;
		fRoot = half / (fRoot);
		output[0] = (m[7] - m[5]) * fRoot;
		output[1] = (m[2] - m[6]) * fRoot;
		output[2] = (m[3] - m[1]) * fRoot;
	}
	else {
		var i = 0;
		if (m[4] > m[0])
			i = 1;
		if (m[8] > m[i * 3 + i])
			i = 2;
		var j = (i + 1) % 3;
		var k = (i + 2) % 3;
		fRoot = Platform.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + one);
		output[i] = half * fRoot;
		fRoot = half / (fRoot);
		output[3] = (m[k * 3 + j] - m[j * 3 + k]) * fRoot;
		output[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
		output[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
	}
	return output;
}

Quat.fromValues = function(x, y, z, w) {
	return Vec4.fromValues(x, y, z, w);
}

Quat.identity_ = function(output) {
	output[0] = 0;
	output[1] = 0;
	output[2] = 0;
	output[3] = 1;
	return output;
}

Quat.prototype.invert = function(output, a) {
	var a0 = a[0];
	var a1 = a[1];
	var a2 = a[2];
	var a3 = a[3];
	var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
	var one = 1;
	var invDot = dot != 0 ? one / (dot) : 0;
	output[0] = -a0 * invDot;
	output[1] = -a1 * invDot;
	output[2] = -a2 * invDot;
	output[3] = a3 * invDot;
	return output;
}

Quat.len = function(a) {
	return Quat.length_(a);
}

Quat.length_ = function(a) {
	return Vec4.length_(a);
}

Quat.lerp = function(output, a, b, t) {
	return Vec4.lerp(output, a, b, t);
}

Quat.mul = function(output, a, b) {
	return Quat.multiply(output, a, b);
}

Quat.multiply = function(output, a, b) {
	var ax = a[0];
	var ay = a[1];
	var az = a[2];
	var aw = a[3];
	var bx = b[0];
	var by = b[1];
	var bz = b[2];
	var bw = b[3];
	output[0] = ax * bw + aw * bx + ay * bz - az * by;
	output[1] = ay * bw + aw * by + az * bx - ax * bz;
	output[2] = az * bw + aw * bz + ax * by - ay * bx;
	output[3] = aw * bw - ax * bx - ay * by - az * bz;
	return output;
}

Quat.normalize = function(output, a) {
	return Vec4.normalize(output, a);
}

Quat.rotateX = function(output, a, rad) {
	rad /= 2;
	var ax = a[0];
	var ay = a[1];
	var az = a[2];
	var aw = a[3];
	var bx = Platform.sin(rad);
	var bw = Platform.cos(rad);
	output[0] = ax * bw + aw * bx;
	output[1] = ay * bw + az * bx;
	output[2] = az * bw - ay * bx;
	output[3] = aw * bw - ax * bx;
	return output;
}

Quat.rotateY = function(output, a, rad) {
	rad /= 2;
	var ax = a[0];
	var ay = a[1];
	var az = a[2];
	var aw = a[3];
	var by = Platform.sin(rad);
	var bw = Platform.cos(rad);
	output[0] = ax * bw - az * by;
	output[1] = ay * bw + aw * by;
	output[2] = az * bw + ax * by;
	output[3] = aw * bw - ay * by;
	return output;
}

Quat.rotateZ = function(output, a, rad) {
	rad /= 2;
	var ax = a[0];
	var ay = a[1];
	var az = a[2];
	var aw = a[3];
	var bz = Platform.sin(rad);
	var bw = Platform.cos(rad);
	output[0] = ax * bw + ay * bz;
	output[1] = ay * bw - ax * bz;
	output[2] = az * bw + aw * bz;
	output[3] = aw * bw - az * bz;
	return output;
}

Quat.rotationTo = function(output, a, b) {
	var tmpvec3 = Vec3.create();
	var xUnitVec3 = Vec3.fromValues(1, 0, 0);
	var yUnitVec3 = Vec3.fromValues(0, 1, 0);
	var dot = Vec3.dot(a, b);
	var nines = 999999;
	nines /= 1000000;
	var epsilon = 1;
	epsilon /= 1000000;
	if (dot < -nines) {
		Vec3.cross(tmpvec3, xUnitVec3, a);
		if (Vec3.length_(tmpvec3) < epsilon)
			Vec3.cross(tmpvec3, yUnitVec3, a);
		Vec3.normalize(tmpvec3, tmpvec3);
		Quat.setAxisAngle(output, tmpvec3, GlMatrixMath.pI());
		return output;
	}
	else if (dot > nines) {
		output[0] = 0;
		output[1] = 0;
		output[2] = 0;
		output[3] = 1;
		return output;
	}
	else {
		Vec3.cross(tmpvec3, a, b);
		output[0] = tmpvec3[0];
		output[1] = tmpvec3[1];
		output[2] = tmpvec3[2];
		output[3] = 1 + dot;
		return Quat.normalize(output, output);
	}
}

Quat.scale = function(output, a, b) {
	return Vec4.scale(output, a, b);
}

Quat.set = function(output, x, y, z, w) {
	return Vec4.set(output, x, y, z, w);
}

Quat.setAxes = function(output, view, right, up) {
	var matr = Mat3.create();
	matr[0] = right[0];
	matr[3] = right[1];
	matr[6] = right[2];
	matr[1] = up[0];
	matr[4] = up[1];
	matr[7] = up[2];
	matr[2] = view[0];
	matr[5] = view[1];
	matr[8] = view[2];
	return Quat.normalize(output, Quat.fromMat3(output, matr));
}

Quat.setAxisAngle = function(output, axis, rad) {
	rad = rad / (2);
	var s = Platform.sin(rad);
	output[0] = s * axis[0];
	output[1] = s * axis[1];
	output[2] = s * axis[2];
	output[3] = Platform.cos(rad);
	return output;
}

Quat.slerp = function(output, a, b, t) {
	var ax = a[0];
	var ay = a[1];
	var az = a[2];
	var aw = a[3];
	var bx = b[0];
	var by = b[1];
	var bz = b[2];
	var bw = b[3];
	var omega;
	var cosom;
	var sinom;
	var scale0;
	var scale1;
	cosom = ax * bx + ay * by + az * bz + aw * bw;
	if (cosom < 0) {
		cosom = -cosom;
		bx = -bx;
		by = -by;
		bz = -bz;
		bw = -bw;
	}
	var one = 1;
	var epsilon = one / (1000000);
	if (one - cosom > epsilon) {
		omega = Platform.acos(cosom);
		sinom = Platform.sin(omega);
		scale0 = Platform.sin((one - t) * omega) / (sinom);
		scale1 = Platform.sin(t * omega) / (sinom);
	}
	else {
		scale0 = one - t;
		scale1 = t;
	}
	output[0] = scale0 * ax + scale1 * bx;
	output[1] = scale0 * ay + scale1 * by;
	output[2] = scale0 * az + scale1 * bz;
	output[3] = scale0 * aw + scale1 * bw;
	return output;
}

Quat.sqrLen = function(a) {
	return Quat.squaredLength(a);
}

Quat.squaredLength = function(a) {
	return Vec4.squaredLength(a);
}

Quat.prototype.f = function() {
}

function QueryClient()
{
	this.p = null;
	this.queryPerformed = false;
	this.querySuccess = false;
	this.result = null;
	this.serverMessage = null;
	this.result = new QueryResult();
	this.querySuccess = false;
	this.queryPerformed = false;
}

QueryClient.prototype.getQuerySuccess = function() {
	return this.querySuccess;
}

QueryClient.prototype.getResult = function() {
	return this.result;
}

QueryClient.prototype.getServerMessage = function() {
	return this.serverMessage;
}

QueryClient.prototype.performQuery = function(ip, port) {
	this.serverMessage = "";
	var client;
	if (this.p.enetAvailable()) {
		var c = new EnetNetClient();
		c.setPlatform(this.p);
		client = c;
	}
	else {
		var c = new TcpNetClient();
		c.setPlatform(this.p);
		client = c;
	}
	client.start();
	client.connect(ip, port);
	this.sendRequest(client);
	this.readPacket(client);
	this.queryPerformed = true;
}

QueryClient.prototype.readPacket = function(client) {
	var success = false;
	var started = this.p.timeMillisecondsFromStart();
	var timeout = 2000;
	while (this.p.timeMillisecondsFromStart() < started + timeout) {
		if (success) {
			this.querySuccess = true;
			return;
		}
		var msg;
		msg = client.readMessage();
		if (msg == null) {
			continue;
		}
		var packet = new Packet_Server();
		Packet_ServerSerializer.deserializeBuffer(msg.message, msg.messageLength, packet);
		switch (packet.id) {
		case 64:
			this.result.name = packet.queryAnswer.name;
			this.result.mOTD = packet.queryAnswer.mOTD;
			this.result.playerCount = packet.queryAnswer.playerCount;
			this.result.maxPlayers = packet.queryAnswer.maxPlayers;
			this.result.playerList = packet.queryAnswer.playerList;
			this.result.port = packet.queryAnswer.port;
			this.result.gameMode = packet.queryAnswer.gameMode;
			this.result.password = packet.queryAnswer.password;
			this.result.publicHash = packet.queryAnswer.publicHash;
			this.result.serverVersion = packet.queryAnswer.serverVersion;
			this.result.mapSizeX = packet.queryAnswer.mapSizeX;
			this.result.mapSizeY = packet.queryAnswer.mapSizeY;
			this.result.mapSizeZ = packet.queryAnswer.mapSizeZ;
			this.result.serverThumbnail = packet.queryAnswer.serverThumbnail;
			success = true;
			continue;
		case 14:
			this.serverMessage = packet.disconnectPlayer.disconnectReason;
			return;
		default:
			continue;
		}
	}
	this.serverMessage = "Timeout while querying server!";
}

QueryClient.prototype.sendRequest = function(client) {
	var pp = ClientPackets.serverQuery();
	var ms = new CitoMemoryStream();
	Packet_ClientSerializer.serialize(ms, pp);
	var data = ms.toArray();
	var msg = new INetOutgoingMessage();
	msg.write(data, ms.length());
	client.sendMessage(msg, MyNetDeliveryMethod.RELIABLE_ORDERED);
}

QueryClient.prototype.setPlatform = function(p_) {
	this.p = p_;
}

function QueryResult()
{
	this.gameMode = null;
	this.mOTD = null;
	this.mapSizeX = 0;
	this.mapSizeY = 0;
	this.mapSizeZ = 0;
	this.maxPlayers = 0;
	this.name = null;
	this.password = false;
	this.playerCount = 0;
	this.playerList = null;
	this.port = 0;
	this.publicHash = null;
	this.serverThumbnail = null;
	this.serverVersion = null;
}

function QueueAction()
{
	this.count = 0;
	this.items = null;
	this.max = 0;
	this.start = 0;
	this.start(128);
}

QueueAction.prototype.count = function() {
	return this.count;
}

QueueAction.create = function(max_) {
	var queue = new QueueAction();
	queue.start(max_);
	return queue;
}

QueueAction.prototype.dequeue = function() {
	var ret = this.items[this.start];
	this.items[this.start] = null;
	this.start++;
	this.start = this.start % this.max;
	this.count--;
	return ret;
}

QueueAction.prototype.enqueue = function(value) {
	if (this.count == this.max) {
		this.resize(this.max * 2);
	}
	var pos = this.start + this.count;
	pos = pos % this.max;
	this.count++;
	this.items[pos] = value;
}

QueueAction.prototype.resize = function(newSize) {
	var items2 = new Array(newSize);
	for (var i = 0; i < this.max; i++) {
		items2[i] = this.items[(this.start + i) % this.max];
	}
	this.items = items2;
	this.start = 0;
	this.max = newSize;
}

QueueAction.prototype.start = function(max_) {
	this.max = max_;
	this.items = new Array(max_);
	this.count = 0;
}

function QueueByte()
{
	this.count = 0;
	this.items = null;
	this.max = 0;
	this.start = 0;
	this.max = 5242880;
	this.items = new Uint8Array(new ArrayBuffer(this.max));
}

QueueByte.prototype.dequeue = function() {
	var ret = this.items[this.start];
	this.start++;
	this.start = this.start % this.max;
	this.count--;
	return ret;
}

QueueByte.prototype.dequeueRange = function(data, length) {
	for (var i = 0; i < length; i++) {
		data[i] = this.dequeue();
	}
}

QueueByte.prototype.enqueue = function(value) {
	var pos = this.start + this.count;
	pos = pos % this.max;
	this.count++;
	this.items[pos] = value;
}

QueueByte.prototype.getCount = function() {
	return this.count;
}

QueueByte.prototype.peekRange = function(data, length) {
	for (var i = 0; i < length; i++) {
		data[i] = this.items[(this.start + i) % this.max];
	}
}

function QueueByteArray()
{
	this.count = 0;
	this.items = null;
	this.itemsSize = 0;
	this.items = new Array(1);
	this.itemsSize = 1;
	this.count = 0;
}

QueueByteArray.prototype.count = function() {
	return this.count;
}

QueueByteArray.prototype.dequeue = function() {
	var ret = this.items[0];
	for (var i = 0; i < this.count - 1; i++) {
		this.items[i] = this.items[i + 1];
	}
	this.count--;
	return ret;
}

QueueByteArray.prototype.enqueue = function(p) {
	if (this.count == this.itemsSize) {
		var items2 = new Array(this.itemsSize * 2);
		for (var i = 0; i < this.itemsSize; i++) {
			items2[i] = this.items[i];
		}
		this.itemsSize = this.itemsSize * 2;
		this.items = items2;
	}
	this.items[this.count++] = p;
}

function QueueINetOutgoingMessage()
{
	this.count = 0;
	this.items = null;
	this.itemsSize = 0;
	this.items = new Array(1);
	this.itemsSize = 1;
	this.count = 0;
}

QueueINetOutgoingMessage.prototype.count = function() {
	return this.count;
}

QueueINetOutgoingMessage.prototype.dequeue = function() {
	var ret = this.items[0];
	for (var i = 0; i < this.count - 1; i++) {
		this.items[i] = this.items[i + 1];
	}
	this.count--;
	return ret;
}

QueueINetOutgoingMessage.prototype.enqueue = function(p) {
	if (this.count == this.itemsSize) {
		var items2 = new Array(this.itemsSize * 2);
		for (var i = 0; i < this.itemsSize; i++) {
			items2[i] = this.items[i];
		}
		this.itemsSize = this.itemsSize * 2;
		this.items = items2;
	}
	this.items[this.count++] = p;
}

function QueueNetIncomingMessage()
{
	this.count = 0;
	this.items = null;
	this.itemsSize = 0;
	this.items = new Array(1);
	this.itemsSize = 1;
	this.count = 0;
}

QueueNetIncomingMessage.prototype.count = function() {
	return this.count;
}

QueueNetIncomingMessage.prototype.dequeue = function() {
	var ret = this.items[0];
	for (var i = 0; i < this.count - 1; i++) {
		this.items[i] = this.items[i + 1];
	}
	this.count--;
	return ret;
}

QueueNetIncomingMessage.prototype.enqueue = function(p) {
	if (this.count == this.itemsSize) {
		var items2 = new Array(this.itemsSize * 2);
		for (var i = 0; i < this.itemsSize; i++) {
			items2[i] = this.items[i];
		}
		this.itemsSize = this.itemsSize * 2;
		this.items = items2;
	}
	this.items[this.count++] = p;
}

var RailDirection = {
	HORIZONTAL : 0,
	VERTICAL : 1,
	UP_LEFT : 2,
	UP_RIGHT : 3,
	DOWN_LEFT : 4,
	DOWN_RIGHT : 5
}

function RailDirectionFlags()
{
}
RailDirectionFlags.CORNERS = 60;
RailDirectionFlags.DOWN_LEFT = 16;
RailDirectionFlags.DOWN_RIGHT = 32;
RailDirectionFlags.FULL = 63;
RailDirectionFlags.HORIZONTAL = 1;
RailDirectionFlags.NONE = 0;
RailDirectionFlags.TWO_HORIZONTAL_VERTICAL = 3;
RailDirectionFlags.UP_LEFT = 4;
RailDirectionFlags.UP_RIGHT = 8;
RailDirectionFlags.VERTICAL = 2;

function RailDirectionFlagsEnum()
{
}
RailDirectionFlagsEnum.DOWN_LEFT = 16;
RailDirectionFlagsEnum.DOWN_RIGHT = 32;
RailDirectionFlagsEnum.HORIZONTAL = 1;
RailDirectionFlagsEnum.NONE = 0;
RailDirectionFlagsEnum.UP_LEFT = 4;
RailDirectionFlagsEnum.UP_RIGHT = 8;
RailDirectionFlagsEnum.VERTICAL = 2;

function RailMapUtil()
{
	this.game = null;
}

RailMapUtil.prototype.getRailSlope = function(x, y, z) {
	var tiletype = this.game.map.getBlock(x, y, z);
	var railDirectionFlags = this.game.blocktypes[tiletype].rail;
	var blocknear;
	if (x < this.game.map.mapSizeX - 1) {
		blocknear = this.game.map.getBlock(x + 1, y, z);
		if (railDirectionFlags == 1 && blocknear != 0 && this.game.blocktypes[blocknear].rail == 0) {
			return RailSlope.TWO_RIGHT_RAISED;
		}
	}
	if (x > 0) {
		blocknear = this.game.map.getBlock(x - 1, y, z);
		if (railDirectionFlags == 1 && blocknear != 0 && this.game.blocktypes[blocknear].rail == 0) {
			return RailSlope.TWO_LEFT_RAISED;
		}
	}
	if (y > 0) {
		blocknear = this.game.map.getBlock(x, y - 1, z);
		if (railDirectionFlags == 2 && blocknear != 0 && this.game.blocktypes[blocknear].rail == 0) {
			return RailSlope.TWO_UP_RAISED;
		}
	}
	if (y < this.game.map.mapSizeY - 1) {
		blocknear = this.game.map.getBlock(x, y + 1, z);
		if (railDirectionFlags == 2 && blocknear != 0 && this.game.blocktypes[blocknear].rail == 0) {
			return RailSlope.TWO_DOWN_RAISED;
		}
	}
	return RailSlope.FLAT;
}

var RailSlope = {
	FLAT : 0,
	TWO_LEFT_RAISED : 1,
	TWO_RIGHT_RAISED : 2,
	TWO_UP_RAISED : 3,
	TWO_DOWN_RAISED : 4
}

function RailSlopeEnum()
{
}
RailSlopeEnum.FLAT = 0;
RailSlopeEnum.TWO_DOWN_RAISED = 4;
RailSlopeEnum.TWO_LEFT_RAISED = 1;
RailSlopeEnum.TWO_RIGHT_RAISED = 2;
RailSlopeEnum.TWO_UP_RAISED = 3;

function RandomCi()
{
}

function RectFRef()
{
	this.h = null;
	this.w = null;
	this.x = null;
	this.y = null;
}

RectFRef.prototype.bottom = function() {
	return this.y + this.h;
}

RectFRef.create = function(x_, y_, w_, h_) {
	var r = new RectFRef();
	r.x = x_;
	r.y = y_;
	r.w = w_;
	r.h = h_;
	return r;
}

RectFRef.prototype.left = function() {
	return this.x;
}

RectFRef.prototype.right = function() {
	return this.x + this.w;
}

RectFRef.prototype.top = function() {
	return this.y;
}

function RectangleFloat()
{
	this.height = null;
	this.width = null;
	this.x = null;
	this.y = null;
}

RectangleFloat.prototype.bottom = function() {
	return this.y + this.height;
}

RectangleFloat.create = function(x_, y_, width_, height_) {
	var r = new RectangleFloat();
	r.x = x_;
	r.y = y_;
	r.width = width_;
	r.height = height_;
	return r;
}

function RenderHintEnum()
{
}
RenderHintEnum.FAST = 0;
RenderHintEnum.NICE = 1;

function RenderedChunk()
{
	this.dirty = false;
	this.ids = null;
	this.idsCount = 0;
	this.light = null;
	this.dirty = true;
}

function Screen()
{
	this.widgetCount = 0;
	this.menu = null;
	this.widgets = null;
	this.widgetCount = 64;
	this.widgets = new Array(this.widgetCount);
}

Screen.prototype.allLoseFocus = function() {
	for (var i = 0; i < this.widgetCount; i++) {
		var w = this.widgets[i];
		if (w != null) {
			w.loseFocus();
		}
	}
}

Screen.prototype.drawWidgets = function() {
	for (var i = 0; i < this.widgetCount; i++) {
		var w = this.widgets[i];
		if (w != null) {
			if (!w.visible) {
				continue;
			}
			var text = w.text;
			if (w.selected) {
				text = StringTools.stringAppend(this.menu.p, "&2", text);
			}
			if (w.type == WidgetType.BUTTON) {
				if (w.buttonStyle == ButtonStyle.TEXT) {
					if (w.image != null) {
						this.menu.draw2dQuad(this.menu.getTexture(w.image), w.x, w.y, w.sizex, w.sizey);
					}
					this.menu.drawText(text, w.font, w.x, w.y + w.sizey / (2), TextAlign.LEFT, TextBaseline.MIDDLE);
				}
				else if (w.buttonStyle == ButtonStyle.BUTTON) {
					this.menu.drawButton(text, w.font, w.x, w.y, w.sizex, w.sizey, w.hover || w.hasKeyboardFocus);
					if (w.description != null) {
						this.menu.drawText(w.description, w.font, w.x, w.y + w.sizey / (2), TextAlign.RIGHT, TextBaseline.MIDDLE);
					}
				}
			}
			if (w.type == WidgetType.TEXTBOX) {
				if (w.password) {
					text = this.menu.charRepeat(42, this.menu.stringLength(w.text));
				}
				if (w.editing) {
					text = StringTools.stringAppend(this.menu.p, text, "_");
				}
				if (w.buttonStyle == ButtonStyle.TEXT) {
					if (w.image != null) {
						this.menu.draw2dQuad(this.menu.getTexture(w.image), w.x, w.y, w.sizex, w.sizey);
					}
					this.menu.drawText(text, w.font, w.x, w.y, TextAlign.LEFT, TextBaseline.TOP);
				}
				else {
					this.menu.drawButton(text, w.font, w.x, w.y, w.sizex, w.sizey, w.hover || w.editing || w.hasKeyboardFocus);
				}
				if (w.description != null) {
					this.menu.drawText(w.description, w.font, w.x, w.y + w.sizey / (2), TextAlign.RIGHT, TextBaseline.MIDDLE);
				}
			}
		}
	}
}

Screen.prototype.keyDown = function(e) {
	for (var i = 0; i < this.widgetCount; i++) {
		var w = this.widgets[i];
		if (w == null) {
			continue;
		}
		if (w.hasKeyboardFocus) {
			if (e.getKeyCode() == 52 || e.getKeyCode() == 49) {
				if (w.type == WidgetType.BUTTON && e.getKeyCode() == 49) {
					this.onButton(w);
					return;
				}
				if (w.nextWidget != -1) {
					w.loseFocus();
					this.widgets[w.nextWidget].getFocus();
					return;
				}
			}
		}
		if (w.type == WidgetType.TEXTBOX) {
			if (w.editing) {
				var key = e.getKeyCode();
				if (e.getCtrlPressed() && key == 104) {
					if (this.menu.p.clipboardContainsText()) {
						w.text = StringTools.stringAppend(this.menu.p, w.text, this.menu.p.clipboardGetText());
					}
					return;
				}
				if (key == 53) {
					if (this.menu.stringLength(w.text) > 0) {
						w.text = StringTools.stringSubstring(this.menu.p, w.text, 0, this.menu.stringLength(w.text) - 1);
					}
					return;
				}
			}
		}
	}
}

Screen.prototype.keyPress = function(e) {
	for (var i = 0; i < this.widgetCount; i++) {
		var w = this.widgets[i];
		if (w != null) {
			if (w.type == WidgetType.TEXTBOX) {
				if (w.editing) {
					if (this.menu.p.isValidTypingChar(e.getKeyChar())) {
						w.text = StringTools.stringAppend(this.menu.p, w.text, this.menu.charToString(e.getKeyChar()));
					}
				}
			}
		}
	}
}

Screen.prototype.loadTranslations = function() {
}

Screen.prototype.mouseDown = function(x, y) {
	var editingChange = false;
	for (var i = 0; i < this.widgetCount; i++) {
		var w = this.widgets[i];
		if (w != null) {
			if (w.type == WidgetType.BUTTON) {
				w.pressed = this.pointInRect(x, y, w.x, w.y, w.sizex, w.sizey);
			}
			if (w.type == WidgetType.TEXTBOX) {
				w.pressed = this.pointInRect(x, y, w.x, w.y, w.sizex, w.sizey);
				var wasEditing = w.editing;
				w.editing = w.pressed;
				if (w.editing && !wasEditing) {
					this.menu.p.showKeyboard(true);
					editingChange = true;
				}
				if (!w.editing && wasEditing && !editingChange) {
					this.menu.p.showKeyboard(false);
				}
			}
			if (w.pressed) {
				this.allLoseFocus();
				w.getFocus();
			}
		}
	}
}

Screen.prototype.mouseMove = function(e) {
	if (e.getEmulated() && !e.getForceUsage()) {
		return;
	}
	for (var i = 0; i < this.widgetCount; i++) {
		var w = this.widgets[i];
		if (w != null) {
			w.hover = this.pointInRect(e.getX(), e.getY(), w.x, w.y, w.sizex, w.sizey);
		}
	}
}

Screen.prototype.mouseUp = function(x, y) {
	for (var i = 0; i < this.widgetCount; i++) {
		var w = this.widgets[i];
		if (w != null) {
			w.pressed = false;
		}
	}
	for (var i = 0; i < this.widgetCount; i++) {
		var w = this.widgets[i];
		if (w != null) {
			if (w.type == WidgetType.BUTTON) {
				if (this.pointInRect(x, y, w.x, w.y, w.sizex, w.sizey)) {
					this.onButton(w);
				}
			}
		}
	}
}

Screen.prototype.onBackPressed = function() {
}

Screen.prototype.onButton = function(w) {
}

Screen.prototype.onKeyDown = function(e) {
	this.keyDown(e);
}

Screen.prototype.onKeyPress = function(e) {
	this.keyPress(e);
}

Screen.prototype.onKeyUp = function(e) {
}

Screen.prototype.onMouseDown = function(e) {
	this.mouseDown(e.getX(), e.getY());
}

Screen.prototype.onMouseMove = function(e) {
	this.mouseMove(e);
}

Screen.prototype.onMouseUp = function(e) {
	this.mouseUp(e.getX(), e.getY());
}

Screen.prototype.onMouseWheel = function(e) {
}

Screen.prototype.onTouchEnd = function(e) {
	this.mouseUp(e.getX(), e.getY());
}

Screen.prototype.onTouchMove = function(e) {
}

Screen.prototype.onTouchStart = function(e) {
	this.mouseDown(e.getX(), e.getY());
}

Screen.prototype.render = function(dt) {
}

Screen.prototype.pointInRect = function(x, y, rx, ry, rw, rh) {
	return x >= rx && y >= ry && x < rx + rw && y < ry + rh;
}

function ScreenConnectToIp()
{
	this.back = null;
	this.buttonConnect = null;
	this.loaded = false;
	this.preferences_ip = null;
	this.preferences_port = null;
	this.textboxIp = null;
	this.textboxPort = null;
	this.title = null;
	this.buttonConnect = new MenuWidget();
	this.buttonConnect.text = "Connect";
	this.buttonConnect.type = WidgetType.BUTTON;
	this.buttonConnect.nextWidget = 3;
	this.textboxIp = new MenuWidget();
	this.textboxIp.type = WidgetType.TEXTBOX;
	this.textboxIp.text = "";
	this.textboxIp.description = "Ip";
	this.textboxIp.nextWidget = 2;
	this.textboxPort = new MenuWidget();
	this.textboxPort.type = WidgetType.TEXTBOX;
	this.textboxPort.text = "";
	this.textboxPort.description = "Port";
	this.textboxPort.nextWidget = 0;
	this.back = new MenuWidget();
	this.back.text = "Back";
	this.back.type = WidgetType.BUTTON;
	this.back.nextWidget = 1;
	this.title = "Connect to IP";
	this.widgets[0] = this.buttonConnect;
	this.widgets[1] = this.textboxIp;
	this.widgets[2] = this.textboxPort;
	this.widgets[3] = this.back;
	this.textboxIp.getFocus();
}
ScreenConnectToIp.prototype = new Screen();

ScreenConnectToIp.prototype.loadTranslations = function() {
	this.buttonConnect.text = this.menu.lang.get("MainMenu_ConnectToIpConnect");
	this.textboxIp.description = this.menu.lang.get("MainMenu_ConnectToIpIp");
	this.textboxPort.description = this.menu.lang.get("MainMenu_ConnectToIpPort");
	this.title = this.menu.lang.get("MainMenu_MultiplayerConnectIP");
}

ScreenConnectToIp.prototype.onBackPressed = function() {
	this.menu.startMultiplayer();
}

ScreenConnectToIp.prototype.onButton = function(w) {
	if (w == this.buttonConnect) {
		var ret = new FloatRef();
		if (!Game.stringEquals(this.textboxIp.text, "") && this.menu.p.floatTryParse(this.textboxPort.text, ret)) {
			this.menu.startLogin(null, this.textboxIp.text, this.menu.p.intParse(this.textboxPort.text));
		}
	}
	if (w == this.back) {
		this.onBackPressed();
	}
}

ScreenConnectToIp.prototype.render = function(dt) {
	if (!this.loaded) {
		this.preferences_ip = this.menu.p.getPreferences().getString("ConnectToIpIp", "127.0.0.1");
		this.preferences_port = this.menu.p.getPreferences().getString("ConnectToIpPort", "25565");
		this.textboxIp.text = this.preferences_ip;
		this.textboxPort.text = this.preferences_port;
		this.loaded = true;
	}
	if (this.textboxIp.text != this.preferences_ip || this.textboxPort.text != this.preferences_port) {
		this.preferences_ip = this.textboxIp.text;
		this.preferences_port = this.textboxPort.text;
		var preferences = this.menu.p.getPreferences();
		preferences.setString("ConnectToIpIp", this.preferences_ip);
		preferences.setString("ConnectToIpPort", this.preferences_port);
		this.menu.p.setPreferences(preferences);
	}
	var p = this.menu.p;
	var scale = this.menu.getScale();
	this.menu.drawBackground();
	var leftx = Math.floor(p.getCanvasWidth() / 2) - 400 * scale;
	var y = Math.floor(p.getCanvasHeight() / 2) - 250 * scale;
	this.menu.drawText(this.title, this.menu.fontMenuHeading, leftx, y + 50 * scale, TextAlign.LEFT, TextBaseline.TOP);
	this.textboxIp.x = leftx;
	this.textboxIp.y = y + 100 * scale;
	this.textboxIp.sizex = 256 * scale;
	this.textboxIp.sizey = 64 * scale;
	this.textboxPort.x = leftx;
	this.textboxPort.y = y + 200 * scale;
	this.textboxPort.sizex = 256 * scale;
	this.textboxPort.sizey = 64 * scale;
	this.buttonConnect.x = leftx;
	this.buttonConnect.y = y + 400 * scale;
	this.buttonConnect.sizex = 256 * scale;
	this.buttonConnect.sizey = 64 * scale;
	this.back.x = 40 * scale;
	this.back.y = p.getCanvasHeight() - 104 * scale;
	this.back.sizex = 256 * scale;
	this.back.sizey = 64 * scale;
	this.drawWidgets();
}

function ScreenGame()
{
	this.connectData = null;
	this.game = null;
	this.platform = null;
	this.serverSimple = null;
	this.serverSimpleMod = null;
	this.singleplayer = false;
	this.singleplayerSavePath = null;
	this.game = new Game();
}
ScreenGame.prototype = new Screen();

ScreenGame.prototype.connect = function(platform) {
	if (this.singleplayer) {
		if (platform.singlePlayerServerAvailable()) {
			platform.singlePlayerServerStart(this.singleplayerSavePath);
		}
		else {
			this.serverSimple = new ServerSimple();
			var network = platform.singlePlayerServerGetNetwork();
			network.start(platform.monitorCreate(), platform.monitorCreate());
			var server = new DummyNetServer();
			server.network = network;
			server.platform = platform;
			server.start();
			this.serverSimple.start(server, this.singleplayerSavePath, platform);
			this.serverSimpleMod = new ModServerSimple();
			this.serverSimpleMod.server = this.serverSimple;
			this.game.addMod(this.serverSimpleMod);
			platform.singlePlayerServerGetNetwork().serverReceiveBuffer.enqueue(new ByteArray());
		}
		this.connectData = new ConnectData();
		this.connectData.username = "Local";
		this.game.connectdata = this.connectData;
		var netclient = new DummyNetClient();
		netclient.setPlatform(platform);
		netclient.setNetwork(platform.singlePlayerServerGetNetwork());
		this.game.main = netclient;
	}
	else {
		this.game.connectdata = this.connectData;
		if (platform.enetAvailable()) {
			var client = new EnetNetClient();
			client.setPlatform(platform);
			this.game.main = client;
		}
		else if (platform.tcpAvailable()) {
			var client = new TcpNetClient();
			client.setPlatform(platform);
			this.game.main = client;
		}
		else if (platform.webSocketAvailable()) {
			var client = new WebSocketClient();
			client.setPlatform(platform);
			this.game.main = client;
		}
		else {
			platform.throwException("Network not implemented");
		}
	}
}

ScreenGame.prototype.onBackPressed = function() {
	this.game.onBackPressed();
}

ScreenGame.prototype.onKeyDown = function(e) {
	this.game.keyDown(e.getKeyCode());
}

ScreenGame.prototype.onKeyPress = function(e) {
	this.game.keyPress(e.getKeyChar());
}

ScreenGame.prototype.onKeyUp = function(e) {
	this.game.keyUp(e.getKeyCode());
}

ScreenGame.prototype.onMouseDown = function(e) {
	if (!this.game.platform.focused()) {
		return;
	}
	this.game.mouseDown(e);
}

ScreenGame.prototype.onMouseMove = function(e) {
	if (!this.game.platform.focused()) {
		return;
	}
	this.game.mouseMove(e);
}

ScreenGame.prototype.onMouseUp = function(e) {
	if (!this.game.platform.focused()) {
		return;
	}
	this.game.mouseUp(e);
}

ScreenGame.prototype.onMouseWheel = function(e) {
	this.game.mouseWheelChanged(e);
}

ScreenGame.prototype.onTouchEnd = function(e) {
	this.game.onTouchEnd(e);
}

ScreenGame.prototype.onTouchMove = function(e) {
	this.game.onTouchMove(e);
}

ScreenGame.prototype.onTouchStart = function(e) {
	this.game.onTouchStart(e);
}

ScreenGame.prototype.render = function(dt) {
	if (this.game.reconnect) {
		this.game.dispose();
		this.menu.startGame(this.singleplayer, this.singleplayerSavePath, this.connectData);
		return;
	}
	if (this.game.exitToMainMenu) {
		this.game.dispose();
		if (this.game.getRedirect() != null) {
			var qclient = new QueryClient();
			qclient.setPlatform(this.platform);
			qclient.performQuery(this.game.getRedirect().getIP(), this.game.getRedirect().getPort());
			if (qclient.queryPerformed && !qclient.querySuccess) {
				this.platform.messageBoxShowError(qclient.getServerMessage(), "Redirection error");
				this.menu.startMainMenu();
				return;
			}
			var qresult = qclient.getResult();
			var lic = new LoginClientCi();
			var lidata = new LoginData();
			var token = this.platform.stringSplit(qresult.publicHash, "=", new IntRef())[1];
			lic.login(this.platform, this.connectData.username, "", token, this.platform.getPreferences().getString("Password", ""), new LoginResultRef(), lidata);
			while (lic.loginResult.value == LoginResult.CONNECTING) {
				lic.update(this.platform);
			}
			if (!lidata.serverCorrect) {
				this.platform.messageBoxShowError("Invalid server address!", "Redirection error!");
				this.menu.startMainMenu();
			}
			else if (!lidata.passwordCorrect) {
				this.menu.startLogin(token, null, 0);
			}
			else if (lidata.serverAddress != null && lidata.serverAddress != "") {
				this.menu.connectToGame(lidata, this.connectData.username);
			}
		}
		else {
			this.menu.startMainMenu();
		}
		return;
	}
	this.game.onRenderFrame(dt);
}

ScreenGame.prototype.start = function(platform_, singleplayer_, singleplayerSavePath_, connectData_) {
	this.platform = platform_;
	this.singleplayer = singleplayer_;
	this.singleplayerSavePath = singleplayerSavePath_;
	this.connectData = connectData_;
	this.game.platform = this.platform;
	this.game.issingleplayer = this.singleplayer;
	this.game.assets = this.menu.assets;
	this.game.assetsLoadProgress = this.menu.assetsLoadProgress;
	this.game.start();
	this.connect(this.platform);
}

function ScreenLogin()
{
	this.back = null;
	this.createAccount = null;
	this.createAccountPassword = null;
	this.createAccountRememberMe = null;
	this.createAccountUsername = null;
	this.fontLoginMessage = null;
	this.login = null;
	this.loginPassword = null;
	this.loginRememberMe = null;
	this.loginResult = null;
	this.loginResultData = null;
	this.loginUsername = null;
	this.serverHash = null;
	this.serverIp = null;
	this.serverPort = 0;
	this.title = null;
	this.triedSavedLogin = false;
	this.login = new MenuWidget();
	this.login.text = "Login";
	this.login.type = WidgetType.BUTTON;
	this.login.nextWidget = 9;
	this.loginUsername = new MenuWidget();
	this.loginUsername.type = WidgetType.TEXTBOX;
	this.loginUsername.text = "";
	this.loginUsername.description = "Username";
	this.loginUsername.nextWidget = 2;
	this.loginPassword = new MenuWidget();
	this.loginPassword.type = WidgetType.TEXTBOX;
	this.loginPassword.text = "";
	this.loginPassword.description = "Password";
	this.loginPassword.password = true;
	this.loginPassword.nextWidget = 3;
	this.loginRememberMe = new MenuWidget();
	this.loginRememberMe.text = "Yes";
	this.loginRememberMe.type = WidgetType.BUTTON;
	this.loginRememberMe.description = "Remember me";
	this.loginRememberMe.nextWidget = 0;
	this.createAccount = new MenuWidget();
	this.createAccount.text = "Create account";
	this.createAccount.type = WidgetType.BUTTON;
	this.createAccountUsername = new MenuWidget();
	this.createAccountUsername.text = "";
	this.createAccountUsername.type = WidgetType.TEXTBOX;
	this.createAccountUsername.description = "Username";
	this.createAccountPassword = new MenuWidget();
	this.createAccountPassword.text = "";
	this.createAccountPassword.type = WidgetType.TEXTBOX;
	this.createAccountPassword.description = "Password";
	this.createAccountPassword.password = true;
	this.createAccountRememberMe = new MenuWidget();
	this.createAccountRememberMe.text = "Yes";
	this.createAccountRememberMe.type = WidgetType.BUTTON;
	this.createAccountRememberMe.description = "Remember me";
	this.back = new MenuWidget();
	this.back.text = "Back";
	this.back.type = WidgetType.BUTTON;
	this.back.nextWidget = 1;
	this.fontLoginMessage = new FontCi();
	this.fontLoginMessage.size = 14;
	this.title = "Login";
	this.widgets[0] = this.login;
	this.widgets[1] = this.loginUsername;
	this.widgets[2] = this.loginPassword;
	this.widgets[3] = this.loginRememberMe;
	this.widgets[4] = this.createAccount;
	this.widgets[5] = this.createAccountUsername;
	this.widgets[6] = this.createAccountPassword;
	this.widgets[7] = this.createAccountRememberMe;
	this.widgets[9] = this.back;
	this.loginUsername.getFocus();
	this.loginResult = new LoginResultRef();
}
ScreenLogin.prototype = new Screen();

ScreenLogin.prototype.loadTranslations = function() {
	this.login.text = this.menu.lang.get("MainMenu_Login");
	this.loginUsername.description = this.menu.lang.get("MainMenu_LoginUsername");
	this.loginPassword.description = this.menu.lang.get("MainMenu_LoginPassword");
	this.loginRememberMe.text = this.menu.lang.get("MainMenu_ChoiceYes");
	this.loginRememberMe.description = this.menu.lang.get("MainMenu_LoginRemember");
	this.back.text = this.menu.lang.get("MainMenu_ButtonBack");
	this.title = this.menu.lang.get("MainMenu_Login");
}

ScreenLogin.prototype.onBackPressed = function() {
	this.menu.startMultiplayer();
}

ScreenLogin.prototype.onButton = function(w) {
	if (w == this.login) {
		this.loginResultData = new LoginData();
		if (this.serverHash != null) {
			this.menu.login(this.loginUsername.text, this.loginPassword.text, this.serverHash, "", this.loginResult, this.loginResultData);
		}
		else {
			if (this.loginRememberMe.text == this.menu.lang.get("MainMenu_ChoiceYes")) {
				var preferences = this.menu.p.getPreferences();
				preferences.setString("Username", this.loginUsername.text);
				this.menu.p.setPreferences(preferences);
			}
			var connectdata = new ConnectData();
			connectdata.ip = this.serverIp;
			connectdata.port = this.serverPort;
			connectdata.username = this.loginUsername.text;
			this.menu.startGame(false, null, connectdata);
		}
	}
	if (w == this.createAccount) {
		this.menu.createAccount(this.createAccountUsername.text, this.createAccountPassword.text, this.loginResult);
	}
	if (w == this.loginRememberMe || w == this.createAccountRememberMe) {
		if (w.text == this.menu.lang.get("MainMenu_ChoiceYes")) {
			w.text = this.menu.lang.get("MainMenu_ChoiceNo");
		}
		else {
			w.text = this.menu.lang.get("MainMenu_ChoiceYes");
		}
	}
	if (w == this.back) {
		this.onBackPressed();
	}
}

ScreenLogin.prototype.render = function(dt) {
	if (!this.triedSavedLogin) {
		var preferences = this.menu.p.getPreferences();
		this.loginUsername.text = preferences.getString("Username", "");
		this.loginPassword.text = "";
		var token = preferences.getString("Password", "");
		this.loginResultData = new LoginData();
		if (this.serverHash != null && token != "") {
			this.menu.login(this.loginUsername.text, this.loginPassword.text, this.serverHash, token, this.loginResult, this.loginResultData);
		}
		this.triedSavedLogin = true;
	}
	if (this.loginResultData != null && this.loginResultData.serverCorrect && this.loginResultData.passwordCorrect) {
		if (this.loginRememberMe.text == this.menu.lang.get("MainMenu_ChoiceYes")) {
			var preferences = this.menu.p.getPreferences();
			preferences.setString("Username", this.loginUsername.text);
			if (this.loginResultData.token != null && this.loginResultData.token != "") {
				preferences.setString("Password", this.loginResultData.token);
			}
			this.menu.p.setPreferences(preferences);
		}
		this.menu.connectToGame(this.loginResultData, this.loginUsername.text);
	}
	var p = this.menu.p;
	var scale = this.menu.getScale();
	this.menu.drawBackground();
	var leftx = Math.floor(p.getCanvasWidth() / 2) - 400 * scale;
	var y = Math.floor(p.getCanvasHeight() / 2) - 250 * scale;
	var loginResultText = null;
	if (this.loginResult.value == LoginResult.FAILED) {
		loginResultText = this.menu.lang.get("MainMenu_LoginInvalid");
	}
	if (this.loginResult.value == LoginResult.CONNECTING) {
		loginResultText = this.menu.lang.get("MainMenu_LoginConnecting");
	}
	if (loginResultText != null) {
		this.menu.drawText(loginResultText, this.fontLoginMessage, leftx, y - 50 * scale, TextAlign.LEFT, TextBaseline.TOP);
	}
	this.menu.drawText(this.title, this.menu.fontMenuHeading, leftx, y + 50 * scale, TextAlign.LEFT, TextBaseline.TOP);
	this.loginUsername.x = leftx;
	this.loginUsername.y = y + 100 * scale;
	this.loginUsername.sizex = 256 * scale;
	this.loginUsername.sizey = 64 * scale;
	this.loginPassword.x = leftx;
	this.loginPassword.y = y + 200 * scale;
	this.loginPassword.sizex = 256 * scale;
	this.loginPassword.sizey = 64 * scale;
	this.loginRememberMe.x = leftx;
	this.loginRememberMe.y = y + 300 * scale;
	this.loginRememberMe.sizex = 256 * scale;
	this.loginRememberMe.sizey = 64 * scale;
	this.login.x = leftx;
	this.login.y = y + 400 * scale;
	this.login.sizex = 256 * scale;
	this.login.sizey = 64 * scale;
	var rightx = Math.floor(p.getCanvasWidth() / 2) + 150 * scale;
	this.createAccountUsername.x = rightx;
	this.createAccountUsername.y = y + 100 * scale;
	this.createAccountUsername.sizex = 256 * scale;
	this.createAccountUsername.sizey = 64 * scale;
	this.createAccountPassword.x = rightx;
	this.createAccountPassword.y = y + 200 * scale;
	this.createAccountPassword.sizex = 256 * scale;
	this.createAccountPassword.sizey = 64 * scale;
	this.createAccountRememberMe.x = rightx;
	this.createAccountRememberMe.y = y + 300 * scale;
	this.createAccountRememberMe.sizex = 256 * scale;
	this.createAccountRememberMe.sizey = 64 * scale;
	this.createAccount.x = rightx;
	this.createAccount.y = y + 400 * scale;
	this.createAccount.sizex = 256 * scale;
	this.createAccount.sizey = 64 * scale;
	this.createAccountUsername.visible = false;
	this.createAccountPassword.visible = false;
	this.createAccountRememberMe.visible = false;
	this.createAccount.visible = false;
	this.back.x = 40 * scale;
	this.back.y = p.getCanvasHeight() - 104 * scale;
	this.back.sizex = 256 * scale;
	this.back.sizey = 64 * scale;
	this.drawWidgets();
}

function ScreenMain()
{
	this.cursorLoaded = false;
	this.exit = null;
	this.fontDefault = null;
	this.multiplayer = null;
	this.queryStringChecked = false;
	this.singleplayer = null;
	this.windowX = null;
	this.windowY = null;
	this.singleplayer = new MenuWidget();
	this.multiplayer = new MenuWidget();
	this.exit = new MenuWidget();
	this.widgets[0] = this.singleplayer;
	this.widgets[1] = this.multiplayer;
	this.widgets[2] = this.exit;
	this.queryStringChecked = false;
	this.cursorLoaded = false;
	this.fontDefault = new FontCi();
	this.fontDefault.size = 20;
}
ScreenMain.prototype = new Screen();

ScreenMain.prototype.onBackPressed = function() {
	this.menu.exit();
}

ScreenMain.prototype.onButton = function(w) {
	if (w == this.singleplayer) {
		this.menu.startSingleplayer();
	}
	if (w == this.multiplayer) {
		this.menu.startMultiplayer();
	}
	if (w == this.exit) {
		this.menu.exit();
	}
}

ScreenMain.prototype.onKeyDown = function(e) {
	if (e.getKeyCode() == 14) {
		this.menu.p.singlePlayerServerDisable();
		this.menu.startGame(true, this.menu.p.pathCombine(this.menu.p.pathSavegames(), "Default.mdss"), null);
	}
	if (e.getKeyCode() == 15) {
		this.menu.startGame(true, this.menu.p.pathCombine(this.menu.p.pathSavegames(), "Default.mddbs"), null);
	}
}

ScreenMain.prototype.render = function(dt) {
	this.windowX = this.menu.p.getCanvasWidth();
	this.windowY = this.menu.p.getCanvasHeight();
	var scale = this.menu.getScale();
	if (this.menu.assetsLoadProgress.value != 1) {
		var s = this.menu.p.stringFormat(this.menu.lang.get("MainMenu_AssetsLoadProgress"), this.menu.p.floatToString(this.menu.p.floatToInt(this.menu.assetsLoadProgress.value * 100)));
		this.menu.drawText(s, this.fontDefault, this.windowX / (2), this.windowY / (2), TextAlign.CENTER, TextBaseline.MIDDLE);
		return;
	}
	if (!this.cursorLoaded) {
		this.menu.p.setWindowCursor(0, 0, 32, 32, this.menu.getFile("mousecursor.png"), this.menu.getFileLength("mousecursor.png"));
		this.cursorLoaded = true;
	}
	this.useQueryStringIpAndPort(this.menu);
	this.menu.drawBackground();
	this.menu.draw2dQuad(this.menu.getTexture("logo.png"), this.windowX / (2) - (1024 * scale) / (2), 0, 1024 * scale, 512 * scale);
	var buttonheight = 64;
	var buttonwidth = 256;
	var spacebetween = 5;
	var offsetfromborder = 50;
	this.singleplayer.text = this.menu.lang.get("MainMenu_Singleplayer");
	this.singleplayer.x = this.windowX / (2) - Math.floor(buttonwidth / 2) * scale;
	this.singleplayer.y = this.windowY - 3 * (buttonheight * scale + spacebetween) - offsetfromborder * scale;
	this.singleplayer.sizex = buttonwidth * scale;
	this.singleplayer.sizey = buttonheight * scale;
	this.multiplayer.text = this.menu.lang.get("MainMenu_Multiplayer");
	this.multiplayer.x = this.windowX / (2) - Math.floor(buttonwidth / 2) * scale;
	this.multiplayer.y = this.windowY - 2 * (buttonheight * scale + spacebetween) - offsetfromborder * scale;
	this.multiplayer.sizex = buttonwidth * scale;
	this.multiplayer.sizey = buttonheight * scale;
	this.exit.visible = this.menu.p.exitAvailable();
	this.exit.text = this.menu.lang.get("MainMenu_Quit");
	this.exit.x = this.windowX / (2) - Math.floor(buttonwidth / 2) * scale;
	this.exit.y = this.windowY - 1 * (buttonheight * scale + spacebetween) - offsetfromborder * scale;
	this.exit.sizex = buttonwidth * scale;
	this.exit.sizey = buttonheight * scale;
	this.drawWidgets();
}

ScreenMain.prototype.useQueryStringIpAndPort = function(menu) {
	if (this.queryStringChecked) {
		return;
	}
	this.queryStringChecked = true;
	var ip = menu.p.queryStringValue("ip");
	var port = menu.p.queryStringValue("port");
	var portInt = 25565;
	if (port != null && menu.p.floatTryParse(port, new FloatRef())) {
		portInt = menu.p.intParse(port);
	}
	if (ip != null) {
		menu.startLogin(null, ip, portInt);
	}
}

function ScreenModifyWorld()
{
	this.back = null;
	this.back = new MenuWidget();
	this.back.text = "Back";
	this.back.type = WidgetType.BUTTON;
	this.widgets[0] = this.back;
}
ScreenModifyWorld.prototype = new Screen();

ScreenModifyWorld.prototype.onBackPressed = function() {
	this.menu.startSingleplayer();
}

ScreenModifyWorld.prototype.onButton = function(w) {
	if (w == this.back) {
		this.onBackPressed();
	}
}

ScreenModifyWorld.prototype.render = function(dt) {
	var p = this.menu.p;
	var scale = this.menu.getScale();
	this.menu.drawBackground();
	this.menu.drawText("Modify World", this.menu.fontMenuHeading, Math.floor(this.menu.p.getCanvasWidth() / 2), 0, TextAlign.CENTER, TextBaseline.TOP);
	this.back.x = 40 * scale;
	this.back.y = p.getCanvasHeight() - 104 * scale;
	this.back.sizex = 256 * scale;
	this.back.sizey = 64 * scale;
	this.drawWidgets();
}

function ScreenMultiplayer()
{
	this.back = null;
	this.connect = null;
	this.connectToIp = null;
	this.fontDefault = null;
	this.fontServerDescription = null;
	this.fontServerHeading = null;
	this.loaded = false;
	this.loading = false;
	this.loggedInName = null;
	this.logout = null;
	this.page = 0;
	this.pageDown = null;
	this.pageUp = null;
	this.refresh = null;
	this.selectedServerHash = null;
	this.serverButtons = null;
	this.serverListAddress = null;
	this.serverListCsv = null;
	this.serversOnList = null;
	this.serversPerPage = 0;
	this.thumbResponses = null;
	this.title = null;
	this.widgetCount = 1088;
	this.widgets = new Array(this.widgetCount);
	this.back = new MenuWidget();
	this.back.text = "Back";
	this.back.type = WidgetType.BUTTON;
	this.back.nextWidget = 1;
	this.connect = new MenuWidget();
	this.connect.text = "Connect";
	this.connect.type = WidgetType.BUTTON;
	this.connect.nextWidget = 3;
	this.connectToIp = new MenuWidget();
	this.connectToIp.text = "Connect to IP";
	this.connectToIp.type = WidgetType.BUTTON;
	this.connectToIp.nextWidget = 2;
	this.refresh = new MenuWidget();
	this.refresh.text = "Refresh";
	this.refresh.type = WidgetType.BUTTON;
	this.refresh.nextWidget = 0;
	this.page = 0;
	this.pageUp = new MenuWidget();
	this.pageUp.text = "";
	this.pageUp.type = WidgetType.BUTTON;
	this.pageUp.buttonStyle = ButtonStyle.TEXT;
	this.pageUp.visible = false;
	this.pageDown = new MenuWidget();
	this.pageDown.text = "";
	this.pageDown.type = WidgetType.BUTTON;
	this.pageDown.buttonStyle = ButtonStyle.TEXT;
	this.pageDown.visible = false;
	this.loggedInName = new MenuWidget();
	this.loggedInName.text = "";
	this.loggedInName.type = WidgetType.BUTTON;
	this.loggedInName.buttonStyle = ButtonStyle.TEXT;
	this.logout = new MenuWidget();
	this.logout.text = "";
	this.logout.type = WidgetType.BUTTON;
	this.logout.buttonStyle = ButtonStyle.BUTTON;
	this.title = "Multiplayer";
	this.fontServerHeading = new FontCi();
	this.fontServerHeading.style = 1;
	this.fontServerHeading.size = 14;
	this.fontServerDescription = new FontCi();
	this.fontDefault = new FontCi();
	this.fontDefault.size = 14;
	this.widgets[0] = this.back;
	this.widgets[1] = this.connect;
	this.widgets[2] = this.refresh;
	this.widgets[3] = this.connectToIp;
	this.widgets[4] = this.pageUp;
	this.widgets[5] = this.pageDown;
	this.widgets[6] = this.loggedInName;
	this.widgets[7] = this.logout;
	this.serverListAddress = new HttpResponseCi();
	this.serverListCsv = new HttpResponseCi();
	this.serversOnList = new Array(1024);
	this.thumbResponses = new Array(1024);
	this.serverButtons = new Array(1024);
	for (var i = 0; i < 1024; i++) {
		var b = new MenuWidget();
		b = new MenuWidget();
		b.text = "Invalid";
		b.type = WidgetType.BUTTON;
		b.visible = false;
		b.image = "serverlist_entry_noimage.png";
		this.serverButtons[i] = b;
		this.widgets[8 + i] = b;
	}
	this.loading = true;
}
ScreenMultiplayer.prototype = new Screen();

ScreenMultiplayer.prototype.drawServerButton = function(name, motd, gamemode, playercount, x, y, width, height, image) {
	this.menu.draw2dQuad(this.menu.getTexture("serverlist_entry_background.png"), x, y, width, height);
	this.menu.draw2dQuad(this.menu.getTexture(image), x, y, height, height);
	this.menu.drawText(name, this.fontServerHeading, x + 70, y + 5, TextAlign.LEFT, TextBaseline.TOP);
	this.menu.drawText(gamemode, this.fontServerDescription, x + width - 10, y + height - 5, TextAlign.RIGHT, TextBaseline.BOTTOM);
	this.menu.drawText(playercount, this.fontServerDescription, x + width - 10, y + 5, TextAlign.RIGHT, TextBaseline.TOP);
	this.menu.drawText(motd, this.fontServerDescription, x + 70, y + height - 5, TextAlign.LEFT, TextBaseline.BOTTOM);
}

ScreenMultiplayer.prototype.drawServerWidgets = function() {
	for (var i = 0; i < this.widgetCount; i++) {
		var w = this.widgets[i];
		if (w != null) {
			if (!w.visible) {
				continue;
			}
			var text = w.text;
			if (w.selected) {
				text = StringTools.stringAppend(this.menu.p, "&2", text);
			}
			if (w.type == WidgetType.BUTTON) {
				if (w.buttonStyle == ButtonStyle.SERVER_ENTRY) {
					var strings = this.menu.p.stringSplit(w.text, "\n", new IntRef());
					if (w.selected) {
						strings[0] = StringTools.stringAppend(this.menu.p, "&2", strings[0]);
						strings[1] = StringTools.stringAppend(this.menu.p, "&2", strings[1]);
						strings[2] = StringTools.stringAppend(this.menu.p, "&2", strings[2]);
						strings[3] = StringTools.stringAppend(this.menu.p, "&2", strings[3]);
					}
					this.drawServerButton(strings[0], strings[1], strings[2], strings[3], w.x, w.y, w.sizex, w.sizey, w.image);
					if (w.description != null) {
						this.menu.draw2dQuad(this.menu.getTexture("serverlist_entry_noresponse.png"), w.x - 38 * this.menu.getScale(), w.y, w.sizey / (2), w.sizey / (2));
					}
					if (strings[4] != this.menu.p.getGameVersion()) {
						this.menu.draw2dQuad(this.menu.getTexture("serverlist_entry_differentversion.png"), w.x - 38 * this.menu.getScale(), w.y + w.sizey / (2), w.sizey / (2), w.sizey / (2));
					}
				}
			}
		}
	}
}

ScreenMultiplayer.prototype.loadTranslations = function() {
	this.back.text = this.menu.lang.get("MainMenu_ButtonBack");
	this.connect.text = this.menu.lang.get("MainMenu_MultiplayerConnect");
	this.connectToIp.text = this.menu.lang.get("MainMenu_MultiplayerConnectIP");
	this.refresh.text = this.menu.lang.get("MainMenu_MultiplayerRefresh");
	this.title = this.menu.lang.get("MainMenu_Multiplayer");
}

ScreenMultiplayer.prototype.onBackPressed = function() {
	this.menu.startMainMenu();
}

ScreenMultiplayer.prototype.onButton = function(w) {
	for (var i = 0; i < 1024; i++) {
		this.serverButtons[i].selected = false;
		if (this.serverButtons[i] == w) {
			this.serverButtons[i].selected = true;
			if (this.serversOnList[i + this.serversPerPage * this.page] != null) {
				this.selectedServerHash = this.serversOnList[i + this.serversPerPage * this.page].hash;
			}
		}
	}
	if (w == this.pageUp) {
		this.pageUp_();
	}
	if (w == this.pageDown) {
		this.pageDown_();
	}
	if (w == this.back) {
		this.onBackPressed();
	}
	if (w == this.connect) {
		if (this.selectedServerHash != null) {
			this.menu.startLogin(this.selectedServerHash, null, 0);
		}
	}
	if (w == this.connectToIp) {
		this.menu.startConnectToIp();
	}
	if (w == this.refresh) {
		this.loaded = false;
		this.loading = true;
	}
	if (w == this.logout) {
		var pref = this.menu.p.getPreferences();
		pref.remove("Username");
		pref.remove("Password");
		this.menu.p.setPreferences(pref);
		this.loggedInName.text = "";
	}
}

ScreenMultiplayer.prototype.onMouseWheel = function(e) {
	if (e.getDelta() < 0) {
		this.pageUp_();
	}
	else if (e.getDelta() > 0) {
		this.pageDown_();
	}
}

ScreenMultiplayer.prototype.pageDown_ = function() {
	if (this.page > 0) {
		this.page--;
	}
}

ScreenMultiplayer.prototype.pageUp_ = function() {
	if (this.pageUp.visible && this.page < Math.floor(1024 / this.serversPerPage) - 1) {
		this.page++;
	}
}

ScreenMultiplayer.prototype.render = function(dt) {
	if (!this.loaded) {
		this.menu.p.webClientDownloadDataAsync("http://manicdigger.sourceforge.net/serverlistcsv.php", this.serverListAddress);
		this.loaded = true;
	}
	if (this.serverListAddress.done) {
		this.serverListAddress.done = false;
		this.menu.p.webClientDownloadDataAsync(this.serverListAddress.getString(this.menu.p), this.serverListCsv);
	}
	if (this.serverListCsv.done) {
		this.loading = false;
		this.serverListCsv.done = false;
		for (var i = 0; i < 1024; i++) {
			this.serversOnList[i] = null;
			this.thumbResponses[i] = null;
		}
		var serversCount = new IntRef();
		var servers = this.menu.p.stringSplit(this.serverListCsv.getString(this.menu.p), "\n", serversCount);
		for (var i = 0; i < serversCount.value; i++) {
			var ssCount = new IntRef();
			var ss = this.menu.p.stringSplit(servers[i], "\t", ssCount);
			if (ssCount.value < 10) {
				continue;
			}
			var s = new ServerOnList();
			s.hash = ss[0];
			s.name = this.menu.p.decodeHTMLEntities(ss[1]);
			s.motd = this.menu.p.decodeHTMLEntities(ss[2]);
			s.port = this.menu.p.intParse(ss[3]);
			s.ip = ss[4];
			s.version = ss[5];
			s.users = this.menu.p.intParse(ss[6]);
			s.max = this.menu.p.intParse(ss[7]);
			s.gamemode = ss[8];
			s.players = ss[9];
			this.serversOnList[i] = s;
		}
	}
	var p = this.menu.p;
	var scale = this.menu.getScale();
	this.back.x = 40 * scale;
	this.back.y = p.getCanvasHeight() - 104 * scale;
	this.back.sizex = 256 * scale;
	this.back.sizey = 64 * scale;
	this.connect.x = Math.floor(p.getCanvasWidth() / 2) - 300 * scale;
	this.connect.y = p.getCanvasHeight() - 104 * scale;
	this.connect.sizex = 256 * scale;
	this.connect.sizey = 64 * scale;
	this.connectToIp.x = Math.floor(p.getCanvasWidth() / 2) - 0 * scale;
	this.connectToIp.y = p.getCanvasHeight() - 104 * scale;
	this.connectToIp.sizex = 256 * scale;
	this.connectToIp.sizey = 64 * scale;
	this.refresh.x = Math.floor(p.getCanvasWidth() / 2) + 350 * scale;
	this.refresh.y = p.getCanvasHeight() - 104 * scale;
	this.refresh.sizex = 256 * scale;
	this.refresh.sizey = 64 * scale;
	this.pageUp.x = p.getCanvasWidth() - 94 * scale;
	this.pageUp.y = 100 * scale + (this.serversPerPage - 1) * 70 * scale;
	this.pageUp.sizex = 64 * scale;
	this.pageUp.sizey = 64 * scale;
	this.pageUp.image = "serverlist_nav_down.png";
	this.pageDown.x = p.getCanvasWidth() - 94 * scale;
	this.pageDown.y = 100 * scale;
	this.pageDown.sizex = 64 * scale;
	this.pageDown.sizey = 64 * scale;
	this.pageDown.image = "serverlist_nav_up.png";
	this.loggedInName.x = p.getCanvasWidth() - 228 * scale;
	this.loggedInName.y = 32 * scale;
	this.loggedInName.sizex = 128 * scale;
	this.loggedInName.sizey = 32 * scale;
	if (this.loggedInName.text == "") {
		if (p.getPreferences().getString("Password", "") != "") {
			this.loggedInName.text = p.getPreferences().getString("Username", "Invalid");
		}
	}
	this.logout.visible = this.loggedInName.text != "";
	this.logout.x = p.getCanvasWidth() - 228 * scale;
	this.logout.y = 62 * scale;
	this.logout.sizex = 128 * scale;
	this.logout.sizey = 32 * scale;
	this.logout.text = "Logout";
	this.menu.drawBackground();
	this.menu.drawText(this.title, this.menu.fontMenuHeading, Math.floor(p.getCanvasWidth() / 2), 10, TextAlign.CENTER, TextBaseline.TOP);
	this.menu.drawText(p.intToString(this.page + 1), this.fontDefault, p.getCanvasWidth() - 68 * scale, Math.floor(p.getCanvasHeight() / 2), TextAlign.CENTER, TextBaseline.MIDDLE);
	if (this.loading) {
		this.menu.drawText(this.menu.lang.get("MainMenu_MultiplayerLoading"), this.fontDefault, 100 * scale, 50 * scale, TextAlign.LEFT, TextBaseline.TOP);
	}
	this.updateThumbnails();
	for (var i = 0; i < 1024; i++) {
		this.serverButtons[i].visible = false;
	}
	this.serversPerPage = this.menu.p.floatToInt((this.menu.p.getCanvasHeight() - 200 * scale) / (70) * scale);
	if (this.serversPerPage <= 0) {
		this.serversPerPage = 1;
	}
	for (var i = 0; i < this.serversPerPage; i++) {
		var index = i + this.serversPerPage * this.page;
		if (index > 1024) {
			this.page = 0;
			index = i + this.serversPerPage * this.page;
		}
		var s = this.serversOnList[index];
		if (s == null) {
			continue;
		}
		var t = this.menu.p.stringFormat2("{1}", this.menu.p.intToString(index), s.name);
		t = this.menu.p.stringFormat2("{0}\n{1}", t, s.motd);
		t = this.menu.p.stringFormat2("{0}\n{1}", t, s.gamemode);
		t = this.menu.p.stringFormat2("{0}\n{1}", t, this.menu.p.intToString(s.users));
		t = this.menu.p.stringFormat2("{0}/{1}", t, this.menu.p.intToString(s.max));
		t = this.menu.p.stringFormat2("{0}\n{1}", t, s.version);
		this.serverButtons[i].text = t;
		this.serverButtons[i].x = 100 * scale;
		this.serverButtons[i].y = 100 * scale + i * 70 * scale;
		this.serverButtons[i].sizex = p.getCanvasWidth() - 200 * scale;
		this.serverButtons[i].sizey = 64 * scale;
		this.serverButtons[i].visible = true;
		this.serverButtons[i].buttonStyle = ButtonStyle.SERVER_ENTRY;
		if (s.thumbnailError) {
			this.serverButtons[i].description = "Server did not respond to query!";
		}
		else {
			this.serverButtons[i].description = null;
		}
		if (s.thumbnailFetched && !s.thumbnailError) {
			this.serverButtons[i].image = this.menu.p.stringFormat("serverlist_entry_{0}.png", s.hash);
		}
		else {
			this.serverButtons[i].image = "serverlist_entry_noimage.png";
		}
	}
	this.updateScrollButtons();
	this.drawWidgets();
	this.drawServerWidgets();
}

ScreenMultiplayer.prototype.updateScrollButtons = function() {
	var maxpage = false;
	if ((this.page + 1) * this.serversPerPage >= 1024) {
		maxpage = true;
	}
	else {
		if (this.serversOnList[(this.page + 1) * this.serversPerPage] == null) {
			maxpage = true;
		}
	}
	if (this.page == 0) {
		this.pageDown.visible = false;
	}
	else {
		this.pageDown.visible = true;
	}
	if (maxpage) {
		this.pageUp.visible = false;
	}
	else {
		this.pageUp.visible = true;
	}
}

ScreenMultiplayer.prototype.updateThumbnails = function() {
	for (var i = 0; i < 1024; i++) {
		var server = this.serversOnList[i];
		if (server == null) {
			continue;
		}
		if (server.thumbnailFetched) {
			continue;
		}
		if (!server.thumbnailDownloading) {
			this.thumbResponses[i] = new ThumbnailResponseCi();
			this.menu.p.thumbnailDownloadAsync(server.ip, server.port, this.thumbResponses[i]);
			server.thumbnailDownloading = true;
		}
		else {
			if (this.thumbResponses[i] != null) {
				if (this.thumbResponses[i].done) {
					var bmp = this.menu.p.bitmapCreateFromPng(this.thumbResponses[i].data, this.thumbResponses[i].dataLength);
					if (bmp != null) {
						var texture = this.menu.p.loadTextureFromBitmap(bmp);
						this.menu.textures.set(this.menu.p.stringFormat("serverlist_entry_{0}.png", server.hash), texture);
						this.menu.p.bitmapDelete(bmp);
					}
					server.thumbnailDownloading = false;
					server.thumbnailFetched = true;
				}
				if (this.thumbResponses[i].error) {
					server.thumbnailDownloading = false;
					server.thumbnailError = true;
					server.thumbnailFetched = true;
				}
			}
			else {
				server.thumbnailDownloading = false;
				server.thumbnailError = true;
				server.thumbnailFetched = true;
			}
		}
	}
}

function ScreenSingleplayer()
{
	this.back = null;
	this.fontDefault = null;
	this.modify = null;
	this.newWorld = null;
	this.open = null;
	this.play = null;
	this.savegames = null;
	this.savegamesCount = 0;
	this.title = null;
	this.worldButtons = null;
	this.play = new MenuWidget();
	this.play.text = "Play";
	this.newWorld = new MenuWidget();
	this.newWorld.text = "New World";
	this.modify = new MenuWidget();
	this.modify.text = "Modify";
	this.back = new MenuWidget();
	this.back.text = "Back";
	this.back.type = WidgetType.BUTTON;
	this.open = new MenuWidget();
	this.open.text = "Create or open...";
	this.open.type = WidgetType.BUTTON;
	this.title = "Singleplayer";
	this.fontDefault = new FontCi();
	this.fontDefault.size = 16;
	this.widgets[0] = this.play;
	this.widgets[1] = this.newWorld;
	this.widgets[2] = this.modify;
	this.widgets[3] = this.back;
	this.widgets[4] = this.open;
	this.worldButtons = new Array(10);
	for (var i = 0; i < 10; i++) {
		this.worldButtons[i] = new MenuWidget();
		this.worldButtons[i].visible = false;
		this.widgets[5 + i] = this.worldButtons[i];
	}
}
ScreenSingleplayer.prototype = new Screen();

ScreenSingleplayer.prototype.loadTranslations = function() {
	this.back.text = this.menu.lang.get("MainMenu_ButtonBack");
	this.open.text = this.menu.lang.get("MainMenu_SingleplayerButtonCreate");
	this.title = this.menu.lang.get("MainMenu_Singleplayer");
}

ScreenSingleplayer.prototype.onBackPressed = function() {
	this.menu.startMainMenu();
}

ScreenSingleplayer.prototype.onButton = function(w) {
	for (var i = 0; i < 10; i++) {
		this.worldButtons[i].selected = false;
	}
	for (var i = 0; i < 10; i++) {
		if (this.worldButtons[i] == w) {
			this.worldButtons[i].selected = true;
		}
	}
	if (w == this.newWorld) {
		this.menu.startNewWorld();
	}
	if (w == this.play) {
	}
	if (w == this.modify) {
		this.menu.startModifyWorld();
	}
	if (w == this.back) {
		this.onBackPressed();
	}
	if (w == this.open) {
		var extension;
		if (this.menu.p.singlePlayerServerAvailable()) {
			extension = "mddbs";
		}
		else {
			extension = "mdss";
		}
		var result = this.menu.p.fileOpenDialog(extension, "Manic Digger Savegame", this.menu.p.pathSavegames());
		if (result != null) {
			this.menu.connectToSingleplayer(result);
		}
	}
}

ScreenSingleplayer.prototype.render = function(dt) {
	var p = this.menu.p;
	var scale = this.menu.getScale();
	this.menu.drawBackground();
	this.menu.drawText(this.title, this.menu.fontMenuHeading, Math.floor(p.getCanvasWidth() / 2), 10, TextAlign.CENTER, TextBaseline.TOP);
	var leftx = Math.floor(p.getCanvasWidth() / 2) - 128 * scale;
	var y = Math.floor(p.getCanvasHeight() / 2) + 0 * scale;
	this.play.x = leftx;
	this.play.y = y + 100 * scale;
	this.play.sizex = 256 * scale;
	this.play.sizey = 64 * scale;
	this.newWorld.x = leftx;
	this.newWorld.y = y + 170 * scale;
	this.newWorld.sizex = 256 * scale;
	this.newWorld.sizey = 64 * scale;
	this.modify.x = leftx;
	this.modify.y = y + 240 * scale;
	this.modify.sizex = 256 * scale;
	this.modify.sizey = 64 * scale;
	this.back.x = 40 * scale;
	this.back.y = p.getCanvasHeight() - 104 * scale;
	this.back.sizex = 256 * scale;
	this.back.sizey = 64 * scale;
	this.open.x = leftx;
	this.open.y = y + 0 * scale;
	this.open.sizex = 256 * scale;
	this.open.sizey = 64 * scale;
	if (this.savegames == null) {
		var savegamesCount_ = new IntRef();
		this.savegames = this.menu.getSavegames(savegamesCount_);
		this.savegamesCount = savegamesCount_.value;
	}
	for (var i = 0; i < 10; i++) {
		this.worldButtons[i].visible = false;
	}
	for (var i = 0; i < this.savegamesCount; i++) {
		this.worldButtons[i].visible = true;
		this.worldButtons[i].text = this.menu.p.fileName(this.savegames[i]);
		this.worldButtons[i].x = leftx;
		this.worldButtons[i].y = 100 + 100 * scale * i;
		this.worldButtons[i].sizex = 256 * scale;
		this.worldButtons[i].sizey = 64 * scale;
	}
	this.open.visible = this.menu.p.singlePlayerServerAvailable();
	this.play.visible = false;
	this.newWorld.visible = false;
	this.modify.visible = false;
	for (var i = 0; i < this.savegamesCount; i++) {
		this.worldButtons[i].visible = false;
	}
	this.drawWidgets();
	if (!this.menu.p.singlePlayerServerAvailable()) {
		this.menu.drawText("Singleplayer is only available on desktop (Windows, Linux, Mac) version of game.", this.fontDefault, Math.floor(this.menu.p.getCanvasWidth() / 2), Math.floor(this.menu.p.getCanvasHeight() / 2), TextAlign.CENTER, TextBaseline.MIDDLE);
	}
}

function Script()
{
}

Script.prototype.onCreate = function(manager) {
}

Script.prototype.onUse = function() {
}

function ScriptCharacterPhysics()
{
	this.acceleration = null;
	this.constEnableAcceleration = false;
	this.constGravity = null;
	this.constJump = null;
	this.constWaterGravityMultiplier = null;
	this.curspeed = null;
	this.game = null;
	this.isplayeronground = false;
	this.jumpacceleration = null;
	this.jumpstartacceleration = null;
	this.jumpstartaccelerationhalf = null;
	this.movedz = null;
	this.movespeednow = null;
	this.tmpBlockingBlockType = null;
	this.tmpPlayerPosition = null;
	this.movedz = 0;
	this.curspeed = new Vector3Ref();
	this.jumpacceleration = 0;
	this.isplayeronground = false;
	this.acceleration = new Acceleration();
	this.jumpstartacceleration = 0;
	this.jumpstartaccelerationhalf = 0;
	this.movespeednow = 0;
	this.tmpPlayerPosition = new Float32Array(new ArrayBuffer(3 << 2));
	this.tmpBlockingBlockType = new IntRef();
	this.constGravity = 0.3;
	this.constWaterGravityMultiplier = 3;
	this.constEnableAcceleration = true;
	this.constJump = 2.1;
}
ScriptCharacterPhysics.prototype = new EntityScript();

ScriptCharacterPhysics.boxPointDistance = function(minX, minY, minZ, maxX, maxY, maxZ, pX, pY, pZ) {
	var dx = ScriptCharacterPhysics.max3(minX - pX, 0, pX - maxX);
	var dy = ScriptCharacterPhysics.max3(minY - pY, 0, pY - maxY);
	var dz = ScriptCharacterPhysics.max3(minZ - pZ, 0, pZ - maxZ);
	return ScriptCharacterPhysics.max3(dx, dy, dz);
}

ScriptCharacterPhysics.prototype.floatToInt = function(value) {
	return this.game.platform.floatToInt(value);
}

ScriptCharacterPhysics.prototype.isEmptyPoint = function(x, y, z, blockingBlocktype) {
	for (var xx = 0; xx < 3; xx++) {
		for (var yy = 0; yy < 3; yy++) {
			for (var zz = 0; zz < 3; zz++) {
				if (!this.isTileEmptyForPhysics(this.floatToInt(x + xx - 1), this.floatToInt(z + zz - 1), this.floatToInt(y + yy - 1))) {
					var minX = this.floatToInt(x + xx - 1);
					var minY = this.floatToInt(y + yy - 1);
					var minZ = this.floatToInt(z + zz - 1);
					var maxX = minX + 1;
					var maxY = minY + this.game.getblockheight(this.floatToInt(x + xx - 1), this.floatToInt(z + zz - 1), this.floatToInt(y + yy - 1));
					var maxZ = minZ + 1;
					if (ScriptCharacterPhysics.boxPointDistance(minX, minY, minZ, maxX, maxY, maxZ, x, y, z) < this.game.constWallDistance) {
						if (blockingBlocktype != null) {
							blockingBlocktype.value = this.game.map.getBlock(this.floatToInt(x + xx - 1), this.floatToInt(z + zz - 1), this.floatToInt(y + yy - 1));
						}
						return false;
					}
				}
			}
		}
	}
	return true;
}

ScriptCharacterPhysics.prototype.isEmptySpaceForPlayer = function(high, x, y, z, blockingBlockType) {
	return this.isEmptyPoint(x, y, z, blockingBlockType) && this.isEmptyPoint(x, y + 1, z, blockingBlockType) && (!high || this.isEmptyPoint(x, y + 2, z, blockingBlockType));
}

ScriptCharacterPhysics.prototype.isTileEmptyForPhysics = function(x, y, z) {
	if (z >= this.game.map.mapSizeZ) {
		return true;
	}
	var enableFreemove = false;
	if (x < 0 || y < 0 || z < 0) {
		return enableFreemove;
	}
	if (x >= this.game.map.mapSizeX || y >= this.game.map.mapSizeY) {
		return enableFreemove;
	}
	var block = this.game.map.getBlockValid(x, y, z);
	if (block == 0) {
		return true;
	}
	var blocktype = this.game.blocktypes[block];
	return blocktype.walkableType == 1 || this.game.isEmptyForPhysics(blocktype) || this.game.isRail(blocktype);
}

ScriptCharacterPhysics.makeCloserToZero = function(a, b) {
	if (a > 0) {
		var c = a - b;
		if (c < 0) {
			c = 0;
		}
		return c;
	}
	else {
		var c = a + b;
		if (c > 0) {
			c = 0;
		}
		return c;
	}
}

ScriptCharacterPhysics.max3 = function(a, b, c) {
	return MathCi.maxFloat(MathCi.maxFloat(a, b), c);
}

ScriptCharacterPhysics.prototype.onNewFrameFixed = function(game_, entity, dt) {
	this.game = game_;
	if (this.game.guistate == GuiState.MAP_LOADING) {
		return;
	}
	this.movespeednow = this.game.moveSpeedNow();
	this.game.controls.movedx = MathCi.clampFloat(this.game.controls.movedx, -1, 1);
	this.game.controls.movedy = MathCi.clampFloat(this.game.controls.movedy, -1, 1);
	var move = this.game.controls;
	this.jumpstartacceleration = 13.333 * this.constGravity;
	this.jumpstartaccelerationhalf = 9 * this.constGravity;
	this.acceleration.setDefault();
	this.game.soundnow = new BoolRef();
	if (this.game.followId() != null && this.game.followId().value == this.game.localPlayerId) {
		move.movedx = 0;
		move.movedy = 0;
		move.moveup = false;
		move.wantsjump = false;
	}
	this.update(this.game.player.position, move, dt, this.game.soundnow, Vector3Ref.create(this.game.pushX, this.game.pushY, this.game.pushZ), this.game.entities[this.game.localPlayerId].drawModel.modelHeight);
}

ScriptCharacterPhysics.prototype.standingOnHalfBlock = function(x, y, z) {
	var under = this.game.map.getBlock(this.game.platform.floatToInt(x), this.game.platform.floatToInt(z), this.game.platform.floatToInt(y));
	return this.game.blocktypes[under].drawType == 11;
}

ScriptCharacterPhysics.prototype.update = function(stateplayerposition, move, dt, soundnow, push, modelheight) {
	if (this.game.stopPlayerMove) {
		this.movedz = 0;
		this.game.stopPlayerMove = false;
	}
	if (!this.isplayeronground) {
		this.acceleration.acceleration1 = 0.99;
		this.acceleration.acceleration2 = 0.2;
		this.acceleration.acceleration3 = 70;
	}
	{
		var blockunderplayer = this.game.blockUnderPlayer();
		if (blockunderplayer != -1 && blockunderplayer == this.game.d_Data.blockIdTrampoline() && !this.isplayeronground && !this.game.controls.shiftkeydown) {
			this.game.controls.wantsjump = true;
			this.jumpstartacceleration = 20.666 * this.constGravity;
		}
	}
	{
		var blockunderplayer = this.game.blockUnderPlayer();
		if (blockunderplayer != -1 && this.game.d_Data.isSlipperyWalk()[blockunderplayer] || this.game.swimmingBody()) {
			this.acceleration.acceleration1 = 0.99;
			this.acceleration.acceleration2 = 0.2;
			this.acceleration.acceleration3 = 70;
		}
	}
	soundnow.value = false;
	var diff1ref = new Vector3Ref();
	VectorTool.toVectorInFixedSystem(move.movedx * this.movespeednow * dt, 0, move.movedy * this.movespeednow * dt, stateplayerposition.rotx, stateplayerposition.roty, diff1ref);
	var diff1 = new Vector3Ref();
	diff1.x = diff1ref.x;
	diff1.y = diff1ref.y;
	diff1.z = diff1ref.z;
	if (MiscCi.vec3Length(push.x, push.y, push.z) > 0.01) {
		push.normalize();
		push.x *= 5;
		push.y *= 5;
		push.z *= 5;
	}
	diff1.x += push.x * dt;
	diff1.y += push.y * dt;
	diff1.z += push.z * dt;
	var loaded = false;
	var cx = this.game.platform.floatToInt(this.game.player.position.x / (16));
	var cy = this.game.platform.floatToInt(this.game.player.position.z / (16));
	var cz = this.game.platform.floatToInt(this.game.player.position.y / (16));
	if (this.game.map.isValidChunkPos(cx, cy, cz)) {
		if (this.game.map.chunks[MapUtilCi.index3d(cx, cy, cz, Math.floor(this.game.map.mapSizeX / 16), Math.floor(this.game.map.mapSizeY / 16))] != null) {
			loaded = true;
		}
	}
	else {
		loaded = true;
	}
	if (!move.freemove && loaded) {
		if (!this.game.swimmingBody()) {
			this.movedz += -this.constGravity;
		}
		else {
			this.movedz += -this.constGravity * this.constWaterGravityMultiplier;
		}
	}
	this.game.movedz = this.movedz;
	if (this.constEnableAcceleration) {
		this.curspeed.x *= this.acceleration.acceleration1;
		this.curspeed.y *= this.acceleration.acceleration1;
		this.curspeed.z *= this.acceleration.acceleration1;
		this.curspeed.x = ScriptCharacterPhysics.makeCloserToZero(this.curspeed.x, this.acceleration.acceleration2 * dt);
		this.curspeed.y = ScriptCharacterPhysics.makeCloserToZero(this.curspeed.y, this.acceleration.acceleration2 * dt);
		this.curspeed.z = ScriptCharacterPhysics.makeCloserToZero(this.curspeed.z, this.acceleration.acceleration2 * dt);
		diff1.y += move.moveup ? 2 * this.movespeednow * dt : 0;
		diff1.y -= move.movedown ? 2 * this.movespeednow * dt : 0;
		this.curspeed.x += diff1.x * this.acceleration.acceleration3 * dt;
		this.curspeed.y += diff1.y * this.acceleration.acceleration3 * dt;
		this.curspeed.z += diff1.z * this.acceleration.acceleration3 * dt;
		if (this.curspeed.length() > this.movespeednow) {
			this.curspeed.normalize();
			this.curspeed.x *= this.movespeednow;
			this.curspeed.y *= this.movespeednow;
			this.curspeed.z *= this.movespeednow;
		}
	}
	else {
		if (MiscCi.vec3Length(diff1.x, diff1.y, diff1.z) > 0) {
			diff1.normalize();
		}
		this.curspeed.x = diff1.x * this.movespeednow;
		this.curspeed.y = diff1.y * this.movespeednow;
		this.curspeed.z = diff1.z * this.movespeednow;
	}
	var newposition = Vector3Ref.create(0, 0, 0);
	if (!move.freemove) {
		newposition.x = stateplayerposition.x + this.curspeed.x;
		newposition.y = stateplayerposition.y + this.curspeed.y;
		newposition.z = stateplayerposition.z + this.curspeed.z;
		if (!this.game.swimmingBody()) {
			newposition.y = stateplayerposition.y;
		}
		var diffx = newposition.x - stateplayerposition.x;
		var diffy = newposition.y - stateplayerposition.y;
		var diffz = newposition.z - stateplayerposition.z;
		var difflength = MiscCi.vec3Length(diffx, diffy, diffz);
		if (difflength > 0) {
			diffx /= difflength;
			diffy /= difflength;
			diffz /= difflength;
			diffx *= this.curspeed.length();
			diffy *= this.curspeed.length();
			diffz *= this.curspeed.length();
		}
		newposition.x = stateplayerposition.x + diffx * dt;
		newposition.y = stateplayerposition.y + diffy * dt;
		newposition.z = stateplayerposition.z + diffz * dt;
	}
	else {
		newposition.x = stateplayerposition.x + this.curspeed.x * dt;
		newposition.y = stateplayerposition.y + this.curspeed.y * dt;
		newposition.z = stateplayerposition.z + this.curspeed.z * dt;
	}
	newposition.y += this.movedz * dt;
	var previousposition = Vector3Ref.create(stateplayerposition.x, stateplayerposition.y, stateplayerposition.z);
	if (!move.noclip) {
		var v = this.wallSlide(Vec3.fromValues(stateplayerposition.x, stateplayerposition.y, stateplayerposition.z), Vec3.fromValues(newposition.x, newposition.y, newposition.z), modelheight);
		stateplayerposition.x = v[0];
		stateplayerposition.y = v[1];
		stateplayerposition.z = v[2];
	}
	else {
		stateplayerposition.x = newposition.x;
		stateplayerposition.y = newposition.y;
		stateplayerposition.z = newposition.z;
	}
	if (!move.freemove) {
		if (this.isplayeronground || this.game.swimmingBody()) {
			this.jumpacceleration = 0;
			this.movedz = 0;
		}
		if ((move.wantsjump || move.wantsjumphalf) && (this.jumpacceleration == 0 && this.isplayeronground || this.game.swimmingBody()) && loaded && !this.game.swimmingEyes()) {
			this.jumpacceleration = move.wantsjumphalf ? this.jumpstartaccelerationhalf : this.jumpstartacceleration;
			soundnow.value = true;
		}
		if (this.jumpacceleration > 0) {
			this.isplayeronground = false;
			this.jumpacceleration = this.jumpacceleration / (2);
		}
		{
			this.movedz += this.jumpacceleration * this.constJump;
		}
	}
	else {
		this.isplayeronground = true;
	}
	this.game.isplayeronground = this.isplayeronground;
}

ScriptCharacterPhysics.prototype.wallSlide = function(oldposition, newposition, modelheight) {
	var high = false;
	if (modelheight >= 2) {
		high = true;
	}
	oldposition[1] += this.game.constWallDistance;
	newposition[1] += this.game.constWallDistance;
	this.game.reachedwall = false;
	this.game.reachedwall_1blockhigh = false;
	this.game.reachedHalfBlock = false;
	this.tmpPlayerPosition[0] = oldposition[0];
	this.tmpPlayerPosition[1] = oldposition[1];
	this.tmpPlayerPosition[2] = oldposition[2];
	this.tmpBlockingBlockType.value = 0;
	if (this.isEmptySpaceForPlayer(high, newposition[0], this.tmpPlayerPosition[1], this.tmpPlayerPosition[2], this.tmpBlockingBlockType)) {
		this.tmpPlayerPosition[0] = newposition[0];
	}
	else {
		this.game.reachedwall = true;
		if (this.isEmptyPoint(newposition[0], this.tmpPlayerPosition[1] + 0.5, this.tmpPlayerPosition[2], null)) {
			this.game.reachedwall_1blockhigh = true;
			if (this.game.blocktypes[this.tmpBlockingBlockType.value].drawType == 11) {
				this.game.reachedHalfBlock = true;
			}
			if (this.standingOnHalfBlock(newposition[0], this.tmpPlayerPosition[1], this.tmpPlayerPosition[2])) {
				this.game.reachedHalfBlock = true;
			}
		}
	}
	if (this.isEmptySpaceForPlayer(high, this.tmpPlayerPosition[0], newposition[1], this.tmpPlayerPosition[2], this.tmpBlockingBlockType)) {
		this.tmpPlayerPosition[1] = newposition[1];
	}
	if (this.isEmptySpaceForPlayer(high, this.tmpPlayerPosition[0], this.tmpPlayerPosition[1], newposition[2], this.tmpBlockingBlockType)) {
		this.tmpPlayerPosition[2] = newposition[2];
	}
	else {
		this.game.reachedwall = true;
		if (this.isEmptyPoint(this.tmpPlayerPosition[0], this.tmpPlayerPosition[1] + 0.5, newposition[2], null)) {
			this.game.reachedwall_1blockhigh = true;
			if (this.game.blocktypes[this.tmpBlockingBlockType.value].drawType == 11) {
				this.game.reachedHalfBlock = true;
			}
			if (this.standingOnHalfBlock(this.tmpPlayerPosition[0], this.tmpPlayerPosition[1], newposition[2])) {
				this.game.reachedHalfBlock = true;
			}
		}
	}
	this.isplayeronground = this.tmpPlayerPosition[1] == oldposition[1] && newposition[1] < oldposition[1];
	this.tmpPlayerPosition[1] -= this.game.constWallDistance;
	return this.tmpPlayerPosition;
}

function ScriptManager()
{
}

function SendPacketAction()
{
	this.client = 0;
	this.packet = null;
	this.server = null;
}
SendPacketAction.prototype = new Action_();

SendPacketAction.create = function(server_, client_, packet_) {
	var a = new SendPacketAction();
	a.server = server_;
	a.client = client_;
	a.packet = packet_;
	return a;
}

SendPacketAction.prototype.run = function() {
	this.server.sendPacket(this.client, this.packet);
}

function ServerCi()
{
	this.mainSockets = null;
	this.mainSocketsCount = 0;
	this.one = null;
	this.one = 1;
	this.mainSocketsCount = 3;
}

function ServerInformation()
{
	this.serverMotd = null;
	this.serverName = null;
	this.serverPing = null;
	this.connectdata = null;
	this.serverName = "";
	this.serverMotd = "";
	this.connectdata = new ConnectData();
	this.serverPing = new Ping_();
}

function ServerOnList()
{
	this.gamemode = null;
	this.hash = null;
	this.ip = null;
	this.max = 0;
	this.motd = null;
	this.name = null;
	this.players = null;
	this.port = 0;
	this.thumbnailDownloading = false;
	this.thumbnailError = false;
	this.thumbnailFetched = false;
	this.users = 0;
	this.version = null;
}

function ServerPackets()
{
}

ServerPackets.answerQuery = function(answer) {
	var p = new Packet_Server();
	p.id = 64;
	p.queryAnswer = answer;
	return p;
}

ServerPackets.blockType = function(id, blockType) {
	var p = new Packet_Server();
	p.id = 56;
	p.blockType = new Packet_ServerBlockType();
	p.blockType.id = id;
	p.blockType.blocktype = blockType;
	return p;
}

ServerPackets.blockTypes = function() {
	var p = new Packet_Server();
	p.id = 27;
	p.blockTypes = new Packet_ServerBlockTypes();
	return p;
}

ServerPackets.chunkPart = function(compressedChunkPart) {
	var p = new Packet_Server();
	p.id = 57;
	p.chunkPart = new Packet_ServerChunkPart();
	p.chunkPart.compressedChunkPart = compressedChunkPart;
	return p;
}

ServerPackets.chunk_ = function(x, y, z, chunksize) {
	var p = new Packet_Server();
	p.id = 15;
	p.chunk_ = new Packet_ServerChunk();
	p.chunk_.x = x;
	p.chunk_.y = y;
	p.chunk_.z = z;
	p.chunk_.sizeX = chunksize;
	p.chunk_.sizeY = chunksize;
	p.chunk_.sizeZ = chunksize;
	return p;
}

ServerPackets.disconnectPlayer = function(disconnectReason) {
	var p = new Packet_Server();
	p.id = 14;
	p.disconnectPlayer = new Packet_ServerDisconnectPlayer();
	p.disconnectPlayer.disconnectReason = disconnectReason;
	return p;
}

ServerPackets.entityDespawn = function(id) {
	var p = new Packet_Server();
	p.id = 68;
	p.entityDespawn = new Packet_ServerEntityDespawn();
	p.entityDespawn.id = id;
	return p;
}

ServerPackets.entityPositionAndOrientation = function(id, positionAndOrientation) {
	var p = new Packet_Server();
	p.id = 67;
	p.entityPosition = new Packet_ServerEntityPositionAndOrientation();
	p.entityPosition.id = id;
	p.entityPosition.positionAndOrientation = positionAndOrientation;
	return p;
}

ServerPackets.entitySpawn = function(id, entity) {
	var p = new Packet_Server();
	p.id = 66;
	p.entitySpawn = new Packet_ServerEntitySpawn();
	p.entitySpawn.id = id;
	p.entitySpawn.entity_ = entity;
	return p;
}

ServerPackets.identification = function(assignedClientId, mapSizeX, mapSizeY, mapSizeZ, version) {
	var p = new Packet_Server();
	p.id = 0;
	p.identification = new Packet_ServerIdentification();
	p.identification.assignedClientId = assignedClientId;
	p.identification.mapSizeX = mapSizeX;
	p.identification.mapSizeY = mapSizeY;
	p.identification.mapSizeZ = mapSizeZ;
	p.identification.serverName = "Simple";
	p.identification.mdProtocolVersion = version;
	return p;
}

ServerPackets.inventory = function(inventory) {
	var p = new Packet_Server();
	p.id = 16;
	p.inventory = new Packet_ServerInventory();
	p.inventory.inventory = inventory;
	return p;
}

ServerPackets.levelFinalize = function() {
	var p = new Packet_Server();
	p.id = 4;
	p.levelFinalize = new Packet_ServerLevelFinalize();
	return p;
}

ServerPackets.levelInitialize = function() {
	var p = new Packet_Server();
	p.id = 2;
	p.levelInitialize = new Packet_ServerLevelInitialize();
	return p;
}

ServerPackets.message = function(text) {
	var p = new Packet_Server();
	p.id = 13;
	p.message = new Packet_ServerMessage();
	p.message.message = text;
	return p;
}

ServerPackets.ping = function() {
	var p = new Packet_Server();
	p.id = 1;
	p.ping = new Packet_ServerPing();
	return p;
}

ServerPackets.playerStats = function(health, maxHealth, oxygen, maxOxygen) {
	var p = new Packet_Server();
	p.id = 23;
	p.playerStats = new Packet_ServerPlayerStats();
	p.playerStats.currentHealth = health;
	p.playerStats.maxHealth = maxHealth;
	p.playerStats.currentOxygen = oxygen;
	p.playerStats.maxOxygen = maxOxygen;
	return p;
}

ServerPackets.serialize = function(packet, retLength) {
	var ms = new CitoMemoryStream();
	Packet_ServerSerializer.serialize(ms, packet);
	var data = ms.toArray();
	retLength.value = ms.length();
	return data;
}

ServerPackets.setBlock = function(x, y, z, block) {
	var p = new Packet_Server();
	p.id = 6;
	p.setBlock = new Packet_ServerSetBlock();
	p.setBlock.x = x;
	p.setBlock.y = y;
	p.setBlock.z = z;
	p.setBlock.blockType = block;
	return p;
}

function ServerSimple()
{
	this.mapSizeX = 0;
	this.mapSizeY = 0;
	this.mapSizeZ = 0;
	this.actions = null;
	this.blockTypes = null;
	this.blockTypesCount = 0;
	this.chunkdrawdistance = 0;
	this.chunks = null;
	this.clients = null;
	this.clientsCount = 0;
	this.mainThreadActions = null;
	this.mainThreadActionsLock = null;
	this.mods = null;
	this.modsCount = 0;
	this.one = null;
	this.platform = null;
	this.saveFilename = null;
	this.server = null;
	this.spawnGlX = 0;
	this.spawnGlY = 0;
	this.spawnGlZ = 0;
	this.one = 1;
	this.clients = new Array(256);
	this.clientsCount = 0;
	this.blockTypes = new Array(1024);
	this.blockTypesCount = 0;
	this.mods = new Array(128);
	var m = new ModManagerSimple1();
	m.start(this);
	this.mods[this.modsCount++] = new ModSimpleDefault();
	this.mods[this.modsCount++] = new ModSimpleWorldGenerator();
	for (var i = 0; i < this.modsCount; i++) {
		this.mods[i].start(m);
	}
	this.mapSizeX = 8192;
	this.mapSizeY = 8192;
	this.mapSizeZ = 128;
	this.chunks = new Array(Math.floor(this.mapSizeX / 32) * Math.floor(this.mapSizeY / 32));
	this.chunkdrawdistance = 4;
	this.actions = new QueueAction();
	this.mainThreadActions = new QueueAction();
	this.spawnGlX = Math.floor(this.mapSizeX / 2);
	this.spawnGlY = this.mapSizeZ;
	for (var i = 0; i < this.modsCount; i++) {
		var spawnHeight = this.mods[i].getHeight();
		if (spawnHeight != -1) {
			this.spawnGlY = spawnHeight;
		}
	}
	this.spawnGlZ = Math.floor(this.mapSizeY / 2);
}
ServerSimple.CHUNK_SIZE = 32;

ServerSimple.prototype.move = function(from, to) {
	this.platform.monitorEnter(this.mainThreadActionsLock);
	var count = from.count;
	for (var i = 0; i < count; i++) {
		var task = from.dequeue();
		to.enqueue(task);
	}
	this.platform.monitorExit(this.mainThreadActionsLock);
}

ServerSimple.prototype.notifyInventory = function() {
	for (var i = 0; i < this.clientsCount; i++) {
		if (this.clients[i] == null) {
			continue;
		}
		if (!this.clients[i].connected) {
			continue;
		}
		if (!this.clients[i].inventoryDirty) {
			continue;
		}
		this.sendPacket(i, ServerPackets.inventory(this.clients[i].inventory));
		this.clients[i].inventoryDirty = false;
	}
}

ServerSimple.prototype.notifyMap = function() {
	for (var i = 0; i < this.clientsCount; i++) {
		if (this.clients[i] == null) {
			continue;
		}
		if (!this.clients[i].connected) {
			continue;
		}
		if (this.clients[i].notifyMapAction == null) {
			var notify = new NotifyMapAction();
			notify.server = this;
			notify.clientId = i;
			this.clients[i].notifyMapAction = notify;
			this.platform.queueUserWorkItem(notify);
		}
	}
}

ServerSimple.prototype.notifyPing = function() {
	for (var i = 0; i < this.clientsCount; i++) {
		if (this.clients[i] == null) {
			continue;
		}
		var now = this.platform.timeMillisecondsFromStart();
		if (now - this.clients[i].pingLastMilliseconds > 1000) {
			this.sendPacket(i, ServerPackets.ping());
			this.clients[i].pingLastMilliseconds = now;
		}
	}
}

ServerSimple.prototype.processActions = function() {
	this.move(this.mainThreadActions, this.actions);
	while (this.actions.count() > 0) {
		var a = this.actions.dequeue();
		a.run();
	}
}

ServerSimple.prototype.processPacket = function(client, packet) {
	switch (packet.getId()) {
	case 0:
		{
			if (packet.identification == null) {
				return;
			}
			this.sendPacket(client, ServerPackets.identification(0, this.mapSizeX, this.mapSizeY, this.mapSizeZ, this.platform.getGameVersion()));
			this.clients[client].name = packet.identification.username;
		}
		break;
	case 50:
		{
			this.sendPacket(client, ServerPackets.levelInitialize());
			for (var i = 0; i < this.blockTypesCount; i++) {
				var blocktype = this.blockTypes[i];
				if (blocktype == null) {
					blocktype = new Packet_BlockType();
				}
				this.sendPacket(client, ServerPackets.blockType(i, blocktype));
			}
			this.sendPacket(client, ServerPackets.blockTypes());
			this.sendPacket(client, ServerPackets.levelFinalize());
			for (var i = 0; i < this.clientsCount; i++) {
				if (this.clients[i] == null) {
					continue;
				}
				this.clients[i].glX = this.spawnGlX;
				this.clients[i].glY = this.spawnGlY;
				this.clients[i].glZ = this.spawnGlZ;
				var pos = new Packet_PositionAndOrientation();
				pos.x = this.platform.floatToInt(32 * this.clients[i].glX);
				pos.y = this.platform.floatToInt(32 * this.clients[i].glY);
				pos.z = this.platform.floatToInt(32 * this.clients[i].glZ);
				pos.pitch = 127;
				var e = new Packet_ServerEntity();
				e.drawModel = new Packet_ServerEntityAnimatedModel();
				e.drawModel.model_ = "player.txt";
				e.drawModel.modelHeight = this.platform.floatToInt((this.one * 17) / (10) * 32);
				e.drawModel.eyeHeight = this.platform.floatToInt((this.one * 15) / (10) * 32);
				e.position = pos;
				this.sendPacket(client, ServerPackets.entitySpawn(0, e));
				this.sendPacket(client, ServerPackets.playerStats(100, 100, 100, 100));
			}
			for (var i = 0; i < this.modsCount; i++) {
				this.mods[i].onPlayerJoin(client);
			}
			this.clients[client].connected = true;
		}
		break;
	case 13:
		{
			this.sendPacketToAll(ServerPackets.message(this.platform.stringFormat2("{0}: &f{1}", this.clients[client].name, packet.message.message)));
		}
		break;
	case 5:
		{
			var x = packet.setBlock.x;
			var y = packet.setBlock.y;
			var z = packet.setBlock.z;
			var block = packet.setBlock.blockType;
			var mode = packet.setBlock.mode;
			if (mode == 1) {
			}
			if (mode == 0) {
				this.sendPacketToAll(ServerPackets.setBlock(x, y, z, 0));
			}
			if (mode == 2) {
			}
			if (mode == 3) {
			}
		}
		break;
	case 8:
		{
			this.clients[client].glX = (this.one * packet.positionAndOrientation.x) / (32);
			this.clients[client].glY = (this.one * packet.positionAndOrientation.y) / (32);
			this.clients[client].glZ = (this.one * packet.positionAndOrientation.z) / (32);
		}
		break;
	case 51:
		{
			switch (packet.inventoryAction.action) {
			case 0:
				break;
			}
		}
		break;
	}
}

ServerSimple.prototype.processPackets = function() {
	for (;;) {
		var msg = this.server.readMessage();
		if (msg == null) {
			return;
		}
		switch (msg.type) {
		case NetworkMessageType.CONNECT:
			var c = new ClientSimple();
			c.mainSocket = this.server;
			c.connection = msg.senderConnection;
			c.chunksseen = new Array(Math.floor(this.mapSizeX / 32) * Math.floor(this.mapSizeY / 32));
			this.clients[0] = c;
			this.clientsCount = 1;
			break;
		case NetworkMessageType.DATA:
			var data = msg.message;
			var packet = new Packet_Client();
			Packet_ClientSerializer.deserializeBuffer(data, msg.messageLength, packet);
			this.processPacket(0, packet);
			break;
		case NetworkMessageType.DISCONNECT:
			break;
		}
	}
}

ServerSimple.prototype.queueMainThreadAction = function(action) {
	this.platform.monitorEnter(this.mainThreadActionsLock);
	this.mainThreadActions.enqueue(action);
	this.platform.monitorExit(this.mainThreadActionsLock);
}

ServerSimple.prototype.sendPacket = function(client, packet) {
	var length = new IntRef();
	var data = ServerPackets.serialize(packet, length);
	var msg = new INetOutgoingMessage();
	msg.write(data, length.value);
	this.clients[client].connection.sendMessage(msg, MyNetDeliveryMethod.RELIABLE_ORDERED, 0);
}

ServerSimple.prototype.sendPacketToAll = function(packet) {
	for (var i = 0; i < this.clientsCount; i++) {
		this.sendPacket(i, packet);
	}
}

ServerSimple.prototype.start = function(server_, saveFilename_, platform_) {
	this.server = server_;
	this.saveFilename = saveFilename_;
	this.platform = platform_;
	this.mainThreadActionsLock = this.platform.monitorCreate();
}

ServerSimple.prototype.update = function() {
	this.processPackets();
	this.notifyMap();
	this.notifyInventory();
	this.notifyPing();
	this.processActions();
}

function Sound_()
{
	this.audio = null;
	this.loop = false;
	this.name = null;
	this.stop = false;
	this.x = null;
	this.y = null;
	this.z = null;
	this.name = null;
	this.x = 0;
	this.y = 0;
	this.z = 0;
	this.loop = false;
	this.stop = false;
	this.audio = null;
}

function SpecialBlockId()
{
}
SpecialBlockId.EMPTY = 0;

function Speculative()
{
	this.blocktype = 0;
	this.timeMilliseconds = 0;
	this.x = 0;
	this.y = 0;
	this.z = 0;
}

function SphereModelData()
{
}

SphereModelData.calculateElements = function(radius, height, segments, rings) {
	var i = 0;
	var data = new Int32Array(new ArrayBuffer(segments * rings * 6 << 2));
	for (var y = 0; y < rings - 1; y++) {
		for (var x = 0; x < segments - 1; x++) {
			data[i++] = (y + 0) * segments + x;
			data[i++] = (y + 1) * segments + x;
			data[i++] = (y + 1) * segments + x + 1;
			data[i++] = (y + 1) * segments + x + 1;
			data[i++] = (y + 0) * segments + x + 1;
			data[i++] = (y + 0) * segments + x;
		}
	}
	return data;
}

SphereModelData.getPi = function() {
	var a = 3141592;
	return a / (1000000);
}

SphereModelData.getSphereModelData = function(radius, height, segments, rings) {
	var i = 0;
	var xyz = new Float32Array(new ArrayBuffer(rings * segments * 3 << 2));
	var uv = new Float32Array(new ArrayBuffer(rings * segments * 2 << 2));
	var rgba = new Uint8Array(new ArrayBuffer(rings * segments * 4));
	for (var y = 0; y < rings; y++) {
		var yFloat = y;
		var phiFloat = yFloat / (rings - 1) * SphereModelData.getPi();
		for (var x = 0; x < segments; x++) {
			var xFloat = x;
			var thetaFloat = xFloat / (segments - 1) * 2 * SphereModelData.getPi();
			var vxFloat = radius * Platform.sin(phiFloat) * Platform.cos(thetaFloat);
			var vyFloat = height * Platform.cos(phiFloat);
			var vzFloat = radius * Platform.sin(phiFloat) * Platform.sin(thetaFloat);
			var uFloat = xFloat / (segments - 1);
			var vFloat = yFloat / (rings - 1);
			xyz[i * 3 + 0] = vxFloat;
			xyz[i * 3 + 1] = vyFloat;
			xyz[i * 3 + 2] = vzFloat;
			uv[i * 2 + 0] = uFloat;
			uv[i * 2 + 1] = vFloat;
			rgba[i * 4 + 0] = 255;
			rgba[i * 4 + 1] = 255;
			rgba[i * 4 + 2] = 255;
			rgba[i * 4 + 3] = 255;
			i++;
		}
	}
	var data = new ModelData();
	data.setVerticesCount(segments * rings);
	data.setIndicesCount(segments * rings * 6);
	data.setXyz(xyz);
	data.setUv(uv);
	data.setRgba(rgba);
	data.setIndices(SphereModelData.calculateElements(radius, height, segments, rings));
	return data;
}

function Sprite()
{
	this.animationcount = 0;
	this.image = null;
	this.positionX = null;
	this.positionY = null;
	this.positionZ = null;
	this.size = 0;
	this.size = 40;
}

function StackMatrix4()
{
	this.count_ = 0;
	this.values = null;
	this.values = new Array(1024);
	for (var i = 0; i < 1024; i++) {
		this.values[i] = Mat4.create();
	}
}

StackMatrix4.prototype.count = function() {
	return this.count_;
}

StackMatrix4.prototype.peek = function() {
	return this.values[this.count_ - 1];
}

StackMatrix4.prototype.pop = function() {
	var ret = this.values[this.count_ - 1];
	this.count_--;
	return ret;
}

StackMatrix4.prototype.push = function(p) {
	Mat4.copy(this.values[this.count_], p);
	this.count_++;
}

function StringByteArray()
{
	this.data = null;
	this.name = null;
}

function StringTools()
{
}

StringTools.stringAppend = function(p, a, b) {
	var aLength = new IntRef();
	var aChars = p.stringToCharArray(a, aLength);
	var bLength = new IntRef();
	var bChars = p.stringToCharArray(b, bLength);
	var cChars = new Int32Array(new ArrayBuffer(aLength.value + bLength.value << 2));
	for (var i = 0; i < aLength.value; i++) {
		cChars[i] = aChars[i];
	}
	for (var i = 0; i < bLength.value; i++) {
		cChars[i + aLength.value] = bChars[i];
	}
	return p.charArrayToString(cChars, aLength.value + bLength.value);
}

StringTools.stringLength = function(p, a) {
	var aLength = new IntRef();
	var aChars = p.stringToCharArray(a, aLength);
	return aLength.value;
}

StringTools.stringStartsWith = function(p, s, b) {
	return StringTools.stringSubstring(p, s, 0, StringTools.stringLength(p, b)) == b;
}

StringTools.stringSubstring = function(p, a, start, count) {
	var aLength = new IntRef();
	var aChars = p.stringToCharArray(a, aLength);
	var bChars = new Int32Array(new ArrayBuffer(count << 2));
	for (var i = 0; i < count; i++) {
		bChars[i] = aChars[start + i];
	}
	return p.charArrayToString(bChars, count);
}

StringTools.stringSubstringToEnd = function(p, a, start) {
	return StringTools.stringSubstring(p, a, start, StringTools.stringLength(p, a) - start);
}

function SunMoonRenderer()
{
	this.imageSize = 0;
	this.day_length_in_seconds = null;
	this.hour = 0;
	this.moontexture = 0;
	this.one = null;
	this.suntexture = 0;
	this.t = null;
	this.one = 1;
	this.hour = 6;
	this.t = 0;
	this.suntexture = -1;
	this.moontexture = -1;
	this.imageSize = 96;
	this.day_length_in_seconds = 30;
}
SunMoonRenderer.prototype = new ClientMod();

SunMoonRenderer.prototype.getHour = function() {
	return this.hour;
}

SunMoonRenderer.prototype.onNewFrameDraw3d = function(game, dt) {
	var platform = game.platform;
	game.gLMatrixModeModelView();
	if (this.suntexture == -1) {
		this.suntexture = game.getTexture("sun.png");
		this.moontexture = game.getTexture("moon.png");
	}
	this.updateSunMoonPosition(game, dt);
	var posX;
	var posY;
	var posZ;
	if (!game.isNight) {
		posX = game.sunPositionX;
		posY = game.sunPositionY;
		posZ = game.sunPositionZ;
	}
	else {
		posX = game.moonPositionX;
		posY = game.moonPositionY;
		posZ = game.moonPositionZ;
	}
	posX += game.player.position.x;
	posY += game.player.position.y;
	posZ += game.player.position.z;
	game.gLPushMatrix();
	game.gLTranslate(posX, posY, posZ);
	ModDrawSprites.billboard(game);
	game.gLScale((this.one * 2) / (100), (this.one * 2) / (100), (this.one * 2) / (100));
	game.draw2dTexture(game.isNight ? this.moontexture : this.suntexture, 0, 0, this.imageSize, this.imageSize, null, 0, Game.colorFromArgb(255, 255, 255, 255), false);
	game.gLPopMatrix();
}

SunMoonRenderer.prototype.setHour = function(value) {
	this.hour = value;
	this.t = (this.hour - 6) / (this.one * 24) * 2 * Game.getPi();
}

SunMoonRenderer.prototype.updateSunMoonPosition = function(game, dt) {
	this.t += (dt * 2 * Game.getPi()) / (this.day_length_in_seconds);
	game.isNight = (this.t + 2 * Game.getPi()) % (2 * Game.getPi()) > Game.getPi();
	game.sunPositionX = game.platform.mathCos(this.t) * 20;
	game.sunPositionY = game.platform.mathSin(this.t) * 20;
	game.sunPositionZ = game.platform.mathSin(this.t) * 20;
	game.moonPositionX = game.platform.mathCos(-this.t) * 20;
	game.moonPositionY = game.platform.mathSin(-this.t) * 20;
	game.moonPositionZ = game.platform.mathSin(this.t) * 20;
}

function TableSerializer()
{
}

TableSerializer.prototype.deserialize = function(p, data, b) {
	var linesCount = new IntRef();
	var lines = p.readAllLines(data, linesCount);
	var header = null;
	var headerLength = new IntRef();
	var current = "";
	var currentI = 0;
	for (var i = 0; i < linesCount.value; i++) {
		var s = p.stringTrim(lines[i]);
		if (s == "") {
			continue;
		}
		if (p.stringStartsWithIgnoreCase(s, "//") || p.stringStartsWithIgnoreCase(s, "#")) {
			continue;
		}
		if (p.stringStartsWithIgnoreCase(s, "section=")) {
			current = p.stringReplace(s, "section=", "");
			var sHeader = p.stringTrim(lines[i + 1]);
			header = p.stringSplit(sHeader, "\t", headerLength);
			i++;
			currentI = 0;
			continue;
		}
		{
			if (header == null) {
				continue;
			}
			var ssLength = new IntRef();
			var ss = p.stringSplit(s, "\t", ssLength);
			for (var k = 0; k < ssLength.value; k++) {
				if (k >= headerLength.value) {
					continue;
				}
				b.set(current, currentI, header[k], ss[k]);
			}
			currentI++;
		}
	}
}

function TaskScheduler()
{
	this.actions = null;
	this.actions = null;
}

TaskScheduler.prototype.update = function(game, dt) {
	if (this.actions == null) {
		this.actions = new Array(game.clientmodsCount);
		for (var i = 0; i < game.clientmodsCount; i++) {
			this.actions[i] = new BackgroundAction();
		}
	}
	if (game.platform.multithreadingAvailable()) {
		for (var i = 0; i < game.clientmodsCount; i++) {
			game.clientmods[i].onReadOnlyMainThread(game, dt);
		}
		var allDone = true;
		for (var i = 0; i < game.clientmodsCount; i++) {
			if (this.actions[i] != null && this.actions[i].active && !this.actions[i].finished) {
				allDone = false;
			}
		}
		if (allDone) {
			for (var i = 0; i < game.clientmodsCount; i++) {
				game.clientmods[i].onReadWriteMainThread(game, dt);
			}
			for (var i = 0; i < game.commitActions.count; i++) {
				game.commitActions.items[i].run();
			}
			game.commitActions.clear();
			for (var i = 0; i < game.clientmodsCount; i++) {
				var a = this.actions[i];
				a.game = game;
				a.dt = dt;
				a.i = i;
				a.active = true;
				a.finished = false;
				game.platform.queueUserWorkItem(a);
			}
		}
	}
	else {
		for (var i = 0; i < game.clientmodsCount; i++) {
			game.clientmods[i].onReadOnlyMainThread(game, dt);
		}
		for (var i = 0; i < game.clientmodsCount; i++) {
			game.clientmods[i].onReadOnlyBackgroundThread(game, dt);
		}
		for (var i = 0; i < game.clientmodsCount; i++) {
			game.clientmods[i].onReadWriteMainThread(game, dt);
		}
		for (var i = 0; i < game.commitActions.count; i++) {
			game.commitActions.items[i].run();
		}
		game.commitActions.clear();
	}
}

function TcpNetClient()
{
	this.connected = null;
	this.data = null;
	this.incoming = null;
	this.platform = null;
	this.tosend = null;
	this.incoming = new QueueByte();
	this.data = new Uint8Array(new ArrayBuffer(1024));
	this.connected = new BoolRef();
}
TcpNetClient.prototype = new NetClient();

TcpNetClient.prototype.connect = function(ip, port) {
	this.platform.tcpConnect(ip, port, this.connected);
	return null;
}

TcpNetClient.prototype.doSendPacket = function(msg) {
	var packet = new Uint8Array(new ArrayBuffer(msg.messageLength + 4));
	this.writeInt(packet, 0, msg.messageLength);
	for (var i = 0; i < msg.messageLength; i++) {
		packet[i + 4] = msg.message[i];
	}
	this.platform.tcpSend(packet, msg.messageLength + 4);
}

TcpNetClient.prototype.getMessage = function() {
	if (this.incoming.count >= 4) {
		var length = new Uint8Array(new ArrayBuffer(4));
		this.incoming.peekRange(length, 4);
		var messageLength = this.readInt(length, 0);
		if (this.incoming.count >= 4 + messageLength) {
			this.incoming.dequeueRange(new Uint8Array(new ArrayBuffer(4)), 4);
			var msg = new NetIncomingMessage();
			msg.message = new Uint8Array(new ArrayBuffer(messageLength));
			msg.messageLength = messageLength;
			this.incoming.dequeueRange(msg.message, msg.messageLength);
			return msg;
		}
	}
	return null;
}
TcpNetClient.MAX_PACKET_LENGTH = 4096;

TcpNetClient.prototype.readInt = function(readBuf, readPos) {
	var n = readBuf[readPos] << 24;
	n |= readBuf[readPos + 1] << 16;
	n |= readBuf[readPos + 2] << 8;
	n |= readBuf[readPos + 3];
	return n;
}

TcpNetClient.prototype.readMessage = function() {
	if (this.connected.value) {
		while (this.tosend.count() > 0) {
			var msg = this.tosend.dequeue();
			this.doSendPacket(msg);
		}
	}
	var message = this.getMessage();
	if (message != null) {
		return message;
	}
	for (var k = 0; k < 1; k++) {
		var received = this.platform.tcpReceive(this.data, 1024);
		if (received <= 0) {
			break;
		}
		for (var i = 0; i < received; i++) {
			this.incoming.enqueue(this.data[i]);
		}
	}
	message = this.getMessage();
	if (message != null) {
		return message;
	}
	return null;
}

TcpNetClient.prototype.sendMessage = function(message, method) {
	var msg = message;
	if (!this.connected.value) {
		this.tosend.enqueue(msg);
		return;
	}
	this.doSendPacket(msg);
}

TcpNetClient.prototype.setPlatform = function(platform_) {
	this.platform = platform_;
}

TcpNetClient.prototype.start = function() {
	this.tosend = new QueueINetOutgoingMessage();
}

TcpNetClient.prototype.writeInt = function(writeBuf, writePos, n) {
	var a = n >> 24 & 255;
	var b = n >> 16 & 255;
	var c = n >> 8 & 255;
	var d = n & 255;
	writeBuf[writePos] = Game.intToByte(a);
	writeBuf[writePos + 1] = Game.intToByte(b);
	writeBuf[writePos + 2] = Game.intToByte(c);
	writeBuf[writePos + 3] = Game.intToByte(d);
}

function TerrainChunkTesselatorCi()
{
	this.atiArtifactFix = null;
	this.blockShadow = null;
	this.eNABLE_TEXTURE_TILING = false;
	this.enableSmoothLight = false;
	this.torchSideTexture = 0;
	this.torchTopTexture = 0;
	this._colorWhite = 0;
	this._texrecHeight = null;
	this._texrecLeft = null;
	this._texrecRight = null;
	this._texrecWidth = null;
	this.c_OcclusionNeighbors = null;
	this.currentChunk18 = null;
	this.currentChunkDraw16 = null;
	this.currentChunkDrawCount16 = null;
	this.currentChunkShadows18 = null;
	this.game = null;
	this.halfocc = null;
	this.isFluid = null;
	this.isLowered = null;
	this.istransparent = null;
	this.lightlevels = null;
	this.mapsizex = 0;
	this.mapsizey = 0;
	this.mapsizez = 0;
	this.maxlightInverse = null;
	this.occ = null;
	this.option_DarkenBlockSides = false;
	this.option_DoNotDrawEdges = false;
	this.ref_blockCornerHeight = null;
	this.started = false;
	this.terrainTexturesPerAtlas = 0;
	this.terrainTexturesPerAtlasInverse = null;
	this.tmpfShadowRation = null;
	this.tmpnPos = null;
	this.tmpoccupied = null;
	this.tmpshadowration = null;
	this.tmpv = null;
	this.toreturnatlas1d = null;
	this.toreturnatlas1dLength = 0;
	this.toreturnatlas1dtransparent = null;
	this.enableSmoothLight = true;
	this.eNABLE_TEXTURE_TILING = true;
	this._colorWhite = Game.colorFromArgb(255, 255, 255, 255);
	this.blockShadow = 0.6;
	this.option_DarkenBlockSides = true;
	this.option_DoNotDrawEdges = true;
	this.occ = 0.7;
	this.halfocc = 0.4;
	this.tmpnPos = new Int32Array(new ArrayBuffer(7 << 2));
	this.tmpshadowration = new Int32Array(new ArrayBuffer(9 << 2));
	this.tmpoccupied = new Array(9);
	this.tmpfShadowRation = new Float32Array(new ArrayBuffer(4 << 2));
	this.tmpv = new VecCito3i();
	this.ref_blockCornerHeight = new Float32Array(new ArrayBuffer(4 << 2));
	this.c_OcclusionNeighbors = new Array(6);
	for (var i = 0; i < 6; i++) {
		this.c_OcclusionNeighbors[i] = new Array(9);
	}
	this.c_OcclusionNeighbors[0][8] = VecCito3i.citoCtr(0, 0, 1);
	this.c_OcclusionNeighbors[0][0] = VecCito3i.citoCtr(0, -1, 1);
	this.c_OcclusionNeighbors[0][1] = VecCito3i.citoCtr(0, 1, 1);
	this.c_OcclusionNeighbors[0][2] = VecCito3i.citoCtr(-1, 0, 1);
	this.c_OcclusionNeighbors[0][3] = VecCito3i.citoCtr(1, 0, 1);
	this.c_OcclusionNeighbors[0][4] = VecCito3i.citoCtr(-1, -1, 1);
	this.c_OcclusionNeighbors[0][5] = VecCito3i.citoCtr(1, -1, 1);
	this.c_OcclusionNeighbors[0][6] = VecCito3i.citoCtr(-1, 1, 1);
	this.c_OcclusionNeighbors[0][7] = VecCito3i.citoCtr(1, 1, 1);
	this.c_OcclusionNeighbors[2][8] = VecCito3i.citoCtr(-1, 0, 0);
	this.c_OcclusionNeighbors[2][0] = VecCito3i.citoCtr(-1, 0, 1);
	this.c_OcclusionNeighbors[2][1] = VecCito3i.citoCtr(-1, 0, -1);
	this.c_OcclusionNeighbors[2][2] = VecCito3i.citoCtr(-1, -1, 0);
	this.c_OcclusionNeighbors[2][3] = VecCito3i.citoCtr(-1, 1, 0);
	this.c_OcclusionNeighbors[2][4] = VecCito3i.citoCtr(-1, -1, 1);
	this.c_OcclusionNeighbors[2][5] = VecCito3i.citoCtr(-1, 1, 1);
	this.c_OcclusionNeighbors[2][6] = VecCito3i.citoCtr(-1, -1, -1);
	this.c_OcclusionNeighbors[2][7] = VecCito3i.citoCtr(-1, 1, -1);
	this.c_OcclusionNeighbors[1][8] = VecCito3i.citoCtr(0, 0, -1);
	this.c_OcclusionNeighbors[1][0] = VecCito3i.citoCtr(0, 1, -1);
	this.c_OcclusionNeighbors[1][1] = VecCito3i.citoCtr(0, -1, -1);
	this.c_OcclusionNeighbors[1][2] = VecCito3i.citoCtr(-1, 0, -1);
	this.c_OcclusionNeighbors[1][3] = VecCito3i.citoCtr(1, 0, -1);
	this.c_OcclusionNeighbors[1][4] = VecCito3i.citoCtr(-1, 1, -1);
	this.c_OcclusionNeighbors[1][5] = VecCito3i.citoCtr(1, 1, -1);
	this.c_OcclusionNeighbors[1][6] = VecCito3i.citoCtr(-1, -1, -1);
	this.c_OcclusionNeighbors[1][7] = VecCito3i.citoCtr(1, -1, -1);
	this.c_OcclusionNeighbors[3][8] = VecCito3i.citoCtr(1, 0, 0);
	this.c_OcclusionNeighbors[3][0] = VecCito3i.citoCtr(1, 0, 1);
	this.c_OcclusionNeighbors[3][1] = VecCito3i.citoCtr(1, 0, -1);
	this.c_OcclusionNeighbors[3][2] = VecCito3i.citoCtr(1, 1, 0);
	this.c_OcclusionNeighbors[3][3] = VecCito3i.citoCtr(1, -1, 0);
	this.c_OcclusionNeighbors[3][4] = VecCito3i.citoCtr(1, 1, 1);
	this.c_OcclusionNeighbors[3][5] = VecCito3i.citoCtr(1, -1, 1);
	this.c_OcclusionNeighbors[3][6] = VecCito3i.citoCtr(1, 1, -1);
	this.c_OcclusionNeighbors[3][7] = VecCito3i.citoCtr(1, -1, -1);
	this.c_OcclusionNeighbors[4][8] = VecCito3i.citoCtr(0, -1, 0);
	this.c_OcclusionNeighbors[4][0] = VecCito3i.citoCtr(0, -1, 1);
	this.c_OcclusionNeighbors[4][1] = VecCito3i.citoCtr(0, -1, -1);
	this.c_OcclusionNeighbors[4][2] = VecCito3i.citoCtr(1, -1, 0);
	this.c_OcclusionNeighbors[4][3] = VecCito3i.citoCtr(-1, -1, 0);
	this.c_OcclusionNeighbors[4][4] = VecCito3i.citoCtr(1, -1, 1);
	this.c_OcclusionNeighbors[4][5] = VecCito3i.citoCtr(-1, -1, 1);
	this.c_OcclusionNeighbors[4][6] = VecCito3i.citoCtr(1, -1, -1);
	this.c_OcclusionNeighbors[4][7] = VecCito3i.citoCtr(-1, -1, -1);
	this.c_OcclusionNeighbors[5][8] = VecCito3i.citoCtr(0, 1, 0);
	this.c_OcclusionNeighbors[5][0] = VecCito3i.citoCtr(0, 1, 1);
	this.c_OcclusionNeighbors[5][1] = VecCito3i.citoCtr(0, 1, -1);
	this.c_OcclusionNeighbors[5][2] = VecCito3i.citoCtr(-1, 1, 0);
	this.c_OcclusionNeighbors[5][3] = VecCito3i.citoCtr(1, 1, 0);
	this.c_OcclusionNeighbors[5][4] = VecCito3i.citoCtr(-1, 1, 1);
	this.c_OcclusionNeighbors[5][5] = VecCito3i.citoCtr(1, 1, 1);
	this.c_OcclusionNeighbors[5][6] = VecCito3i.citoCtr(-1, 1, -1);
	this.c_OcclusionNeighbors[5][7] = VecCito3i.citoCtr(1, 1, -1);
}

TerrainChunkTesselatorCi.prototype.addTorch = function(x, y, z, type, tt) {
	var d_TerainRenderer = this;
	var curcolor = this._colorWhite;
	var torchsizexy = 0.16;
	var topx = 0.5 - torchsizexy / (2);
	var topy = 0.5 - torchsizexy / (2);
	var bottomx = 0.5 - torchsizexy / (2);
	var bottomy = 0.5 - torchsizexy / (2);
	topx += x;
	topy += y;
	bottomx += x;
	bottomy += y;
	if (type == 3) {
		bottomx = x - torchsizexy;
	}
	if (type == 4) {
		bottomx = x + 1;
	}
	if (type == 1) {
		bottomy = y - torchsizexy;
	}
	if (type == 2) {
		bottomy = y + 1;
	}
	var top00 = Vector3Ref.create(topx, z + 0.9, topy);
	var top01 = Vector3Ref.create(topx, z + 0.9, topy + torchsizexy);
	var top10 = Vector3Ref.create(topx + torchsizexy, z + 0.9, topy);
	var top11 = Vector3Ref.create(topx + torchsizexy, z + 0.9, topy + torchsizexy);
	if (type == 1) {
		top01.y += -0.1;
		top11.y += -0.1;
	}
	if (type == 2) {
		top10.y += -0.1;
		top00.y += -0.1;
	}
	if (type == 3) {
		top10.y += -0.1;
		top11.y += -0.1;
	}
	if (type == 4) {
		top01.y += -0.1;
		top00.y += -0.1;
	}
	var bottom00 = Vector3Ref.create(bottomx, z + 0, bottomy);
	var bottom01 = Vector3Ref.create(bottomx, z + 0, bottomy + torchsizexy);
	var bottom10 = Vector3Ref.create(bottomx + torchsizexy, z + 0, bottomy);
	var bottom11 = Vector3Ref.create(bottomx + torchsizexy, z + 0, bottomy + torchsizexy);
	{
		var sidetexture = this.torchTopTexture;
		var texrecTop = this.terrainTexturesPerAtlasInverse * sidetexture % this.terrainTexturesPerAtlas;
		var texrecBottom = texrecTop + this._texrecHeight;
		var toreturn = this.getModelData(tt, sidetexture);
		var lastelement = toreturn.verticesCount;
		ModelDataTool.addVertex(toreturn, top00.x, top00.y, top00.z, this._texrecLeft, texrecTop, curcolor);
		ModelDataTool.addVertex(toreturn, top01.x, top01.y, top01.z, this._texrecLeft, texrecBottom, curcolor);
		ModelDataTool.addVertex(toreturn, top10.x, top10.y, top10.z, this._texrecRight, texrecTop, curcolor);
		ModelDataTool.addVertex(toreturn, top11.x, top11.y, top11.z, this._texrecRight, texrecBottom, curcolor);
		ModelDataTool.addIndex(toreturn, lastelement + 0);
		ModelDataTool.addIndex(toreturn, lastelement + 1);
		ModelDataTool.addIndex(toreturn, lastelement + 2);
		ModelDataTool.addIndex(toreturn, lastelement + 1);
		ModelDataTool.addIndex(toreturn, lastelement + 3);
		ModelDataTool.addIndex(toreturn, lastelement + 2);
	}
	{
		var sidetexture = this.torchSideTexture;
		var texrecTop = this.terrainTexturesPerAtlasInverse * sidetexture % this.terrainTexturesPerAtlas;
		var texrecBottom = texrecTop + this._texrecHeight;
		var toreturn = this.getModelData(tt, sidetexture);
		var lastelement = toreturn.verticesCount;
		ModelDataTool.addVertex(toreturn, bottom00.x, bottom00.y, bottom00.z, this._texrecLeft, texrecTop, curcolor);
		ModelDataTool.addVertex(toreturn, bottom01.x, bottom01.y, bottom01.z, this._texrecLeft, texrecBottom, curcolor);
		ModelDataTool.addVertex(toreturn, bottom10.x, bottom10.y, bottom10.z, this._texrecRight, texrecTop, curcolor);
		ModelDataTool.addVertex(toreturn, bottom11.x, bottom11.y, bottom11.z, this._texrecRight, texrecBottom, curcolor);
		ModelDataTool.addIndex(toreturn, lastelement + 1);
		ModelDataTool.addIndex(toreturn, lastelement + 0);
		ModelDataTool.addIndex(toreturn, lastelement + 2);
		ModelDataTool.addIndex(toreturn, lastelement + 3);
		ModelDataTool.addIndex(toreturn, lastelement + 1);
		ModelDataTool.addIndex(toreturn, lastelement + 2);
	}
	{
		var sidetexture = this.torchSideTexture;
		var texrecTop = this.terrainTexturesPerAtlasInverse * sidetexture % this.terrainTexturesPerAtlas;
		var texrecBottom = texrecTop + this._texrecHeight;
		var toreturn = this.getModelData(tt, sidetexture);
		var lastelement = toreturn.verticesCount;
		ModelDataTool.addVertex(toreturn, bottom00.x, bottom00.y, bottom00.z, this._texrecLeft, texrecBottom, curcolor);
		ModelDataTool.addVertex(toreturn, bottom01.x, bottom01.y, bottom01.z, this._texrecRight, texrecBottom, curcolor);
		ModelDataTool.addVertex(toreturn, top00.x, top00.y, top00.z, this._texrecLeft, texrecTop, curcolor);
		ModelDataTool.addVertex(toreturn, top01.x, top01.y, top01.z, this._texrecRight, texrecTop, curcolor);
		ModelDataTool.addIndex(toreturn, lastelement + 0);
		ModelDataTool.addIndex(toreturn, lastelement + 1);
		ModelDataTool.addIndex(toreturn, lastelement + 2);
		ModelDataTool.addIndex(toreturn, lastelement + 1);
		ModelDataTool.addIndex(toreturn, lastelement + 3);
		ModelDataTool.addIndex(toreturn, lastelement + 2);
	}
	{
		var sidetexture = this.torchSideTexture;
		var texrecTop = this.terrainTexturesPerAtlasInverse * sidetexture % this.terrainTexturesPerAtlas;
		var texrecBottom = texrecTop + this._texrecHeight;
		var toreturn = this.getModelData(tt, sidetexture);
		var lastelement = toreturn.verticesCount;
		ModelDataTool.addVertex(toreturn, bottom10.x, bottom10.y, bottom10.z, this._texrecRight, texrecBottom, curcolor);
		ModelDataTool.addVertex(toreturn, bottom11.x, bottom11.y, bottom11.z, this._texrecLeft, texrecBottom, curcolor);
		ModelDataTool.addVertex(toreturn, top10.x, top10.y, top10.z, this._texrecRight, texrecTop, curcolor);
		ModelDataTool.addVertex(toreturn, top11.x, top11.y, top11.z, this._texrecLeft, texrecTop, curcolor);
		ModelDataTool.addIndex(toreturn, lastelement + 1);
		ModelDataTool.addIndex(toreturn, lastelement + 0);
		ModelDataTool.addIndex(toreturn, lastelement + 2);
		ModelDataTool.addIndex(toreturn, lastelement + 3);
		ModelDataTool.addIndex(toreturn, lastelement + 1);
		ModelDataTool.addIndex(toreturn, lastelement + 2);
	}
	{
		var sidetexture = this.torchSideTexture;
		var texrecTop = this.terrainTexturesPerAtlasInverse * sidetexture % this.terrainTexturesPerAtlas;
		var texrecBottom = texrecTop + this._texrecHeight;
		var toreturn = this.getModelData(tt, sidetexture);
		var lastelement = toreturn.verticesCount;
		ModelDataTool.addVertex(toreturn, bottom00.x, bottom00.y, bottom00.z, this._texrecRight, texrecBottom, curcolor);
		ModelDataTool.addVertex(toreturn, top00.x, top00.y, top00.z, this._texrecRight, texrecTop, curcolor);
		ModelDataTool.addVertex(toreturn, bottom10.x, bottom10.y, bottom10.z, this._texrecLeft, texrecBottom, curcolor);
		ModelDataTool.addVertex(toreturn, top10.x, top10.y, top10.z, this._texrecLeft, texrecTop, curcolor);
		ModelDataTool.addIndex(toreturn, lastelement + 0);
		ModelDataTool.addIndex(toreturn, lastelement + 1);
		ModelDataTool.addIndex(toreturn, lastelement + 2);
		ModelDataTool.addIndex(toreturn, lastelement + 1);
		ModelDataTool.addIndex(toreturn, lastelement + 3);
		ModelDataTool.addIndex(toreturn, lastelement + 2);
	}
	{
		var sidetexture = this.torchSideTexture;
		var texrecTop = this.terrainTexturesPerAtlasInverse * sidetexture % this.terrainTexturesPerAtlas;
		var texrecBottom = texrecTop + this._texrecHeight;
		var toreturn = this.getModelData(tt, sidetexture);
		var lastelement = toreturn.verticesCount;
		ModelDataTool.addVertex(toreturn, bottom01.x, bottom01.y, bottom01.z, this._texrecLeft, texrecBottom, curcolor);
		ModelDataTool.addVertex(toreturn, top01.x, top01.y, top01.z, this._texrecLeft, texrecTop, curcolor);
		ModelDataTool.addVertex(toreturn, bottom11.x, bottom11.y, bottom11.z, this._texrecRight, texrecBottom, curcolor);
		ModelDataTool.addVertex(toreturn, top11.x, top11.y, top11.z, this._texrecRight, texrecTop, curcolor);
		ModelDataTool.addIndex(toreturn, lastelement + 1);
		ModelDataTool.addIndex(toreturn, lastelement + 0);
		ModelDataTool.addIndex(toreturn, lastelement + 2);
		ModelDataTool.addIndex(toreturn, lastelement + 3);
		ModelDataTool.addIndex(toreturn, lastelement + 1);
		ModelDataTool.addIndex(toreturn, lastelement + 2);
	}
}

TerrainChunkTesselatorCi.prototype.addVertex = function(model, x, y, z, u, v, color) {
	model.xyz[model.getXyzCount() + 0] = x;
	model.xyz[model.getXyzCount() + 1] = y;
	model.xyz[model.getXyzCount() + 2] = z;
	model.uv[model.getUvCount() + 0] = u;
	model.uv[model.getUvCount() + 1] = v;
	model.rgba[model.getRgbaCount() + 0] = Game.intToByte(Game.colorR(color));
	model.rgba[model.getRgbaCount() + 1] = Game.intToByte(Game.colorG(color));
	model.rgba[model.getRgbaCount() + 2] = Game.intToByte(Game.colorB(color));
	model.rgba[model.getRgbaCount() + 3] = Game.intToByte(Game.colorA(color));
	model.verticesCount++;
}

TerrainChunkTesselatorCi.prototype.buildBlockFace = function(x, y, z, tileType, vOffsetX, vOffsetY, vOffsetZ, vScaleX, vScaleY, vScaleZ, currentChunk, tileSide) {
	var xx = x % 16 + 1;
	var yy = y % 16 + 1;
	var zz = z % 16 + 1;
	var vNeighbors = this.c_OcclusionNeighbors[tileSide];
	var shadowration = this.tmpshadowration;
	var occupied = this.tmpoccupied;
	var shadowratio = this.getShadowRatio(vNeighbors[8].x + xx, vNeighbors[8].y + yy, vNeighbors[8].z + zz);
	var fShadowRation = this.tmpfShadowRation;
	var shadowratiomain = this.lightlevels[shadowratio];
	fShadowRation[0] = shadowratiomain;
	fShadowRation[1] = shadowratiomain;
	fShadowRation[2] = shadowratiomain;
	fShadowRation[3] = shadowratiomain;
	if (this.enableSmoothLight) {
		for (var i = 0; i < 9; i++) {
			var vPosX = vNeighbors[i].x + xx;
			var vPosY = vNeighbors[i].y + yy;
			var vPosZ = vNeighbors[i].z + zz;
			var nBlockType = currentChunk[(vPosZ * 18 + vPosY) * 18 + vPosX];
			if (nBlockType != 0) {
				occupied[i] = !this.isTransparentForLight(nBlockType);
				shadowration[i] = shadowratio;
			}
			else {
				occupied[i] = false;
				shadowration[i] = this.getShadowRatio(vPosX, vPosY, vPosZ);
			}
		}
		this.calcShadowRation(0, 2, 4, 0, fShadowRation, occupied, shadowration);
		this.calcShadowRation(0, 3, 5, 1, fShadowRation, occupied, shadowration);
		this.calcShadowRation(1, 2, 6, 2, fShadowRation, occupied, shadowration);
		this.calcShadowRation(1, 3, 7, 3, fShadowRation, occupied, shadowration);
	}
	else {
	}
	this.drawBlockFace(x, y, z, tileType, tileSide, vOffsetX, vOffsetY, vOffsetZ, vScaleX, vScaleY, vScaleZ, vNeighbors, fShadowRation);
}

TerrainChunkTesselatorCi.prototype.buildBlockPolygons = function(x, y, z) {
	for (var xx = 0; xx < 16; xx++) {
		for (var yy = 0; yy < 16; yy++) {
			for (var zz = 0; zz < 16; zz++) {
				if (this.currentChunkDraw16[(zz * 16 + yy) * 16 + xx] != 0) {
					var xxx = x * 16 + xx;
					var yyy = y * 16 + yy;
					var zzz = z * 16 + zz;
					this.buildSingleBlockPolygon(xxx, yyy, zzz, this.currentChunk18);
				}
			}
		}
	}
}

TerrainChunkTesselatorCi.prototype.buildSingleBlockPolygon = function(x, y, z, currentChunk) {
	for (var i = 0; i < 4; i++) {
		this.ref_blockCornerHeight[i] = 0;
	}
	var xx = x % 16 + 1;
	var yy = y % 16 + 1;
	var zz = z % 16 + 1;
	var nToDraw = this.getToDrawFlags(xx, yy, zz);
	var tiletype = currentChunk[(zz * 18 + yy) * 18 + xx];
	var vOffsetX = 0;
	var vOffsetY = 0;
	var vOffsetZ = 0;
	var vScaleX = 1;
	var vScaleY = 1;
	var vScaleZ = 1;
	if (!this.isvalid(tiletype)) {
		return;
	}
	if (nToDraw == 0) {
		return;
	}
	if (this.option_DoNotDrawEdges) {
		if (z == 0) {
			nToDraw &= ~2;
		}
		if (x == 0) {
			nToDraw &= ~16;
		}
		if (x == this.mapsizex - 1) {
			nToDraw &= ~32;
		}
		if (y == 0) {
			nToDraw &= ~8;
		}
		if (y == this.mapsizey - 1) {
			nToDraw &= ~4;
		}
	}
	if (this.isFlower(tiletype)) {
		nToDraw = 20;
		vScaleX = 0.9;
		vScaleY = 0.9;
		vScaleZ = 1;
		this.buildBlockFace(x, y, z, tiletype, 0.5, 0.05, 0, vScaleX, vScaleY, vScaleZ, currentChunk, 2);
		this.buildBlockFace(x, y, z, tiletype, 0.05, 0.5, 0, vScaleX, vScaleY, vScaleZ, currentChunk, 4);
		return;
	}
	else if (this.game.blocktypes[tiletype].drawType == 13) {
		var fScale = 0.875;
		var fOffset = (1 - fScale) / (2);
		var vLROffsetX = fOffset;
		var vLROffsetY = 0;
		var vLROffsetZ = 0;
		var vLRScaleX = fScale;
		var vLRScaleY = 1;
		var vLRScaleZ = 1;
		var vFBOffsetX = 0;
		var vFBOffsetY = fOffset;
		var vFBOffsetZ = 0;
		var vFBScaleX = 1;
		var vFBScaleY = fScale;
		var vFBScaleZ = 1;
		this.buildBlockFace(x, y, z, tiletype, vLROffsetX, vLROffsetY, vLROffsetZ, vLRScaleX, vLRScaleY, vLRScaleZ, currentChunk, 2);
		this.buildBlockFace(x, y, z, tiletype, vLROffsetX, vLROffsetY, vLROffsetZ, vLRScaleX, vLRScaleY, vLRScaleZ, currentChunk, 3);
		this.buildBlockFace(x, y, z, tiletype, vFBOffsetX, vFBOffsetY, vFBOffsetZ, vFBScaleX, vFBScaleY, vFBScaleZ, currentChunk, 5);
		this.buildBlockFace(x, y, z, tiletype, vFBOffsetX, vFBOffsetY, vFBOffsetZ, vFBScaleX, vFBScaleY, vFBScaleZ, currentChunk, 4);
		nToDraw = nToDraw & 3;
	}
	else if (this.game.blocktypes[tiletype].drawType == 6 || this.game.blocktypes[tiletype].drawType == 7) {
		var blnDrawn = false;
		var fOffset = 0.025;
		if (currentChunk[(zz * 18 + yy) * 18 + xx - 1] == 0 && currentChunk[(zz * 18 + yy) * 18 + xx + 1] == 0) {
			nToDraw = 8;
			vOffsetX = 0;
			vOffsetY = fOffset;
			vOffsetZ = 0;
			blnDrawn = true;
		}
		if (!blnDrawn || currentChunk[(zz * 18 + yy - 1) * 18 + xx] == 0 && currentChunk[(zz * 18 + yy + 1) * 18 + xx] == 0) {
			vOffsetX = fOffset;
			vOffsetY = 0;
			vOffsetZ = 0;
			nToDraw = 16;
		}
	}
	else if (this.game.blocktypes[tiletype].drawType == 10 || this.game.blocktypes[tiletype].drawType == 8) {
		var blnSideDrawn = false;
		if (currentChunk[(zz * 18 + yy) * 18 + xx - 1] != 0 || currentChunk[(zz * 18 + yy) * 18 + xx + 1] != 0) {
			this.buildBlockFace(x, y, z, tiletype, 0, -0.5, 0, vScaleX, vScaleY, vScaleZ, currentChunk, 5);
			blnSideDrawn = true;
		}
		if (!blnSideDrawn || currentChunk[(zz * 18 + yy - 1) * 18 + xx] != 0 || currentChunk[(zz * 18 + yy + 1) * 18 + xx] != 0) {
			this.buildBlockFace(x, y, z, tiletype, 0.5, 0, 0, vScaleX, vScaleY, vScaleZ, currentChunk, 2);
		}
		return;
	}
	else if (this.game.blocktypes[tiletype].drawType == 9) {
		vOffsetX = 0.025;
		vOffsetY = 0.025;
		vOffsetZ = 0;
		vScaleX = 0.95;
		vScaleY = 0.95;
		vScaleZ = 1;
		nToDraw = 0;
		var ladderAtPositionMatchWall = this.getBestLadderWall(xx, yy, zz, currentChunk);
		if (ladderAtPositionMatchWall < 0) {
			var ladderbelow = this.getBestLadderInDirection(xx, yy, zz, currentChunk, -1);
			var ladderabove = this.getBestLadderInDirection(xx, yy, zz, currentChunk, 1);
			if (ladderbelow != 0) {
				ladderAtPositionMatchWall = this.getBestLadderWall(xx, yy, zz + ladderbelow, currentChunk);
			}
			else if (ladderabove != 0) {
				ladderAtPositionMatchWall = this.getBestLadderWall(xx, yy, zz + ladderabove, currentChunk);
			}
		}
		switch (ladderAtPositionMatchWall) {
		case 1:
			nToDraw |= 4;
			break;
		case 2:
			nToDraw |= 16;
			break;
		case 3:
			nToDraw |= 32;
			break;
		default:
			nToDraw |= 8;
			break;
		}
	}
	else if (this.game.blocktypes[tiletype].drawType == 11) {
		vScaleX = 1;
		vScaleY = 1;
		vScaleZ = 0.5;
	}
	else if (this.game.blocktypes[tiletype].drawType == 12) {
		vScaleX = 1;
		vScaleY = 1;
		vScaleZ = 0.05;
	}
	else if (this.game.blocktypes[tiletype].drawType == 4) {
		var type = 0;
		if (this.canSupportTorch(currentChunk[(zz * 18 + yy) * 18 + xx - 1])) {
			type = 3;
		}
		if (this.canSupportTorch(currentChunk[(zz * 18 + yy) * 18 + xx + 1])) {
			type = 4;
		}
		if (this.canSupportTorch(currentChunk[(zz * 18 + yy - 1) * 18 + xx])) {
			type = 1;
		}
		if (this.canSupportTorch(currentChunk[(zz * 18 + yy + 1) * 18 + xx])) {
			type = 2;
		}
		this.torchSideTexture = this.textureId(tiletype, 2);
		this.torchTopTexture = this.textureId(tiletype, 0);
		this.addTorch(x, y, z, type, tiletype);
		return;
	}
	else if (tiletype == 8) {
		if (currentChunk[((zz - 1) * 18 + yy) * 18 + xx] == 8) {
			vOffsetX = 0;
			vOffsetY = 0;
			vOffsetZ = -0.1;
		}
		else {
			vScaleX = 1;
			vScaleY = 1;
			vScaleZ = 0.9;
		}
	}
	else {
		var rail = this.rail(tiletype);
		if (rail != 0) {
			var slope = this.getRailSlope(xx, yy, zz);
			var fSlopeMod = 1;
			vScaleX = 1;
			vScaleY = 1;
			vScaleZ = 0.3;
			if (slope == 2) {
				this.ref_blockCornerHeight[1] = fSlopeMod;
				this.ref_blockCornerHeight[3] = fSlopeMod;
			}
			else if (slope == 1) {
				this.ref_blockCornerHeight[0] = fSlopeMod;
				this.ref_blockCornerHeight[2] = fSlopeMod;
			}
			else if (slope == 3) {
				this.ref_blockCornerHeight[0] = fSlopeMod;
				this.ref_blockCornerHeight[1] = fSlopeMod;
			}
			else if (slope == 4) {
				this.ref_blockCornerHeight[2] = fSlopeMod;
				this.ref_blockCornerHeight[3] = fSlopeMod;
			}
		}
	}
	for (var i = 0; i < 6; i++) {
		if ((nToDraw & TileSideEnum.toFlags(i)) != 0) {
			this.buildBlockFace(x, y, z, tiletype, vOffsetX, vOffsetY, vOffsetZ, vScaleX, vScaleY, vScaleZ, currentChunk, i);
		}
	}
}

TerrainChunkTesselatorCi.prototype.calcShadowRation = function(nDir1, nDir2, nDirBetween, nCorner, fShadowRation, occupied, shadowRationInt) {
	if (occupied[nDir1] && occupied[nDir2]) {
		fShadowRation[nCorner] *= this.halfocc;
	}
	else {
		var facesconsidered = 1;
		if (!occupied[nDir1]) {
			fShadowRation[nCorner] += this.lightlevels[shadowRationInt[nDir1]];
			facesconsidered++;
		}
		if (!occupied[nDir2]) {
			fShadowRation[nCorner] += this.lightlevels[shadowRationInt[nDir2]];
			facesconsidered++;
		}
		if (!occupied[nDirBetween]) {
			fShadowRation[nCorner] += this.lightlevels[shadowRationInt[nDirBetween]];
			facesconsidered++;
		}
		fShadowRation[nCorner] /= facesconsidered;
		if (occupied[nDir1] || occupied[nDir2] || occupied[nDirBetween]) {
			fShadowRation[nCorner] *= this.occ;
		}
	}
}

TerrainChunkTesselatorCi.prototype.calculateTilingCount = function(currentChunk, startx, starty, startz) {
	for (var i = 0; i < 4096; i++) {
		if (this.currentChunkDrawCount16[i] == null) {
			this.currentChunkDrawCount16[i] = new Uint8Array(new ArrayBuffer(6));
		}
		this.currentChunkDrawCount16[i][0] = 0;
		this.currentChunkDrawCount16[i][1] = 0;
		this.currentChunkDrawCount16[i][2] = 0;
		this.currentChunkDrawCount16[i][3] = 0;
		this.currentChunkDrawCount16[i][4] = 0;
		this.currentChunkDrawCount16[i][5] = 0;
	}
	{
		var currentChunk_ = currentChunk;
		for (var zz = 1; zz < 17; zz++) {
			for (var yy = 1; yy < 17; yy++) {
				var pos = (zz * 18 + yy) * 18 + 0;
				for (var xx = 1; xx < 17; xx++) {
					var tt = currentChunk_[pos + xx];
					if (tt == 0) {
						continue;
					}
					var x = startx + xx - 1;
					var y = starty + yy - 1;
					var z = startz + zz - 1;
					var draw = this.currentChunkDraw16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1];
					if (draw == 0) {
						continue;
					}
					if ((draw & 1) != 0) {
						var shadowratioTop = this.getShadowRatio(xx, yy, zz + 1);
						this.currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1][0] = 1;
					}
					if ((draw & 2) != 0) {
						var shadowratioTop = this.getShadowRatio(xx, yy, zz - 1);
						this.currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1][1] = 1;
					}
					if ((draw & 4) != 0) {
						var shadowratioTop = this.getShadowRatio(xx - 1, yy, zz);
						this.currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1][2] = 1;
					}
					if ((draw & 8) != 0) {
						var shadowratioTop = this.getShadowRatio(xx + 1, yy, zz);
						this.currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1][3] = 1;
					}
					if ((draw & 16) != 0) {
						var shadowratioTop = this.getShadowRatio(xx, yy - 1, zz);
						this.currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1][4] = 1;
					}
					if ((draw & 32) != 0) {
						var shadowratioTop = this.getShadowRatio(xx, yy + 1, zz);
						this.currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1][5] = 1;
					}
				}
			}
		}
	}
}

TerrainChunkTesselatorCi.prototype.calculateVisibleFaces = function(currentChunk) {
	var movez = 324;
	for (var zz = 1; zz < 17; zz++) {
		for (var yy = 1; yy < 17; yy++) {
			var posstart = (zz * 18 + yy) * 18 + 0;
			for (var xx = 1; xx < 17; xx++) {
				var pos = posstart + xx;
				var tt = currentChunk[pos];
				if (tt == 0) {
					continue;
				}
				var draw = 0;
				var nPos = this.tmpnPos;
				nPos[0] = pos + movez;
				nPos[1] = pos - movez;
				nPos[5] = pos + 18;
				nPos[4] = pos - 18;
				nPos[2] = pos - 1;
				nPos[3] = pos + 1;
				var blnIsFluid = this.isFluid[tt];
				var blnIsLowered = this.isLowered[tt];
				draw |= this.getFaceVisibility(0, currentChunk, nPos, blnIsFluid, blnIsLowered);
				draw |= this.getFaceVisibility(1, currentChunk, nPos, blnIsFluid, blnIsLowered);
				draw |= this.getFaceVisibility(2, currentChunk, nPos, blnIsFluid, blnIsLowered);
				draw |= this.getFaceVisibility(3, currentChunk, nPos, blnIsFluid, blnIsLowered);
				draw |= this.getFaceVisibility(4, currentChunk, nPos, blnIsFluid, blnIsLowered);
				draw |= this.getFaceVisibility(5, currentChunk, nPos, blnIsFluid, blnIsLowered);
				if (blnIsLowered && draw > 0) {
					if (!TileSideFlagsEnum.hasFlag(draw, 1)) {
						if (TileSideFlagsEnum.hasFlag(draw, 60)) {
							draw |= 1;
						}
					}
					var nRail = this.rail(tt);
					if (nRail > 0) {
						var nSlope = this.getRailSlope(xx, yy, zz);
						switch (nSlope) {
						case 4:
							draw |= 52;
							break;
						case 3:
							draw |= 56;
							break;
						case 1:
							draw |= 28;
							break;
						case 2:
							draw |= 44;
							break;
						}
					}
				}
				this.currentChunkDraw16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1] = Game.intToByte(draw);
			}
		}
	}
}

TerrainChunkTesselatorCi.prototype.canSupportTorch = function(blocktype) {
	return blocktype != 0 && this.game.blocktypes[blocktype].drawType != 4;
}

TerrainChunkTesselatorCi.prototype.colorMultiply = function(color, fValue) {
	return Game.colorFromArgb(Game.colorA(color), this.game.platform.floatToInt(Game.colorR(color) * fValue), this.game.platform.floatToInt(Game.colorG(color) * fValue), this.game.platform.floatToInt(Game.colorB(color) * fValue));
}

TerrainChunkTesselatorCi.prototype.drawBlockFace = function(x, y, z, tileType, tileSide, vOffsetX, vOffsetY, vOffsetZ, vScaleX, vScaleY, vScaleZ, vNeighbors, fShadowRation) {
	var color = this._colorWhite;
	if (this.option_DarkenBlockSides) {
		switch (tileSide) {
		case 1:
		case 2:
		case 3:
			color = this.colorMultiply(color, this.blockShadow);
			break;
		}
	}
	var sidetexture = this.textureId(tileType, tileSide);
	var toreturn = this.getModelData(tileType, sidetexture);
	var texrecTop = this.terrainTexturesPerAtlasInverse * sidetexture % this.terrainTexturesPerAtlas + this.atiArtifactFix * this.terrainTexturesPerAtlasInverse;
	var texrecBottom = texrecTop + this._texrecHeight;
	var lastelement = toreturn.verticesCount;
	var v = this.tmpv;
	var fSlopeModifier = 0;
	vNeighbors[5].add(1, 1, 1, v);
	fSlopeModifier = this.getCornerHeightModifier(tileSide, 1);
	var xPos = x + vOffsetX + v.x * 0.5 * vScaleX;
	var zPos = z + vOffsetZ + v.z * 0.5 * vScaleZ + fSlopeModifier;
	var yPos = y + vOffsetY + v.y * 0.5 * vScaleY;
	ModelDataTool.addVertex(toreturn, xPos, zPos, yPos, this._texrecRight, texrecTop, this.colorMultiply(color, fShadowRation[1]));
	vNeighbors[4].add(1, 1, 1, v);
	fSlopeModifier = this.getCornerHeightModifier(tileSide, 0);
	xPos = x + vOffsetX + v.x * 0.5 * vScaleX;
	zPos = z + vOffsetZ + v.z * 0.5 * vScaleZ + fSlopeModifier;
	yPos = y + vOffsetY + v.y * 0.5 * vScaleY;
	ModelDataTool.addVertex(toreturn, xPos, zPos, yPos, this._texrecLeft, texrecTop, this.colorMultiply(color, fShadowRation[0]));
	vNeighbors[7].add(1, 1, 1, v);
	fSlopeModifier = this.getCornerHeightModifier(tileSide, 3);
	xPos = x + vOffsetX + v.x * 0.5 * vScaleX;
	zPos = z + vOffsetZ + v.z * 0.5 * vScaleZ + fSlopeModifier;
	yPos = y + vOffsetY + v.y * 0.5 * vScaleY;
	ModelDataTool.addVertex(toreturn, xPos, zPos, yPos, this._texrecRight, texrecBottom, this.colorMultiply(color, fShadowRation[3]));
	vNeighbors[6].add(1, 1, 1, v);
	fSlopeModifier = this.getCornerHeightModifier(tileSide, 2);
	xPos = x + vOffsetX + v.x * 0.5 * vScaleX;
	zPos = z + vOffsetZ + v.z * 0.5 * vScaleZ + fSlopeModifier;
	yPos = y + vOffsetY + v.y * 0.5 * vScaleY;
	ModelDataTool.addVertex(toreturn, xPos, zPos, yPos, this._texrecLeft, texrecBottom, this.colorMultiply(color, fShadowRation[2]));
	{
		ModelDataTool.addIndex(toreturn, lastelement + 0);
		ModelDataTool.addIndex(toreturn, lastelement + 1);
		ModelDataTool.addIndex(toreturn, lastelement + 2);
		ModelDataTool.addIndex(toreturn, lastelement + 1);
		ModelDataTool.addIndex(toreturn, lastelement + 3);
		ModelDataTool.addIndex(toreturn, lastelement + 2);
	}
}

TerrainChunkTesselatorCi.prototype.getCornerHeightModifier = function(side, corner) {
	var nIndex = -1;
	switch (side) {
	case 1:
		{
			nIndex = -1;
			break;
		}
	case 3:
		switch (corner) {
		case 1:
			nIndex = 1;
			break;
		case 0:
			nIndex = 3;
			break;
		}
		break;
	case 2:
		switch (corner) {
		case 0:
			nIndex = 0;
			break;
		case 1:
			nIndex = 2;
			break;
		}
		break;
	case 5:
		switch (corner) {
		case 0:
			nIndex = 2;
			break;
		case 1:
			nIndex = 3;
			break;
		}
		break;
	case 4:
		switch (corner) {
		case 0:
			nIndex = 1;
			break;
		case 1:
			nIndex = 0;
			break;
		}
		break;
	case 0:
		nIndex = corner;
		break;
	}
	if (nIndex != -1) {
		return this.ref_blockCornerHeight[nIndex];
	}
	else {
		return 0;
	}
}

TerrainChunkTesselatorCi.prototype.getFaceVisibility = function(nSide, currentChunk, nPos, blnIsFluid, blnIsLowered) {
	var nReturn = 0;
	var nIndex = nPos[nSide];
	var tt2 = currentChunk[nIndex];
	if (tt2 == 0 || this.istransparent[tt2] && !this.isLowered[tt2] || this.isFluid[tt2] && !blnIsFluid) {
		nReturn |= TileSideEnum.toFlags(nSide);
	}
	else if (blnIsFluid && nSide != 1) {
		if (this.isFluid[currentChunk[nPos[1]]]) {
			if (!this.isFluid[tt2]) {
				var movez = 324;
				var nPos2 = nPos[nSide] - movez;
				if (nPos2 > 0 && this.isFluid[currentChunk[nPos2]]) {
					nReturn |= TileSideEnum.toFlags(nSide);
				}
			}
		}
		else {
		}
	}
	if (this.isLowered[tt2] && nSide != 0) {
		if (!blnIsLowered) {
			nReturn |= TileSideEnum.toFlags(nSide);
		}
		else if (nSide == 1) {
			nReturn |= 2;
		}
		else {
			nReturn |= 1;
		}
	}
	return nReturn;
}

TerrainChunkTesselatorCi.prototype.getFinalVerticesIndices = function(x, y, z, retCount) {
	var ret = new Array(this.toreturnatlas1dLength + this.toreturnatlas1dLength);
	retCount.value = 0;
	for (var i = 0; i < this.toreturnatlas1dLength; i++) {
		if (this.toreturnatlas1d[i].indicesCount > 0) {
			ret[retCount.value++] = this.getVerticesIndices(this.toreturnatlas1d[i], x, y, z, this.game.d_TerrainTextures.terrainTextures1d()[i % this.game.d_TerrainTextures.terrainTexturesPerAtlas()], false);
		}
	}
	for (var i = 0; i < this.toreturnatlas1dLength; i++) {
		if (this.toreturnatlas1dtransparent[i].indicesCount > 0) {
			ret[retCount.value++] = this.getVerticesIndices(this.toreturnatlas1dtransparent[i], x, y, z, this.game.d_TerrainTextures.terrainTextures1d()[i % this.game.d_TerrainTextures.terrainTexturesPerAtlas()], true);
		}
	}
	return ret;
}

TerrainChunkTesselatorCi.prototype.getModelData = function(tiletype, textureid) {
	if (this.isFluid[tiletype] || this.istransparent[tiletype] && !this.isLowered[tiletype]) {
		return this.toreturnatlas1dtransparent[Math.floor(textureid / this.game.terrainTexturesPerAtlas)];
	}
	else {
		return this.toreturnatlas1d[Math.floor(textureid / this.game.terrainTexturesPerAtlas)];
	}
}

TerrainChunkTesselatorCi.prototype.getRailSlope = function(xx, yy, zz) {
	var tiletype = this.currentChunk18[(zz * 18 + yy) * 18 + xx];
	var rail = this.rail(tiletype);
	var blocknear;
	{
		blocknear = this.currentChunk18[(zz * 18 + yy) * 18 + xx + 1];
		if (rail == 1 && blocknear != 0 && this.rail(blocknear) == 0) {
			return 2;
		}
	}
	{
		blocknear = this.currentChunk18[(zz * 18 + yy) * 18 + xx - 1];
		if (rail == 1 && blocknear != 0 && this.rail(blocknear) == 0) {
			return 1;
		}
	}
	{
		blocknear = this.currentChunk18[(zz * 18 + yy - 1) * 18 + xx];
		if (rail == 2 && blocknear != 0 && this.rail(blocknear) == 0) {
			return 3;
		}
	}
	{
		blocknear = this.currentChunk18[(zz * 18 + yy + 1) * 18 + xx];
		if (rail == 2 && blocknear != 0 && this.rail(blocknear) == 0) {
			return 4;
		}
	}
	return 0;
}

TerrainChunkTesselatorCi.prototype.getShadowRatio = function(xx, yy, zz) {
	return this.currentChunkShadows18[(zz * 18 + yy) * 18 + xx];
}

TerrainChunkTesselatorCi.prototype.getShadowRatioOld = function(xx, yy, zz, globalx, globaly, globalz) {
	return this.getShadowRatio(xx, yy, zz);
}

TerrainChunkTesselatorCi.prototype.getShadowRatioVec = function(v) {
	return this.getShadowRatio(v.x, v.y, v.z);
}

TerrainChunkTesselatorCi.prototype.getTilingCount = function(currentChunk, xx, yy, zz, tt, x, y, z, shadowratio, dir, dirflags) {
	if (!this.eNABLE_TEXTURE_TILING) {
		return 1;
	}
	if (this.istransparent[currentChunk[(zz * 18 + yy) * 18 + xx]] && !this.isTransparentFully(currentChunk[(zz * 18 + yy) * 18 + xx])) {
		return 1;
	}
	if (dir == 0 || dir == 1) {
		var shadowz = dir == 0 ? 1 : -1;
		var newxx = xx + 1;
		for (;;) {
			if (newxx >= 17) {
				break;
			}
			if (currentChunk[(zz * 18 + yy) * 18 + newxx] != tt) {
				break;
			}
			var shadowratio2 = this.getShadowRatioOld(newxx, yy, zz + shadowz, x + newxx - xx, y, z + shadowz);
			if (shadowratio != shadowratio2) {
				break;
			}
			if ((this.currentChunkDraw16[((zz - 1) * 16 + yy - 1) * 16 + newxx - 1] & dirflags) == 0) {
				break;
			}
			this.currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + newxx - 1][dir] = 0;
			this.currentChunkDraw16[((zz - 1) * 16 + yy - 1) * 16 + newxx - 1] &= Game.intToByte(~dirflags);
			newxx++;
		}
		return newxx - xx;
	}
	else if (dir == 5 || dir == 4) {
		var shadowx = dir == 5 ? -1 : 1;
		var newyy = yy + 1;
		for (;;) {
			if (newyy >= 17) {
				break;
			}
			if (currentChunk[(zz * 18 + newyy) * 18 + xx] != tt) {
				break;
			}
			var shadowratio2 = this.getShadowRatioOld(xx + shadowx, newyy, zz, x + shadowx, y + newyy - yy, z);
			if (shadowratio != shadowratio2) {
				break;
			}
			if ((this.currentChunkDraw16[((zz - 1) * 16 + newyy - 1) * 16 + xx - 1] & dirflags) == 0) {
				break;
			}
			this.currentChunkDrawCount16[((zz - 1) * 16 + newyy - 1) * 16 + xx - 1][dir] = 0;
			this.currentChunkDraw16[((zz - 1) * 16 + newyy - 1) * 16 + xx - 1] &= Game.intToByte(~dirflags);
			newyy++;
		}
		return newyy - yy;
	}
	else {
		var shadowy = dir == 2 ? -1 : 1;
		var newxx = xx + 1;
		for (;;) {
			if (newxx >= 17) {
				break;
			}
			if (currentChunk[(zz * 18 + yy) * 18 + newxx] != tt) {
				break;
			}
			var shadowratio2 = this.getShadowRatioOld(newxx, yy + shadowy, zz, x + newxx - xx, y + shadowy, z);
			if (shadowratio != shadowratio2) {
				break;
			}
			if ((this.currentChunkDraw16[((zz - 1) * 16 + yy - 1) * 16 + newxx - 1] & dirflags) == 0) {
				break;
			}
			this.currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + newxx - 1][dir] = 0;
			this.currentChunkDraw16[((zz - 1) * 16 + yy - 1) * 16 + newxx - 1] &= Game.intToByte(~dirflags);
			newxx++;
		}
		return newxx - xx;
	}
}

TerrainChunkTesselatorCi.prototype.getToDrawFlags = function(xx, yy, zz) {
	var nToDraw = 0;
	var drawFlags = this.currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1];
	nToDraw = this.setVisibleFlag(drawFlags, 0, nToDraw, 1);
	nToDraw = this.setVisibleFlag(drawFlags, 1, nToDraw, 2);
	nToDraw = this.setVisibleFlag(drawFlags, 2, nToDraw, 4);
	nToDraw = this.setVisibleFlag(drawFlags, 3, nToDraw, 8);
	nToDraw = this.setVisibleFlag(drawFlags, 4, nToDraw, 16);
	nToDraw = this.setVisibleFlag(drawFlags, 5, nToDraw, 32);
	return nToDraw;
}

TerrainChunkTesselatorCi.prototype.getVerticesIndices = function(m, x, y, z, texture, transparent) {
	var v = new VerticesIndicesToLoad();
	v.modelData = m;
	v.positionX = x * 16;
	v.positionY = y * 16;
	v.positionZ = z * 16;
	v.texture = texture;
	v.transparent = transparent;
	return v;
}

TerrainChunkTesselatorCi.prototype.isFlower = function(tiletype) {
	return this.game.blocktypes[tiletype].drawType == 5;
}

TerrainChunkTesselatorCi.prototype.isTransparentForLight = function(block) {
	var b = this.game.blocktypes[block];
	return b.drawType != 1 && b.drawType != 8;
}

TerrainChunkTesselatorCi.prototype.isTransparentFully = function(p) {
	var b = this.game.blocktypes[p];
	return b.drawType != 1 && b.drawType != 5 && b.drawType != 6 && b.drawType != 7 && b.drawType != 8;
}

TerrainChunkTesselatorCi.prototype.makeChunk = function(x, y, z, chunk18, shadows18, lightlevels_, retCount) {
	this.currentChunk18 = chunk18;
	this.currentChunkShadows18 = shadows18;
	this.lightlevels = lightlevels_;
	for (var i = 0; i < 1024; i++) {
		var b = this.game.blocktypes[i];
		if (b == null) {
			continue;
		}
		this.istransparent[i] = b.drawType != 1 && b.drawType != 3;
		if (b.drawType == 11 || b.drawType == 12 || b.getRail() != 0) {
			this.isLowered[i] = true;
		}
		this.isFluid[i] = b.drawType == 3;
	}
	if (x < 0 || y < 0 || z < 0) {
		retCount.value = 0;
		return new Array(0);
	}
	if (!this.started) {
		this.game.platform.throwException("not started");
	}
	if (x >= Math.floor(this.mapsizex / 16) || y >= Math.floor(this.mapsizey / 16) || z >= Math.floor(this.mapsizez / 16)) {
		retCount.value = 0;
		return new Array(0);
	}
	for (var i = 0; i < this.toreturnatlas1dLength; i++) {
		this.toreturnatlas1d[i].verticesCount = 0;
		this.toreturnatlas1d[i].indicesCount = 0;
		this.toreturnatlas1dtransparent[i].verticesCount = 0;
		this.toreturnatlas1dtransparent[i].indicesCount = 0;
	}
	this.calculateVisibleFaces(this.currentChunk18);
	this.calculateTilingCount(this.currentChunk18, x * 16, y * 16, z * 16);
	this.buildBlockPolygons(x, y, z);
	var ret = this.getFinalVerticesIndices(x, y, z, retCount);
	return ret;
}

TerrainChunkTesselatorCi.prototype.max = function(a, b) {
	if (a > b) {
		return a;
	}
	else {
		return b;
	}
}

TerrainChunkTesselatorCi.prototype.min = function(a, b) {
	if (a < b) {
		return a;
	}
	else {
		return b;
	}
}

TerrainChunkTesselatorCi.prototype.rail = function(tiletype) {
	return this.game.blocktypes[tiletype].rail;
}

TerrainChunkTesselatorCi.prototype.setVisibleFlag = function(drawFlags, tileSideIndex, nCurrentFlags, nFlagToSet) {
	if (drawFlags[tileSideIndex] > 0) {
		return nCurrentFlags | nFlagToSet;
	}
	else {
		return nCurrentFlags;
	}
}

TerrainChunkTesselatorCi.prototype.start = function() {
	this.currentChunk18 = new Int32Array(new ArrayBuffer(5832 << 2));
	this.currentChunkShadows18 = new Uint8Array(new ArrayBuffer(5832));
	this.currentChunkDraw16 = new Uint8Array(new ArrayBuffer(4096));
	this.currentChunkDrawCount16 = new Array(4096);
	this.mapsizex = this.game.map.mapSizeX;
	this.mapsizey = this.game.map.mapSizeY;
	this.mapsizez = this.game.map.mapSizeZ;
	this.started = true;
	this.istransparent = new Array(1024);
	for (var i = 0; i < 1024; i++) {
		this.istransparent[i] = false;
	}
	this.isLowered = new Array(1024);
	for (var i = 0; i < 1024; i++) {
		this.isLowered[i] = false;
	}
	this.isFluid = new Array(1024);
	for (var i = 0; i < 1024; i++) {
		this.isFluid[i] = false;
	}
	this.maxlightInverse = 1 / (15);
	this.terrainTexturesPerAtlas = this.game.terrainTexturesPerAtlas;
	this.terrainTexturesPerAtlasInverse = 1 / (this.game.terrainTexturesPerAtlas);
	if (this.game.platform.isFastSystem()) {
		this.atiArtifactFix = 1 / (32) * 0.25;
	}
	else {
		this.atiArtifactFix = 1 / (32) * 1.5;
	}
	this._texrecWidth = 1 - this.atiArtifactFix * 2;
	this._texrecHeight = this.terrainTexturesPerAtlasInverse * (1 - this.atiArtifactFix * 2);
	this._texrecLeft = this.atiArtifactFix;
	this._texrecRight = this._texrecLeft + this._texrecWidth;
	this.toreturnatlas1dLength = this.max(1, Math.floor(1024 / this.game.terrainTexturesPerAtlas));
	this.toreturnatlas1d = new Array(this.toreturnatlas1dLength);
	this.toreturnatlas1dtransparent = new Array(this.toreturnatlas1dLength);
	for (var i = 0; i < this.toreturnatlas1dLength; i++) {
		this.toreturnatlas1d[i] = new ModelData();
		var max = 1024;
		this.toreturnatlas1d[i].xyz = new Float32Array(new ArrayBuffer(max * 3 << 2));
		this.toreturnatlas1d[i].uv = new Float32Array(new ArrayBuffer(max * 2 << 2));
		this.toreturnatlas1d[i].rgba = new Uint8Array(new ArrayBuffer(max * 4));
		this.toreturnatlas1d[i].indices = new Int32Array(new ArrayBuffer(max << 2));
		this.toreturnatlas1d[i].verticesMax = max;
		this.toreturnatlas1d[i].indicesMax = max;
		this.toreturnatlas1dtransparent[i] = new ModelData();
		this.toreturnatlas1dtransparent[i].xyz = new Float32Array(new ArrayBuffer(max * 3 << 2));
		this.toreturnatlas1dtransparent[i].uv = new Float32Array(new ArrayBuffer(max * 2 << 2));
		this.toreturnatlas1dtransparent[i].rgba = new Uint8Array(new ArrayBuffer(max * 4));
		this.toreturnatlas1dtransparent[i].indices = new Int32Array(new ArrayBuffer(max << 2));
		this.toreturnatlas1dtransparent[i].verticesMax = max;
		this.toreturnatlas1dtransparent[i].indicesMax = max;
	}
}

TerrainChunkTesselatorCi.prototype.textureId = function(tiletype, side) {
	return this.game.textureId[tiletype][side];
}

TerrainChunkTesselatorCi.prototype.getBestLadderInDirection = function(x, y, z, currentChunk, dir) {
	var dz = dir;
	var result = 0;
	{
		while (((z + dz) * 18 + y) * 18 + x >= 0 && ((z + dz) * 18 + y) * 18 + x < 5832 && currentChunk[((z + dz) * 18 + y) * 18 + x] == 152) {
			result = dz;
			if (this.getBestLadderWall(x, y, z + dz, currentChunk) != -1)
				return result;
			dz += dir;
		}
	}
	return 0;
}

TerrainChunkTesselatorCi.prototype.getBestLadderWall = function(x, y, z, currentChunk) {
	var front = false;
	var back = false;
	var left = false;
	var wallscount = 0;
	if (currentChunk[(z * 18 + y - 1) * 18 + x] != 0) {
		front = true;
		wallscount++;
	}
	if (currentChunk[(z * 18 + y + 1) * 18 + x] != 0) {
		back = true;
		wallscount++;
	}
	var c = currentChunk[(z * 18 + y) * 18 + x - 1];
	if (c != 0) {
		left = true;
		wallscount++;
	}
	if (currentChunk[(z * 18 + y) * 18 + x + 1] != 0) {
		wallscount++;
	}
	if (wallscount != 1) {
		return -1;
	}
	else {
		if (front) {
			return 0;
		}
		else if (back) {
			return 1;
		}
		else if (left) {
			return 2;
		}
		else {
			return 3;
		}
	}
}

TerrainChunkTesselatorCi.prototype.isvalid = function(tt) {
	return this.game.blocktypes[tt].name != null;
}

function TerrainRendererCommit()
{
	this.renderer = null;
}
TerrainRendererCommit.prototype = new Action_();

TerrainRendererCommit.create = function(renderer) {
	var c = new TerrainRendererCommit();
	c.renderer = renderer;
	return c;
}

TerrainRendererCommit.prototype.run = function() {
	this.renderer.mainThreadCommit();
}

function TerrainRendererRedraw()
{
	this.c = null;
	this.data = null;
	this.dataCount = 0;
}

var TextAlign = {
	LEFT : 0,
	CENTER : 1,
	RIGHT : 2
}

var TextBaseline = {
	TOP : 0,
	MIDDLE : 1,
	BOTTOM : 2
}

function TextColorRenderer()
{
	this.platform = null;
}

TextColorRenderer.prototype.createTextTexture = function(t) {
	var partsCount = new IntRef();
	var parts = this.decodeColors(t.text, t.color, partsCount);
	var totalwidth = 0;
	var totalheight = 0;
	var sizesX = new Int32Array(new ArrayBuffer(partsCount.value << 2));
	var sizesY = new Int32Array(new ArrayBuffer(partsCount.value << 2));
	for (var i = 0; i < partsCount.value; i++) {
		var outWidth = new IntRef();
		var outHeight = new IntRef();
		this.platform.textSize(parts[i].text, t.font, outWidth, outHeight);
		sizesX[i] = outWidth.value;
		sizesY[i] = outHeight.value;
		totalwidth += outWidth.value;
		totalheight = MathCi.maxFloat(totalheight, outHeight.value);
	}
	var size2X = this.nextPowerOfTwo(this.platform.floatToInt(totalwidth) + 1);
	var size2Y = this.nextPowerOfTwo(this.platform.floatToInt(totalheight) + 1);
	var bmp2 = this.platform.bitmapCreate(size2X, size2Y);
	var bmp2Pixels = new Int32Array(new ArrayBuffer(size2X * size2Y << 2));
	var currentwidth = 0;
	for (var i = 0; i < partsCount.value; i++) {
		var sizeiX = sizesX[i];
		var sizeiY = sizesY[i];
		if (sizeiX == 0 || sizeiY == 0) {
			continue;
		}
		var partText = new Text_();
		partText.text = parts[i].text;
		partText.color = parts[i].color;
		partText.font = t.font;
		var partBmp = this.platform.createTextTexture(partText);
		var partWidth = this.platform.floatToInt(this.platform.bitmapGetWidth(partBmp));
		var partHeight = this.platform.floatToInt(this.platform.bitmapGetHeight(partBmp));
		var partBmpPixels = new Int32Array(new ArrayBuffer(partWidth * partHeight << 2));
		this.platform.bitmapGetPixelsArgb(partBmp, partBmpPixels);
		for (var x = 0; x < partWidth; x++) {
			for (var y = 0; y < partHeight; y++) {
				if (x + currentwidth >= size2X) {
					continue;
				}
				if (y >= size2Y) {
					continue;
				}
				var c = partBmpPixels[MapUtilCi.index2d(x, y, partWidth)];
				if (Game.colorA(c) > 0) {
					bmp2Pixels[MapUtilCi.index2d(this.platform.floatToInt(currentwidth) + x, y, size2X)] = c;
				}
			}
		}
		currentwidth += sizeiX;
	}
	this.platform.bitmapSetPixelsArgb(bmp2, bmp2Pixels);
	return bmp2;
}

TextColorRenderer.prototype.decodeColors = function(s, defaultcolor, retLength) {
	var messageMax = 256;
	var wordMax = 64;
	var parts = new Array(messageMax);
	var partsCount = 0;
	var currenttext = new Int32Array(new ArrayBuffer(wordMax << 2));
	var currenttextLength = 0;
	var endCurrentWord = false;
	var sLength = new IntRef();
	var sChars = this.platform.stringToCharArray(s, sLength);
	var currentColor = defaultcolor;
	var changeColor = false;
	var nextColor = defaultcolor;
	for (var i = 0; i < sLength.value; i++) {
		if (partsCount >= messageMax) {
			break;
		}
		if (endCurrentWord || currenttextLength >= wordMax) {
			if (currenttextLength > 0) {
				var part = new TextPart();
				part.text = this.platform.charArrayToString(currenttext, currenttextLength);
				part.color = currentColor;
				parts[partsCount] = part;
				partsCount++;
				currenttextLength = 0;
			}
			endCurrentWord = false;
		}
		if (changeColor) {
			currentColor = nextColor;
			changeColor = false;
		}
		if (sChars[i] == 32) {
			currenttext[currenttextLength] = sChars[i];
			currenttextLength++;
			endCurrentWord = true;
		}
		else if (sChars[i] == 38) {
			if (i + 1 < sLength.value) {
				var color = TextColorRenderer.hexToInt(sChars[i + 1]);
				if (color != -1) {
					nextColor = TextColorRenderer.getColor(color);
					changeColor = true;
					endCurrentWord = true;
					i++;
					continue;
				}
				else {
					currenttext[currenttextLength] = sChars[i];
					currenttextLength++;
				}
			}
			else {
				currenttext[currenttextLength] = sChars[i];
				currenttextLength++;
			}
		}
		else {
			currenttext[currenttextLength] = sChars[i];
			currenttextLength++;
		}
	}
	if (currenttextLength != 0 && partsCount < messageMax) {
		var part = new TextPart();
		part.text = this.platform.charArrayToString(currenttext, currenttextLength);
		part.color = currentColor;
		parts[partsCount] = part;
		partsCount++;
	}
	retLength.value = partsCount;
	return parts;
}

TextColorRenderer.getColor = function(currentcolor) {
	switch (currentcolor) {
	case 0:
		{
			return Game.colorFromArgb(255, 0, 0, 0);
		}
	case 1:
		{
			return Game.colorFromArgb(255, 0, 0, 191);
		}
	case 2:
		{
			return Game.colorFromArgb(255, 0, 191, 0);
		}
	case 3:
		{
			return Game.colorFromArgb(255, 0, 191, 191);
		}
	case 4:
		{
			return Game.colorFromArgb(255, 191, 0, 0);
		}
	case 5:
		{
			return Game.colorFromArgb(255, 191, 0, 191);
		}
	case 6:
		{
			return Game.colorFromArgb(255, 191, 191, 0);
		}
	case 7:
		{
			return Game.colorFromArgb(255, 191, 191, 191);
		}
	case 8:
		{
			return Game.colorFromArgb(255, 40, 40, 40);
		}
	case 9:
		{
			return Game.colorFromArgb(255, 64, 64, 255);
		}
	case 10:
		{
			return Game.colorFromArgb(255, 64, 255, 64);
		}
	case 11:
		{
			return Game.colorFromArgb(255, 64, 255, 255);
		}
	case 12:
		{
			return Game.colorFromArgb(255, 255, 64, 64);
		}
	case 13:
		{
			return Game.colorFromArgb(255, 255, 64, 255);
		}
	case 14:
		{
			return Game.colorFromArgb(255, 255, 255, 64);
		}
	case 15:
		{
			return Game.colorFromArgb(255, 255, 255, 255);
		}
	default:
		return Game.colorFromArgb(255, 255, 255, 255);
	}
}

TextColorRenderer.hexToInt = function(c) {
	if (c == 48) {
		return 0;
	}
	if (c == 49) {
		return 1;
	}
	if (c == 50) {
		return 2;
	}
	if (c == 51) {
		return 3;
	}
	if (c == 52) {
		return 4;
	}
	if (c == 53) {
		return 5;
	}
	if (c == 54) {
		return 6;
	}
	if (c == 55) {
		return 7;
	}
	if (c == 56) {
		return 8;
	}
	if (c == 57) {
		return 9;
	}
	if (c == 97) {
		return 10;
	}
	if (c == 98) {
		return 11;
	}
	if (c == 99) {
		return 12;
	}
	if (c == 100) {
		return 13;
	}
	if (c == 101) {
		return 14;
	}
	if (c == 102) {
		return 15;
	}
	return -1;
}

TextColorRenderer.prototype.nextPowerOfTwo = function(x) {
	x--;
	x |= x >> 1;
	x |= x >> 2;
	x |= x >> 4;
	x |= x >> 8;
	x++;
	return x;
}

function TextPart()
{
	this.color = 0;
	this.text = null;
}

function TextTexture()
{
	this.font = null;
	this.text = null;
	this.textheight = 0;
	this.texture = 0;
	this.textureheight = 0;
	this.texturewidth = 0;
	this.textwidth = 0;
}

function Text_()
{
	this.color = 0;
	this.font = null;
	this.text = null;
}

Text_.prototype.equals_ = function(t) {
	return this.text == t.text && this.color == t.color && this.font != null && t.font != null && this.font.size == t.font.size && this.font.family == t.font.family && this.font.style == t.font.style;
}

Text_.prototype.getColor = function() {
	return this.color;
}

Text_.prototype.getFont = function() {
	return this.font;
}

Text_.prototype.getFontFamily = function() {
	return this.font.family;
}

Text_.prototype.getFontSize = function() {
	return this.font.size;
}

Text_.prototype.getFontStyle = function() {
	return this.font.style;
}

Text_.prototype.getText = function() {
	return this.text;
}

Text_.prototype.setColor = function(value) {
	this.color = value;
}

Text_.prototype.setFont = function(value) {
	this.font = value;
}

Text_.prototype.setText = function(value) {
	this.text = value;
}

function Texture()
{
}

function TextureAtlas()
{
}

TextureAtlas.textureCoords2d = function(textureId, texturesPacked) {
	var one = 1;
	var r = new RectFRef();
	r.y = one / (texturesPacked) * Math.floor(textureId / texturesPacked);
	r.x = one / (texturesPacked) * textureId % texturesPacked;
	r.w = one / (texturesPacked);
	r.h = one / (texturesPacked);
	return r;
}

function TextureAtlasCi()
{
}

TextureAtlasCi.textureCoords2d = function(textureId, texturesPacked, r) {
	var one = 1;
	r.y = one / (texturesPacked) * Math.floor(textureId / texturesPacked);
	r.x = one / (texturesPacked) * textureId % texturesPacked;
	r.w = one / (texturesPacked);
	r.h = one / (texturesPacked);
}

function TextureAtlasConverter()
{
}

TextureAtlasConverter.prototype.atlas2dInto1d = function(p, atlas2d_, tiles, atlassizezlimit, retCount) {
	var orig = BitmapData_.createFromBitmap(p, atlas2d_);
	var tilesize = Math.floor(orig.width / tiles);
	var atlasescount = MathCi.maxInt(1, Math.floor(tiles * tiles * tilesize / atlassizezlimit));
	var atlases = new Array(128);
	var atlasesCount = 0;
	var atlas1d = null;
	for (var i = 0; i < tiles * tiles; i++) {
		var x = i % tiles;
		var y = Math.floor(i / tiles);
		var tilesinatlas = Math.floor(tiles * tiles / atlasescount);
		if (i % tilesinatlas == 0) {
			if (atlas1d != null) {
				atlases[atlasesCount++] = atlas1d.toBitmap(p);
			}
			atlas1d = BitmapData_.create(tilesize, atlassizezlimit);
		}
		for (var xx = 0; xx < tilesize; xx++) {
			for (var yy = 0; yy < tilesize; yy++) {
				var c = orig.getPixel(x * tilesize + xx, y * tilesize + yy);
				atlas1d.setPixel(xx, i % tilesinatlas * tilesize + yy, c);
			}
		}
	}
	atlases[atlasesCount++] = atlas1d.toBitmap(p);
	retCount.value = atlasescount;
	return atlases;
}

function ThumbnailResponseCi()
{
	this.data = null;
	this.dataLength = 0;
	this.done = false;
	this.error = false;
	this.serverMessage = null;
}

ThumbnailResponseCi.prototype.getData = function() {
	return this.data;
}

ThumbnailResponseCi.prototype.getDataLength = function() {
	return this.dataLength;
}

ThumbnailResponseCi.prototype.getDone = function() {
	return this.done;
}

ThumbnailResponseCi.prototype.getError = function() {
	return this.error;
}

ThumbnailResponseCi.prototype.getServerMessage = function() {
	return this.serverMessage;
}

ThumbnailResponseCi.prototype.setData = function(value_) {
	this.data = value_;
}

ThumbnailResponseCi.prototype.setDataLength = function(value_) {
	this.dataLength = value_;
}

ThumbnailResponseCi.prototype.setDone = function(value_) {
	this.done = value_;
}

ThumbnailResponseCi.prototype.setError = function(value_) {
	this.error = value_;
}

ThumbnailResponseCi.prototype.setServerMessage = function(value_) {
	this.serverMessage = value_;
}

function TileDirectionEnum()
{
}
TileDirectionEnum.BOTTOM = 1;
TileDirectionEnum.BOTTOM_LEFT = 6;
TileDirectionEnum.BOTTOM_RIGHT = 7;
TileDirectionEnum.CENTER = 8;
TileDirectionEnum.DIRECTION_COUNTS = 9;
TileDirectionEnum.LEFT = 2;
TileDirectionEnum.RIGHT = 3;
TileDirectionEnum.TOP = 0;
TileDirectionEnum.TOP_LEFT = 4;
TileDirectionEnum.TOP_RIGHT = 5;

function TileEnterData()
{
	this.blockPositionX = 0;
	this.blockPositionY = 0;
	this.blockPositionZ = 0;
	this.enterDirection = TileEnterDirection.UP;
}

var TileEnterDirection = {
	UP : 0,
	DOWN : 1,
	LEFT : 2,
	RIGHT : 3
}

var TileExitDirection = {
	UP : 0,
	DOWN : 1,
	LEFT : 2,
	RIGHT : 3
}

function TileSide()
{
}
TileSide.BACK = 3;
TileSide.BOTTOM = 1;
TileSide.FRONT = 2;
TileSide.LEFT = 4;
TileSide.RIGHT = 5;
TileSide.TOP = 0;

function TileSideEnum()
{
}
TileSideEnum.BACK = 4;
TileSideEnum.BOTTOM = 1;
TileSideEnum.FRONT = 5;
TileSideEnum.LEFT = 2;
TileSideEnum.RIGHT = 3;
TileSideEnum.SIDE_COUNT = 6;

TileSideEnum.toFlags = function(nValue) {
	switch (nValue) {
	case 0:
		return 1;
	case 1:
		return 2;
	case 2:
		return 16;
	case 3:
		return 32;
	case 4:
		return 8;
	case 5:
		return 4;
	default:
		return 0;
	}
}
TileSideEnum.TOP = 0;

function TileSideFlagsEnum()
{
}
TileSideFlagsEnum.BACK = 32;
TileSideFlagsEnum.BOTTOM = 2;
TileSideFlagsEnum.FRONT = 16;

TileSideFlagsEnum.hasFlag = function(nFlagA, nFlagB) {
	return (nFlagA & nFlagB) != 0;
}
TileSideFlagsEnum.LEFT = 8;
TileSideFlagsEnum.NONE = 0;
TileSideFlagsEnum.RIGHT = 4;
TileSideFlagsEnum.TOP = 1;

function TimerCi()
{
	this.accumulator = null;
	this.interval = null;
	this.maxDeltaTime = null;
	this.interval = 1;
	this.maxDeltaTime = -1;
}

TimerCi.create = function(interval_, maxDeltaTime_) {
	var timer = new TimerCi();
	timer.interval = interval_;
	timer.maxDeltaTime = maxDeltaTime_;
	return timer;
}

TimerCi.prototype.reset = function() {
	this.accumulator = 0;
}

TimerCi.prototype.update = function(dt) {
	this.accumulator += dt;
	var constDt = this.interval;
	if (this.maxDeltaTime != -1 && this.accumulator > this.maxDeltaTime) {
		this.accumulator = this.maxDeltaTime;
	}
	var updates = 0;
	while (this.accumulator >= constDt) {
		updates++;
		this.accumulator -= constDt;
	}
	return updates;
}

function ToCall()
{
	this.count = 0;
	this.lists = null;
	this.max = 0;
}

var TorchType = {
	NORMAL : 0,
	LEFT : 1,
	RIGHT : 2,
	FRONT : 3,
	BACK : 4
}

function TorchTypeEnum()
{
}
TorchTypeEnum.BACK = 4;
TorchTypeEnum.FRONT = 3;
TorchTypeEnum.LEFT = 1;
TorchTypeEnum.NORMAL = 0;
TorchTypeEnum.RIGHT = 2;

function TouchEventArgs()
{
	this.handled = false;
	this.id = 0;
	this.x = 0;
	this.y = 0;
}

TouchEventArgs.prototype.getHandled = function() {
	return this.handled;
}

TouchEventArgs.prototype.getId = function() {
	return this.id;
}

TouchEventArgs.prototype.getX = function() {
	return this.x;
}

TouchEventArgs.prototype.getY = function() {
	return this.y;
}

TouchEventArgs.prototype.setHandled = function(value) {
	this.handled = value;
}

TouchEventArgs.prototype.setId = function(value) {
	this.id = value;
}

TouchEventArgs.prototype.setX = function(value) {
	this.x = value;
}

TouchEventArgs.prototype.setY = function(value) {
	this.y = value;
}

function TranslatedString()
{
	this.id = null;
	this.language = null;
	this.translated = null;
}

var TypingState = {
	NONE : 0,
	TYPING : 1,
	READY : 2
}

function UnloadRendererChunksCommit()
{
	this.game = null;
	this.unloadChunkPos = 0;
}
UnloadRendererChunksCommit.prototype = new Action_();

UnloadRendererChunksCommit.prototype.run = function() {
	if (this.unloadChunkPos != -1) {
		var c = this.game.map.chunks[this.unloadChunkPos];
		for (var k = 0; k < c.rendered.idsCount; k++) {
			var loadedSubmesh = c.rendered.ids[k];
			this.game.d_Batcher.remove(loadedSubmesh);
		}
		c.rendered.ids = null;
		c.rendered.dirty = true;
		c.rendered.light = null;
		this.unloadChunkPos = -1;
	}
}

function Unproject()
{
	this.finalMatrix = null;
	this.inp = null;
	this.out_ = null;
	this.finalMatrix = Mat4.create();
	this.inp = new Float32Array(new ArrayBuffer(4 << 2));
	this.out_ = new Float32Array(new ArrayBuffer(4 << 2));
}

Unproject.prototype.multMatrixVec = function(matrix, inp__, out__) {
	for (var i = 0; i < 4; i = i + 1) {
		out__[i] = inp__[0] * matrix[0 + i] + inp__[1] * matrix[4 + i] + inp__[2] * matrix[8 + i] + inp__[3] * matrix[12 + i];
	}
}

Unproject.prototype.unProject = function(winX, winY, winZ, model, proj, view, objPos) {
	this.inp[0] = winX;
	this.inp[1] = winY;
	this.inp[2] = winZ;
	this.inp[3] = 1;
	Mat4.multiply(this.finalMatrix, proj, model);
	Mat4.invert(this.finalMatrix, this.finalMatrix);
	this.inp[0] = (this.inp[0] - view[0]) / (view[2]);
	this.inp[1] = (this.inp[1] - view[1]) / (view[3]);
	this.inp[0] = this.inp[0] * 2 - 1;
	this.inp[1] = this.inp[1] * 2 - 1;
	this.inp[2] = this.inp[2] * 2 - 1;
	this.multMatrixVec(this.finalMatrix, this.inp, this.out_);
	if (this.out_[3] == 0) {
		return false;
	}
	this.out_[0] /= this.out_[3];
	this.out_[1] /= this.out_[3];
	this.out_[2] /= this.out_[3];
	objPos[0] = this.out_[0];
	objPos[1] = this.out_[1];
	objPos[2] = this.out_[2];
	return true;
}

function UpDown()
{
}
UpDown.DOWN = 2;
UpDown.NONE = 0;
UpDown.UP = 1;

function UriCi()
{
	this.get = null;
	this.ip = null;
	this.port = 0;
	this.url = null;
}

UriCi.prototype.getGet = function() {
	return this.get;
}

UriCi.prototype.getIp = function() {
	return this.ip;
}

UriCi.prototype.getPort = function() {
	return this.port;
}

UriCi.prototype.getUrl = function() {
	return this.url;
}

UriCi.prototype.setGet = function(value_) {
	this.get = value_;
}

UriCi.prototype.setIp = function(value_) {
	this.ip = value_;
}

UriCi.prototype.setPort = function(value_) {
	this.port = value_;
}

UriCi.prototype.setUrl = function(value_) {
	this.url = value_;
}

function Vec2()
{
}

Vec2.add = function(output, a, b) {
	output[0] = a[0] + b[0];
	output[1] = a[1] + b[1];
	return output;
}

Vec2.cloneIt = function(a) {
	var output = new Float32Array(new ArrayBuffer(2 << 2));
	output[0] = a[0];
	output[1] = a[1];
	return output;
}

Vec2.copy = function(output, a) {
	output[0] = a[0];
	output[1] = a[1];
	return output;
}

Vec2.create = function() {
	var output = new Float32Array(new ArrayBuffer(2 << 2));
	output[0] = 0;
	output[1] = 0;
	return output;
}

Vec2.cross = function(output, a, b) {
	var z = a[0] * b[1] - a[1] * b[0];
	output[0] = output[1] = 0;
	output[2] = z;
	return output;
}

Vec2.dist = function(a, b) {
	return Vec2.distance(a, b);
}

Vec2.distance = function(a, b) {
	var x = b[0] - a[0];
	var y = b[1] - a[1];
	return Platform.sqrt(x * x + y * y);
}

Vec2.div = function(output, a, b) {
	return Vec2.divide(output, a, b);
}

Vec2.divide = function(output, a, b) {
	output[0] = a[0] / (b[0]);
	output[1] = a[1] / (b[1]);
	return output;
}

Vec2.dot = function(a, b) {
	return a[0] * b[0] + a[1] * b[1];
}

Vec2.fromValues = function(x, y) {
	var output = new Float32Array(new ArrayBuffer(2 << 2));
	output[0] = x;
	output[1] = y;
	return output;
}

Vec2.len = function(a) {
	return Vec2.length_(a);
}

Vec2.length_ = function(a) {
	var x = a[0];
	var y = a[1];
	return Platform.sqrt(x * x + y * y);
}

Vec2.lerp = function(output, a, b, t) {
	var ax = a[0];
	var ay = a[1];
	output[0] = ax + t * (b[0] - ax);
	output[1] = ay + t * (b[1] - ay);
	return output;
}

Vec2.max = function(output, a, b) {
	output[0] = GlMatrixMath.max(a[0], b[0]);
	output[1] = GlMatrixMath.max(a[1], b[1]);
	return output;
}

Vec2.min = function(output, a, b) {
	output[0] = GlMatrixMath.min(a[0], b[0]);
	output[1] = GlMatrixMath.min(a[1], b[1]);
	return output;
}

Vec2.mul = function(output, a, b) {
	return Vec2.multiply(output, a, b);
}

Vec2.multiply = function(output, a, b) {
	output[0] = a[0] * b[0];
	output[1] = a[1] * b[1];
	return output;
}

Vec2.negate = function(output, a) {
	output[0] = -a[0];
	output[1] = -a[1];
	return output;
}

Vec2.normalize = function(output, a) {
	var x = a[0];
	var y = a[1];
	var len = x * x + y * y;
	if (len > 0) {
		len = 1 / (Platform.sqrt(len));
		output[0] = a[0] * len;
		output[1] = a[1] * len;
	}
	return output;
}

Vec2.scale = function(output, a, b) {
	output[0] = a[0] * b;
	output[1] = a[1] * b;
	return output;
}

Vec2.scaleAndAdd = function(output, a, b, scale) {
	output[0] = a[0] + b[0] * scale;
	output[1] = a[1] + b[1] * scale;
	return output;
}

Vec2.set = function(output, x, y) {
	output[0] = x;
	output[1] = y;
	return output;
}

Vec2.sqrDist = function(a, b) {
	return Vec2.squaredDistance(a, b);
}

Vec2.sqrLen = function(a) {
	return Vec2.squaredLength(a);
}

Vec2.squaredDistance = function(a, b) {
	var x = b[0] - a[0];
	var y = b[1] - a[1];
	return x * x + y * y;
}

Vec2.squaredLength = function(a) {
	var x = a[0];
	var y = a[1];
	return x * x + y * y;
}

Vec2.sub = function(output, a, b) {
	return Vec2.subtract(output, a, b);
}

Vec2.subtract = function(output, a, b) {
	output[0] = a[0] - b[0];
	output[1] = a[1] - b[1];
	return output;
}

Vec2.transformMat2 = function(output, a, m) {
	var x = a[0];
	var y = a[1];
	output[0] = m[0] * x + m[2] * y;
	output[1] = m[1] * x + m[3] * y;
	return output;
}

Vec2.transformMat2d = function(output, a, m) {
	var x = a[0];
	var y = a[1];
	output[0] = m[0] * x + m[2] * y + m[4];
	output[1] = m[1] * x + m[3] * y + m[5];
	return output;
}

Vec2.transformMat3 = function(output, a, m) {
	var x = a[0];
	var y = a[1];
	output[0] = m[0] * x + m[3] * y + m[6];
	output[1] = m[1] * x + m[4] * y + m[7];
	return output;
}

Vec2.transformMat4 = function(output, a, m) {
	var x = a[0];
	var y = a[1];
	output[0] = m[0] * x + m[4] * y + m[12];
	output[1] = m[1] * x + m[5] * y + m[13];
	return output;
}

Vec2.prototype.f = function() {
}

function Vec3()
{
}

Vec3.add = function(output, a, b) {
	output[0] = a[0] + b[0];
	output[1] = a[1] + b[1];
	output[2] = a[2] + b[2];
	return output;
}

Vec3.cloneIt = function(a) {
	var output = new Float32Array(new ArrayBuffer(3 << 2));
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	return output;
}

Vec3.copy = function(output, a) {
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	return output;
}

Vec3.create = function() {
	var output = new Float32Array(new ArrayBuffer(3 << 2));
	output[0] = 0;
	output[1] = 0;
	output[2] = 0;
	return output;
}

Vec3.cross = function(output, a, b) {
	var ax = a[0];
	var ay = a[1];
	var az = a[2];
	var bx = b[0];
	var by = b[1];
	var bz = b[2];
	output[0] = ay * bz - az * by;
	output[1] = az * bx - ax * bz;
	output[2] = ax * by - ay * bx;
	return output;
}

Vec3.dist = function(a, b) {
	return Vec3.distance(a, b);
}

Vec3.distance = function(a, b) {
	var x = b[0] - a[0];
	var y = b[1] - a[1];
	var z = b[2] - a[2];
	return Platform.sqrt(x * x + y * y + z * z);
}

Vec3.div = function(output, a, b) {
	return Vec3.divide(output, a, b);
}

Vec3.divide = function(output, a, b) {
	output[0] = a[0] / (b[0]);
	output[1] = a[1] / (b[1]);
	output[2] = a[2] / (b[2]);
	return output;
}

Vec3.dot = function(a, b) {
	return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

Vec3.fromValues = function(x, y, z) {
	var output = new Float32Array(new ArrayBuffer(3 << 2));
	output[0] = x;
	output[1] = y;
	output[2] = z;
	return output;
}

Vec3.len = function(a) {
	return Vec3.length_(a);
}

Vec3.length_ = function(a) {
	var x = a[0];
	var y = a[1];
	var z = a[2];
	return Platform.sqrt(x * x + y * y + z * z);
}

Vec3.lerp = function(output, a, b, t) {
	var ax = a[0];
	var ay = a[1];
	var az = a[2];
	output[0] = ax + t * (b[0] - ax);
	output[1] = ay + t * (b[1] - ay);
	output[2] = az + t * (b[2] - az);
	return output;
}

Vec3.max = function(output, a, b) {
	output[0] = GlMatrixMath.max(a[0], b[0]);
	output[1] = GlMatrixMath.max(a[1], b[1]);
	output[2] = GlMatrixMath.max(a[2], b[2]);
	return output;
}

Vec3.min = function(output, a, b) {
	output[0] = GlMatrixMath.min(a[0], b[0]);
	output[1] = GlMatrixMath.min(a[1], b[1]);
	output[2] = GlMatrixMath.min(a[2], b[2]);
	return output;
}

Vec3.mul = function(output, a, b) {
	return Vec3.multiply(output, a, b);
}

Vec3.multiply = function(output, a, b) {
	output[0] = a[0] * b[0];
	output[1] = a[1] * b[1];
	output[2] = a[2] * b[2];
	return output;
}

Vec3.negate = function(output, a) {
	output[0] = 0 - a[0];
	output[1] = 0 - a[1];
	output[2] = 0 - a[2];
	return output;
}

Vec3.normalize = function(output, a) {
	var x = a[0];
	var y = a[1];
	var z = a[2];
	var len = x * x + y * y + z * z;
	if (len > 0) {
		var one = 1;
		len = one / (Platform.sqrt(len));
		output[0] = a[0] * len;
		output[1] = a[1] * len;
		output[2] = a[2] * len;
	}
	return output;
}

Vec3.scale = function(output, a, b) {
	output[0] = a[0] * b;
	output[1] = a[1] * b;
	output[2] = a[2] * b;
	return output;
}

Vec3.scaleAndAdd = function(output, a, b, scale) {
	output[0] = a[0] + b[0] * scale;
	output[1] = a[1] + b[1] * scale;
	output[2] = a[2] + b[2] * scale;
	return output;
}

Vec3.set = function(output, x, y, z) {
	output[0] = x;
	output[1] = y;
	output[2] = z;
	return output;
}

Vec3.sqrDist = function(a, b) {
	return Vec3.squaredDistance(a, b);
}

Vec3.sqrLen = function(a) {
	return Vec3.squaredLength(a);
}

Vec3.squaredDistance = function(a, b) {
	var x = b[0] - a[0];
	var y = b[1] - a[1];
	var z = b[2] - a[2];
	return x * x + y * y + z * z;
}

Vec3.squaredLength = function(a) {
	var x = a[0];
	var y = a[1];
	var z = a[2];
	return x * x + y * y + z * z;
}

Vec3.sub = function(output, a, b) {
	return Vec3.substract(output, a, b);
}

Vec3.substract = function(output, a, b) {
	output[0] = a[0] - b[0];
	output[1] = a[1] - b[1];
	output[2] = a[2] - b[2];
	return output;
}

Vec3.transformMat3 = function(output, a, m) {
	var x = a[0];
	var y = a[1];
	var z = a[2];
	output[0] = x * m[0] + y * m[3] + z * m[6];
	output[1] = x * m[1] + y * m[4] + z * m[7];
	output[2] = x * m[2] + y * m[5] + z * m[8];
	return output;
}

Vec3.transformMat4 = function(output, a, m) {
	var x = a[0];
	var y = a[1];
	var z = a[2];
	output[0] = m[0] * x + m[4] * y + m[8] * z + m[12];
	output[1] = m[1] * x + m[5] * y + m[9] * z + m[13];
	output[2] = m[2] * x + m[6] * y + m[10] * z + m[14];
	return output;
}

Vec3.transformQuat = function(output, a, q) {
	var x = a[0];
	var y = a[1];
	var z = a[2];
	var qx = q[0];
	var qy = q[1];
	var qz = q[2];
	var qw = q[3];
	var ix = qw * x + qy * z - qz * y;
	var iy = qw * y + qz * x - qx * z;
	var iz = qw * z + qx * y - qy * x;
	var iw = (0 - qx) * x - qy * y - qz * z;
	output[0] = ix * qw + iw * (0 - qx) + iy * (0 - qz) - iz * (0 - qy);
	output[1] = iy * qw + iw * (0 - qy) + iz * (0 - qx) - ix * (0 - qz);
	output[2] = iz * qw + iw * (0 - qz) + ix * (0 - qy) - iy * (0 - qx);
	return output;
}

Vec3.str = function(a) {
	return "";
}

function Vec4()
{
}

Vec4.add = function(output, a, b) {
	output[0] = a[0] + b[0];
	output[1] = a[1] + b[1];
	output[2] = a[2] + b[2];
	output[3] = a[3] + b[3];
	return output;
}

Vec4.cloneIt = function(a) {
	var output = new Float32Array(new ArrayBuffer(4 << 2));
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[3];
	return output;
}

Vec4.copy = function(output, a) {
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[3];
	return output;
}

Vec4.create = function() {
	var output = new Float32Array(new ArrayBuffer(4 << 2));
	output[0] = 0;
	output[1] = 0;
	output[2] = 0;
	output[3] = 0;
	return output;
}

Vec4.dist = function(a, b) {
	return Vec4.distance(a, b);
}

Vec4.distance = function(a, b) {
	var x = b[0] - a[0];
	var y = b[1] - a[1];
	var z = b[2] - a[2];
	var w = b[3] - a[3];
	return Platform.sqrt(x * x + y * y + z * z + w * w);
}

Vec4.div = function(output, a, b) {
	return Vec4.divide(output, a, b);
}

Vec4.divide = function(output, a, b) {
	output[0] = a[0] / (b[0]);
	output[1] = a[1] / (b[1]);
	output[2] = a[2] / (b[2]);
	output[3] = a[3] / (b[3]);
	return output;
}

Vec4.dot = function(a, b) {
	return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}

Vec4.fromValues = function(x, y, z, w) {
	var output = new Float32Array(new ArrayBuffer(4 << 2));
	output[0] = x;
	output[1] = y;
	output[2] = z;
	output[3] = w;
	return output;
}

Vec4.len = function(a) {
	return Vec4.length_(a);
}

Vec4.length_ = function(a) {
	var x = a[0];
	var y = a[1];
	var z = a[2];
	var w = a[3];
	return Platform.sqrt(x * x + y * y + z * z + w * w);
}

Vec4.lerp = function(output, a, b, t) {
	var ax = a[0];
	var ay = a[1];
	var az = a[2];
	var aw = a[3];
	output[0] = ax + t * (b[0] - ax);
	output[1] = ay + t * (b[1] - ay);
	output[2] = az + t * (b[2] - az);
	output[3] = aw + t * (b[3] - aw);
	return output;
}

Vec4.max = function(output, a, b) {
	output[0] = GlMatrixMath.max(a[0], b[0]);
	output[1] = GlMatrixMath.max(a[1], b[1]);
	output[2] = GlMatrixMath.max(a[2], b[2]);
	output[3] = GlMatrixMath.max(a[3], b[3]);
	return output;
}

Vec4.min = function(output, a, b) {
	output[0] = GlMatrixMath.min(a[0], b[0]);
	output[1] = GlMatrixMath.min(a[1], b[1]);
	output[2] = GlMatrixMath.min(a[2], b[2]);
	output[3] = GlMatrixMath.min(a[3], b[3]);
	return output;
}

Vec4.mul = function(output, a, b) {
	return Vec4.multiply(output, a, b);
}

Vec4.multiply = function(output, a, b) {
	output[0] = a[0] * b[0];
	output[1] = a[1] * b[1];
	output[2] = a[2] * b[2];
	output[3] = a[3] * b[3];
	return output;
}

Vec4.negate = function(output, a) {
	output[0] = -a[0];
	output[1] = -a[1];
	output[2] = -a[2];
	output[3] = -a[3];
	return output;
}

Vec4.normalize = function(output, a) {
	var x = a[0];
	var y = a[1];
	var z = a[2];
	var w = a[3];
	var len = x * x + y * y + z * z + w * w;
	if (len > 0) {
		var one = 1;
		len = one / (Platform.sqrt(len));
		output[0] = a[0] * len;
		output[1] = a[1] * len;
		output[2] = a[2] * len;
		output[3] = a[3] * len;
	}
	return output;
}

Vec4.scale = function(output, a, b) {
	output[0] = a[0] * b;
	output[1] = a[1] * b;
	output[2] = a[2] * b;
	output[3] = a[3] * b;
	return output;
}

Vec4.scaleAndAdd = function(output, a, b, scale) {
	output[0] = a[0] + b[0] * scale;
	output[1] = a[1] + b[1] * scale;
	output[2] = a[2] + b[2] * scale;
	output[3] = a[3] + b[3] * scale;
	return output;
}

Vec4.set = function(output, x, y, z, w) {
	output[0] = x;
	output[1] = y;
	output[2] = z;
	output[3] = w;
	return output;
}

Vec4.sqrDist = function(a, b) {
	return Vec4.squaredDistance(a, b);
}

Vec4.sqrLen = function(a) {
	return Vec4.squaredLength(a);
}

Vec4.squaredDistance = function(a, b) {
	var x = b[0] - a[0];
	var y = b[1] - a[1];
	var z = b[2] - a[2];
	var w = b[3] - a[3];
	return x * x + y * y + z * z + w * w;
}

Vec4.squaredLength = function(a) {
	var x = a[0];
	var y = a[1];
	var z = a[2];
	var w = a[3];
	return x * x + y * y + z * z + w * w;
}

Vec4.sub = function(output, a, b) {
	return Vec4.subtract(output, a, b);
}

Vec4.subtract = function(output, a, b) {
	output[0] = a[0] - b[0];
	output[1] = a[1] - b[1];
	output[2] = a[2] - b[2];
	output[3] = a[3] - b[3];
	return output;
}

Vec4.transformMat4 = function(output, a, m) {
	var x = a[0];
	var y = a[1];
	var z = a[2];
	var w = a[3];
	output[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
	output[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
	output[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
	output[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
	return output;
}

Vec4.prototype.f = function() {
}

Vec4.transformQuat = function(output, a, q) {
	var x = a[0];
	var y = a[1];
	var z = a[2];
	var qx = q[0];
	var qy = q[1];
	var qz = q[2];
	var qw = q[3];
	var ix = qw * x + qy * z - qz * y;
	var iy = qw * y + qz * x - qx * z;
	var iz = qw * z + qx * y - qy * x;
	var iw = -qx * x - qy * y - qz * z;
	output[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	output[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	output[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	return output;
}

function VecCito3i()
{
	this.x = 0;
	this.y = 0;
	this.z = 0;
}

VecCito3i.prototype.add = function(_x, _y, _z, result) {
	result.x = this.x + _x;
	result.y = this.y + _y;
	result.z = this.z + _z;
}

VecCito3i.citoCtr = function(_x, _y, _z) {
	var v = new VecCito3i();
	v.x = _x;
	v.y = _y;
	v.z = _z;
	return v;
}

function Vector3Float()
{
	this.value = null;
	this.x = 0;
	this.y = 0;
	this.z = 0;
}

function Vector3IntRef()
{
	this.x = 0;
	this.y = 0;
	this.z = 0;
}

Vector3IntRef.create = function(x, y, z) {
	var v = new Vector3IntRef();
	v.x = x;
	v.y = y;
	v.z = z;
	return v;
}

function Vector3Ref()
{
	this.x = null;
	this.y = null;
	this.z = null;
}

Vector3Ref.create = function(x, y, z) {
	var v = new Vector3Ref();
	v.x = x;
	v.y = y;
	v.z = z;
	return v;
}

Vector3Ref.prototype.getX = function() {
	return this.x;
}

Vector3Ref.prototype.getY = function() {
	return this.y;
}

Vector3Ref.prototype.getZ = function() {
	return this.z;
}

Vector3Ref.prototype.length = function() {
	return Platform.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
}

Vector3Ref.prototype.normalize = function() {
	var length = this.length();
	this.x = this.x / (length);
	this.y = this.y / (length);
	this.z = this.z / (length);
}

function VectorTool()
{
}

VectorTool.toVectorInFixedSystem = function(dx, dy, dz, orientationx, orientationy, output) {
	if (dx == 0 && dy == 0 && dz == 0) {
		output.x = 0;
		output.y = 0;
		output.z = 0;
		return;
	}
	var xRot = orientationx;
	var yRot = orientationy;
	var x = dx * Platform.cos(yRot) + dy * Platform.sin(xRot) * Platform.sin(yRot) - dz * Platform.cos(xRot) * Platform.sin(yRot);
	var y = dy * Platform.cos(xRot) + dz * Platform.sin(xRot);
	var z = dx * Platform.sin(yRot) - dy * Platform.sin(xRot) * Platform.cos(yRot) + dz * Platform.cos(xRot) * Platform.cos(yRot);
	output.x = x;
	output.y = y;
	output.z = z;
}

var VehicleDirection12 = {
	HORIZONTAL_LEFT : 0,
	HORIZONTAL_RIGHT : 1,
	VERTICAL_UP : 2,
	VERTICAL_DOWN : 3,
	UP_LEFT_UP : 4,
	UP_LEFT_LEFT : 5,
	UP_RIGHT_UP : 6,
	UP_RIGHT_RIGHT : 7,
	DOWN_LEFT_DOWN : 8,
	DOWN_LEFT_LEFT : 9,
	DOWN_RIGHT_DOWN : 10,
	DOWN_RIGHT_RIGHT : 11
}

function VehicleDirection12Flags()
{
}
VehicleDirection12Flags.DOWN_LEFT_DOWN = 256;
VehicleDirection12Flags.DOWN_LEFT_LEFT = 512;
VehicleDirection12Flags.DOWN_RIGHT_DOWN = 1024;
VehicleDirection12Flags.DOWN_RIGHT_RIGHT = 2048;
VehicleDirection12Flags.HORIZONTAL_LEFT = 1;
VehicleDirection12Flags.HORIZONTAL_RIGHT = 2;
VehicleDirection12Flags.NONE = 0;
VehicleDirection12Flags.UP_LEFT_LEFT = 32;
VehicleDirection12Flags.UP_LEFT_UP = 16;
VehicleDirection12Flags.UP_RIGHT_RIGHT = 128;
VehicleDirection12Flags.UP_RIGHT_UP = 64;
VehicleDirection12Flags.VERTICAL_DOWN = 8;
VehicleDirection12Flags.VERTICAL_UP = 4;

function VerticesIndicesToLoad()
{
	this.modelData = null;
	this.positionX = null;
	this.positionY = null;
	this.positionZ = null;
	this.texture = 0;
	this.transparent = false;
}

function VisibleDialog()
{
	this.key = null;
	this.screen = null;
	this.value = null;
}

function WearPlace_()
{
}
WearPlace_.BOOTS = 2;
WearPlace_.GAUNTLET = 4;
WearPlace_.HELMET = 3;
WearPlace_.MAIN_ARMOR = 1;
WearPlace_.RIGHT_HAND = 0;

function WebSocketClient()
{
	this.c = null;
	this.incomingData = null;
	this.p = null;
	this.incomingData = new Uint8Array(new ArrayBuffer(16384));
}
WebSocketClient.prototype = new NetClient();

WebSocketClient.prototype.connect = function(ip, port) {
	this.p.webSocketConnect(ip, port);
	this.c.address = this.p.stringFormat2("{0}:{1}", ip, this.p.intToString(port));
	this.c.platform = this.p;
	return this.c;
}

WebSocketClient.prototype.readMessage = function() {
	var received = this.p.webSocketReceive(this.incomingData, 16384);
	if (received == -1) {
		return null;
	}
	else {
		var msg = new NetIncomingMessage();
		msg.message = this.incomingData;
		msg.messageLength = received;
		msg.senderConnection = this.c;
		return msg;
	}
}

WebSocketClient.prototype.sendMessage = function(message, method) {
	this.c.sendMessage(message, method, 0);
}

WebSocketClient.prototype.setPlatform = function(platform) {
	this.p = platform;
}

WebSocketClient.prototype.start = function() {
	this.c = new WebSocketClientConnection();
}

function WebSocketClientConnection()
{
	this.address = null;
	this.platform = null;
}
WebSocketClientConnection.prototype = new NetConnection();

WebSocketClientConnection.prototype.equalsConnection = function(connection) {
	return true;
}

WebSocketClientConnection.prototype.remoteEndPoint = function() {
	return IPEndPointCiDefault.create(this.address);
}

WebSocketClientConnection.prototype.sendMessage = function(msg, method, sequenceChannel) {
	this.platform.webSocketSend(msg.message, msg.messageLength);
}

WebSocketClientConnection.prototype.update = function() {
}

var WidgetType = {
	BUTTON : 0,
	TEXTBOX : 1,
	LABEL : 2
}

var WindowState = {
	NORMAL : 0,
	MINIMIZED : 1,
	MAXIMIZED : 2,
	FULLSCREEN : 3
}

function Wire()
{
}
Wire.FIXED32 = 5;
Wire.FIXED64 = 1;
Wire.LENGTH_DELIMITED = 2;
Wire.VARINT = 0;

function WireframeCube()
{
}

WireframeCube.addVertex = function(model, x, y, z, u, v, color) {
	model.xyz[model.getXyzCount() + 0] = x;
	model.xyz[model.getXyzCount() + 1] = y;
	model.xyz[model.getXyzCount() + 2] = z;
	model.uv[model.getUvCount() + 0] = u;
	model.uv[model.getUvCount() + 1] = v;
	model.rgba[model.getRgbaCount() + 0] = Game.intToByte(Game.colorR(color));
	model.rgba[model.getRgbaCount() + 1] = Game.intToByte(Game.colorG(color));
	model.rgba[model.getRgbaCount() + 2] = Game.intToByte(Game.colorB(color));
	model.rgba[model.getRgbaCount() + 3] = Game.intToByte(Game.colorA(color));
	model.verticesCount++;
}

WireframeCube.drawLineLoop = function(m, p0, p1, p2, p3) {
	var startVertex = m.getVerticesCount();
	WireframeCube.addVertex(m, p0.x, p0.y, p0.z, 0, 0, Game.colorFromArgb(255, 255, 255, 255));
	WireframeCube.addVertex(m, p1.x, p1.y, p1.z, 0, 0, Game.colorFromArgb(255, 255, 255, 255));
	WireframeCube.addVertex(m, p2.x, p2.y, p2.z, 0, 0, Game.colorFromArgb(255, 255, 255, 255));
	WireframeCube.addVertex(m, p3.x, p3.y, p3.z, 0, 0, Game.colorFromArgb(255, 255, 255, 255));
	m.indices[m.indicesCount++] = startVertex + 0;
	m.indices[m.indicesCount++] = startVertex + 1;
	m.indices[m.indicesCount++] = startVertex + 1;
	m.indices[m.indicesCount++] = startVertex + 2;
	m.indices[m.indicesCount++] = startVertex + 2;
	m.indices[m.indicesCount++] = startVertex + 3;
	m.indices[m.indicesCount++] = startVertex + 3;
	m.indices[m.indicesCount++] = startVertex + 0;
}

WireframeCube.get = function() {
	var m = new ModelData();
	m.setMode(1);
	m.xyz = new Float32Array(new ArrayBuffer(72 << 2));
	m.uv = new Float32Array(new ArrayBuffer(48 << 2));
	m.rgba = new Uint8Array(new ArrayBuffer(96));
	m.indices = new Int32Array(new ArrayBuffer(48 << 2));
	WireframeCube.drawLineLoop(m, Vector3Ref.create(-1, -1, -1), Vector3Ref.create(-1, 1, -1), Vector3Ref.create(1, 1, -1), Vector3Ref.create(1, -1, -1));
	WireframeCube.drawLineLoop(m, Vector3Ref.create(-1, -1, -1), Vector3Ref.create(1, -1, -1), Vector3Ref.create(1, -1, 1), Vector3Ref.create(-1, -1, 1));
	WireframeCube.drawLineLoop(m, Vector3Ref.create(-1, -1, -1), Vector3Ref.create(-1, -1, 1), Vector3Ref.create(-1, 1, 1), Vector3Ref.create(-1, 1, -1));
	WireframeCube.drawLineLoop(m, Vector3Ref.create(-1, -1, 1), Vector3Ref.create(1, -1, 1), Vector3Ref.create(1, 1, 1), Vector3Ref.create(-1, 1, 1));
	WireframeCube.drawLineLoop(m, Vector3Ref.create(-1, 1, -1), Vector3Ref.create(-1, 1, 1), Vector3Ref.create(1, 1, 1), Vector3Ref.create(1, 1, -1));
	WireframeCube.drawLineLoop(m, Vector3Ref.create(1, -1, -1), Vector3Ref.create(1, 1, -1), Vector3Ref.create(1, 1, 1), Vector3Ref.create(1, -1, 1));
	return m;
}
